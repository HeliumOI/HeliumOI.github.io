<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PKUSC 2022 游记</title>
      <link href="/archives/2101398000/"/>
      <url>/archives/2101398000/</url>
      
        <content type="html"><![CDATA[<h2 id="day--1">Day -1</h2><p>因疫情原因，PKUSC 2022 改为线上进行。</p><p>听教练说审核通过了，好耶。</p><p><del>如果不是线上进行，像你这种菜鸡也不可能报名通过好吧。</del></p><p>听说信息组别的同学报的都是 THUSC……我是不是脑抽（其实是因为 THUSC 的报名信息没时间填写（PKUSC 只有一个简单的报名表格。）</p><h2 id="day-0">Day 0</h2><p>又是备战中考的一天。</p><p><del>你再怎么准备 PKUSC 也不可能拿奖，你在想什么。</del></p><h2 id="day-1">Day 1</h2><p>雅礼集团好像只有我和 lrj 学长报了 PKUSC（</p><p>试机题不会。</p><p>T1 概率期望，T2 计算几何，T3 概率期望。</p><p>恰好都是我平时从来不学的技能。</p><p>《如果早知道，PKUSC 有三道数学题》</p><p>T1 应该是消元但写了半天发现读错题了，读完题之后还是不会。</p><p>T2 先写了个暴力，枚举累加每一条线段在长方形区域内的部分的长度。Subtask 3 不懂性质，Subtask 4 中所有线段的斜率都是 -1 然而我还是不会（</p><p>T3 Subtask1 考虑每只猫的比值 <span class="math inline">\(c\)</span> 都相等，就变成了解一个方程，剩下的部分分好像是高斯消元？然而还是不会写（</p><p>Day1：0 + 18 + 12 = 30，告辞</p><p>晚上打了场 ABC，结果中途被拉去填表，只写出前三题，还好用的小号（</p><h2 id="day-2">Day 2</h2><p>T1 概率，T2 树上问题，T3 大模拟（？）</p><p>T1 想了 30min 毫无思路。</p><p>T2 先写了个暴力，然而后面的 Subtask 还是不会维护。</p><p>T3 大模拟，花 2h 过了前两个 Subtask，后面应该需要用数据结构维护或者是奇怪的剪枝优化，然而还是不会，寄。</p><p>Day2：0 + 9 + 25 = 34</p><p>PKUSC：0 + 18 + 12 + 0 + 18 + 12 = 64</p><h2 id="ending">Ending</h2><p>中考，你好。</p><blockquote><p>原谅我总是分不清　坚强和倔强<br />原谅我总是看着　没有尽头的远方<br />天亮那路在呼唤　我的行囊和我的吉他<br />原谅我的不陪伴　我已经出发　原谅我<br />像孤单的旅行家　这人生一路风沙<br />却固执看着前方</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
            <tag> PKUSC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联合省选 2022 游记</title>
      <link href="/archives/3668593493/"/>
      <url>/archives/3668593493/</url>
      
        <content type="html"><![CDATA[<h2 id="day--8">Day -8</h2><p>打了带花树的板子。</p><p>没用的知识增加了。（省选考这种东西吗。）</p><h2 id="day--6">Day -6</h2><p>在 CodeForces 上和 hzk 组队 VP 了场 ICPC（2019-2020 ICPC, NERC, Southern and Volga Russian Regional Contest），打得还不错，应该不会提前用掉 RP？（RP++）</p><p>然后一看 QQ 群才发现同学们都在写 Public OJ 的模拟赛。（小丑竟是我自己）</p><h2 id="day--4">Day -4</h2><p>打了 KD-Tree 的板子（天使玩偶）。</p><p>没用的知识又增加了。</p><h2 id="day--1">Day -1</h2><p>日常在家里上网课，省选对初中生来说可能不太重要？信息组也没有什么停课之类的安排，初三最重要的还是中考。</p><h2 id="day-0">Day 0</h2><p>上午信息组召开动员大会（由于疫情影响，动员大会转为线上在腾讯会议进行。），然后打了 FFT、NTT、MTT 和几个多项式全家桶，中途调试 1h+，然后去打数据结构，线段树、Splay、分块、珂朵莉树（省选真的可能考这玩意吗）。打板子的效率不高，可能本来对省选就没抱什么期望？<del>反正现在连中考都比省选更重要，中考考不好省选有个锤子用。</del></p><p>下午继续打板子，SAM 打完之后又发现挂了，继续肉眼找错。</p><p>7点牛客挑战赛，交了一发 A 题之后跑路。（事后一看竟然上分了？）</p><p>随便打了一下图论的板子。</p><h2 id="day-1">Day 1</h2><p>省选地点在雅礼书院，学校不提供接送，参赛选手自己前往考试地点。</p><p>进考场前在包里翻了一下没找到准考证，慌得一批的我立刻打电话给教练，当教练打印好准考证准备送过来时我又在包里找到准考证了。（被教练 diss 不可避免）</p><p>开考后先看半个小时题目。</p><p>T1 大模拟，T2 像是树形 DP 或者是奇怪的图论多项式/线性代数计数，T3 第一眼没看出什么但好像有白给一部分分。</p><p>T1 好像最可做所以先写，直接把字符串分割成标识符然后再递归处理，判断宏的部分用一个 Trie。写完后调了半个小时，然后发现之前对 <code>substr</code> 有误解（<code>substr</code> 返回的是从指定位置往后若干个字符组成的字符串），改了之后输出大体上对了，但输出结果中不知道为什么混杂了很多换行符。又调了一会，发现 C++ 在读入 string 时会顺带读入换行符？也不知道为什么之前没注意到这个问题，也有可能是 <code>fgets</code> 的问题？判断并去掉字符串末尾的换行符后样例过了。手造了几组样例好像没什么问题，去看 T2。</p><p>我平时就不会写数数，既不会 DP 也不会 Matrix-Tree 或者多项式之类的东西，想了一下 10 pts 暴力分感觉不太好拿，去看 T3。</p><p>T3 搜索有 4 pts，进行最优剪枝后共有 8 pts，直接输出楼上消息和楼下消息的总数又有白给的 20 pts。</p><p>T2 暴力和 T3 的其它部分分都不会打，自闭了。</p><p>出考场后：</p><p>hzk：“T2 明显是个拉格朗日插值。”</p><p>zym：“T3 网络流。”</p><p>sxh：“T2 只要枚举最大最小值树形 DP 就有 40 pts。”</p><p>我：“……”</p><p>下午体育锻炼，做核酸。</p><p>T1 洛谷自测只有 80 pts？奇奇怪怪的地方又写挂了。</p><p>晚上打了 AtCoder Beginner Contest 248，写出 A～F 然后就不会了，继续自闭。</p><h2 id="day-2">Day 2</h2><p>进场先看题，T1 根号分治，T2 应该有结论或者区间 DP，T3 奇怪的树上操作？</p><p>先写 T1 暴力 20 pts，然后写了个根号分治 + DP，不出意外地挂了。再去看 T2，感觉暴力分没什么思路。这时感觉肚子不舒服，向监考老师举手，然后被告知前面还排着一堆要上厕所的人。（？）过了半个小时排到我，回考场后写了个奇怪的贪心，从左往右找符合要求的括号对，也不知道能拿多少分？继续肚子疼，再次向监考老师举手时监考老师一脸黑线地让我先去。</p><p>回来之后状态好多了，去看 T3，先写暴力。写完暴力之后考虑树形 DP，好像不太行？在考虑奇怪的树上操作，好像也不太行？</p><p>达成成就：Day2 全程罚坐。</p><p>出考场后：</p><p>hzk：“第二题就是一个裸的根号分治 + FWT。”</p><p>我：“……”</p><p>下午教练请我们信息组去必胜客大吃一顿，<del>没有复现去年 NOIP 考完后在必胜客的可乐大爆炸是个遗憾。</del></p><p>期望得分：100 + 0 + 28 + 25 + 8 + 12 = 173</p><p>实际分数：90 + 0 + 20 + 25 + 0 + 12 = 147</p><p>三年 OI 一场空，高中努力吧。</p><blockquote><p>A+B Problem，似乎在梦里见过的样子……<br />NOIP 2018，那真是太令人高兴了<br />CSP-S 2019，已经没什么好害怕的了<br />洛谷的朋友们，奇迹、魔法，都是存在的<br />CSP-S 2020，怎么可能会后悔<br />NOI Online 2021，这种事绝对很奇怪啊<br />APIO 2021，你能面对真正的内心吗？<br />Candidate Master，我，真是个笨蛋<br />CSP-S 2021，那样的事，我绝不容许<br />NOIP 2021，再也不依靠任何人<br />联合省选 2022，最后留下的路标<br />中考，我最好的朋友</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游记 </tag>
            
            <tag> 省选 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA11383 Golden Tiger Claw 题解</title>
      <link href="/archives/2111054984/"/>
      <url>/archives/2111054984/</url>
      
        <content type="html"><![CDATA[<h2 id="分析">分析</h2><p>我们会发现这道题本质上是一个线性规划问题：</p><p><span class="math display">\[h_i + l_j \ge w_{i,j}\]</span> <span class="math display">\[h_i \ge 0 (\forall 1 \le i \le n)\]</span> <span class="math display">\[l_j \ge 0 (\forall 1 \le j \le n)\]</span> <span class="math display">\[\operatorname{minimize} \sum_{i = 1}^{n} h_i + \sum_{j = 1}^{n} l_j\]</span></p><p>我们考虑它的对偶线性规划。</p><h3 id="对偶线性规划">对偶线性规划</h3><p>所谓对偶线性规划是指：</p><ul><li>原问题中的每个变量都变为对偶问题中的一个限制条件；</li><li>原问题中的每个限制条件都变为对偶问题中的一个变量；</li><li>原问题若是求目标函数的最大值，则对偶问题是求最小值，反之亦然。</li></ul><p>另外还有“强对偶定理”，通俗的来说就是原问题的最优解等于对偶问题的最优解。</p><p>例如本题的对偶线性规划为：</p><p><span class="math display">\[\sum_{j = 1}^{n} y_{i, j} \le 1 (\forall 1 \le i \le n) \]</span> <span class="math display">\[\sum_{i = 1}^{n} y_{i, j} \le 1 (\forall 1 \le j \le n) \]</span> <span class="math display">\[y_{i, j} \ge 0 \]</span> <span class="math display">\[\operatorname{maximize} \sum_{(i, j)} w_{i, j} y_{i, j}\]</span></p><p>注意到这正好是二分图最大权匹配问题，所以可以用 KM 算法解决。</p><p>（绕了一个大圈……事实上 KM 算法本身的原理就是解决二分图最大权匹配问题的对偶问题“二分图最小顶标和问题”，即本问题。换句话说，KM 算法本身就会保证算法结束后顶标最小。）</p><h2 id="代码">代码</h2><p>KM 算法的模版。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> e[MAXN][MAXN], la[MAXN], lb[MAXN], slack[MAXN];</span><br><span class="line"><span class="type">int</span> match[MAXN], last[MAXN];</span><br><span class="line"><span class="type">bool</span> va[MAXN], vb[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> fa)</span> </span>&#123;</span><br><span class="line">    va[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(vb[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(la[u] + lb[v] == e[u][v]) &#123;</span><br><span class="line">            vb[v] = <span class="literal">true</span>;</span><br><span class="line">            last[v] = fa;</span><br><span class="line">            <span class="keyword">if</span>(!match[v] || <span class="built_in">dfs</span>(match[v], v)) &#123;</span><br><span class="line">                match[v] = u;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(slack[v] &gt; la[u] + lb[v] - e[u][v]) &#123;</span><br><span class="line">            slack[v] = la[u] + lb[v] - e[u][v];</span><br><span class="line">            last[v] = fa;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">KM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(match + <span class="number">1</span>, match + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">fill</span>(last + <span class="number">1</span>, last + n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        la[i] = -INF;</span><br><span class="line">        lb[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            la[i] = <span class="built_in">max</span>(la[i], e[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">fill</span>(va + <span class="number">1</span>, va + n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">fill</span>(vb + <span class="number">1</span>, vb + n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">fill</span>(slack + <span class="number">1</span>, slack + n + <span class="number">1</span>, INF);</span><br><span class="line">        <span class="type">int</span> st = <span class="number">0</span>; match[st] = i;</span><br><span class="line">        <span class="keyword">while</span>(match[st]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(match[st], st)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="type">int</span> delta = INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!vb[j] &amp;&amp; delta &gt; slack[j]) &#123;</span><br><span class="line">                    delta = slack[j];</span><br><span class="line">                    st = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(va[j]) la[j] -= delta;</span><br><span class="line">                <span class="keyword">if</span>(vb[j]) lb[j] += delta; <span class="keyword">else</span> slack[j] -= delta;</span><br><span class="line">            &#125;</span><br><span class="line">            vb[st] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(st) &#123;</span><br><span class="line">            match[st] = match[last[st]];</span><br><span class="line">            st = last[st];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;e[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">KM</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, la[i]);</span><br><span class="line">            ans += la[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, lb[i]);</span><br><span class="line">            ans += lb[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> UVa </tag>
            
            <tag> KM </tag>
            
            <tag> 二分图带权匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 UVA1324 Bring Them There</title>
      <link href="/archives/2022708006/"/>
      <url>/archives/2022708006/</url>
      
        <content type="html"><![CDATA[<h2 id="题目分析">题目分析</h2><p>可以看出这道题应该用网络流解决，但如果单纯使用网络流的话，“每条隧道需要一天时间来通过”就无法处理了。</p><p>在这道题中，我们注意到每台计算机能否移动与图当前的状态有关，而图当前的状态又与“时间”这一参数有关，所以我们建图时就应该考虑时间的影响，换句话说，建分层图。假设一共运送了 <span class="math inline">\(T\)</span> 天，那么我们就可以将每个点 <span class="math inline">\(u\)</span> 拆成 <span class="math inline">\(T + 1\)</span> 个点 <span class="math inline">\(u_0\)</span>、<span class="math inline">\(u_2\)</span>、<span class="math inline">\(u_3\)</span>、……、<span class="math inline">\(u_T\)</span>，<span class="math inline">\(u_i\)</span> 表示第 <span class="math inline">\(i\)</span> 天的节点 <span class="math inline">\(u\)</span>，具体实现时则使用 <span class="math inline">\(u_i = u + in\)</span> 的方式来表示。</p><p>对于一条无向边 <span class="math inline">\((u, v)\)</span>，我们从 <span class="math inline">\(u_i\)</span> 向 <span class="math inline">\(v_{i + 1}\)</span> 连容量为 <span class="math inline">\(1\)</span> 的边，从 <span class="math inline">\(v_i\)</span> 向 <span class="math inline">\(u_{i + 1}\)</span> 连容量为 <span class="math inline">\(1\)</span> 的边，表示飞船可以花一天的时间从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 或从 <span class="math inline">\(v\)</span> 到 <span class="math inline">\(u\)</span>。同时，对于每一个节点 <span class="math inline">\(u\)</span>，我们都从 <span class="math inline">\(u_i\)</span> 向 <span class="math inline">\(u_{i + 1}\)</span> 连容量为正无穷的边，表示飞船可以待在原地不动。</p><p>首先能想到二分 <span class="math inline">\(T\)</span> 。但也可以一层一层建图（每次将 <span class="math inline">\(T\)</span> 增加 <span class="math inline">\(1\)</span>。），每建完一层就在上一次的残量网络上跑从 <span class="math inline">\(s_0\)</span> 到 <span class="math inline">\(t_T\)</span> 的最大流，直到最大流达到 <span class="math inline">\(k\)</span> 为止。（达到 <span class="math inline">\(k\)</span> 时立即停止，这一点可以通过在增广时对初始流量进行限制来实现。）</p><p>另一个比较棘手的问题是如何输出方案。事实上，第 <span class="math inline">\(i\)</span> 天时所有计算机的动向的信息就保存在第 <span class="math inline">\(i\)</span> 层分层图中，如果从 <span class="math inline">\(u_i\)</span> 到 <span class="math inline">\(v_{i + 1}\)</span> 的边满流，就意味着在第 <span class="math inline">\(i + 1\)</span> 天有一台计算机从 <span class="math inline">\(u\)</span> 移动到 <span class="math inline">\(v\)</span>。（因为所有计算机彼此之间没有区别，所以从 <span class="math inline">\(u_i\)</span> 到 <span class="math inline">\(v_{i + 1}\)</span> 的边和从 <span class="math inline">\(v_i\)</span> 到 <span class="math inline">\(u_{i + 1}\)</span> 的边都满流可以被视作相互抵消。）</p><p>所以我们可以先记录所有“移动事件”，再对于每一个从 <span class="math inline">\((u, v)\)</span> 的移动，随便找一台当前位置为 <span class="math inline">\(u\)</span> 的计算机，将它的位置改为 <span class="math inline">\(v\)</span> 并输出。当然，因为一台计算机一天只能移动一次，我们必须记录每台计算机当天是否已经移动过了，如果已经移动过了就不再移动。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">50</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line">Edge e[MAXM];</span><br><span class="line">pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mov[MAXM];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> pos[MAXK];</span><br><span class="line"><span class="type">bool</span> blk[MAXK];</span><br><span class="line"><span class="type">int</span> head[MAXN], to[MAXM], nxt[MAXM], flow[MAXM], cap[MAXM];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dep[MAXN], cur[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, k, s, T, t;</span><br><span class="line"><span class="type">int</span> cnt, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    to[tot] = v;</span><br><span class="line">    nxt[tot] = head[u];</span><br><span class="line">    flow[tot] = f;</span><br><span class="line">    cap[tot] = c;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">0</span>; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cap[i] &gt; flow[i] &amp;&amp; dep[to[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                dep[to[i]] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">                <span class="keyword">if</span>(to[i] == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t || limit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rest = limit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; i = cur[u]; i != <span class="number">0</span>; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cap[i] &gt; flow[i] &amp;&amp; dep[to[i]] == dep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">dinic</span>(to[i], <span class="built_in">min</span>(rest, cap[i] - flow[i]));</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">                dep[to[i]] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flow[i] += k;</span><br><span class="line">            flow[i ^ <span class="number">1</span>] -= k;</span><br><span class="line">            rest -= k;</span><br><span class="line">            <span class="keyword">if</span>(rest == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> limit - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxflow</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, head, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        res += <span class="built_in">dinic</span>(s, limit - res); <span class="comment">//流量限制，确保流量正好为 $k$</span></span><br><span class="line">        <span class="keyword">if</span>(res == limit) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        pos[i] = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> now = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(blk, <span class="number">0</span>, <span class="built_in">sizeof</span>(blk));</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(flow[now] == <span class="number">1</span> &amp;&amp; flow[now + <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                mov[++ans] = <span class="built_in">make_pair</span>(e[j].u, e[j].v);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flow[now] == <span class="number">0</span> &amp;&amp; flow[now + <span class="number">2</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">                mov[++ans] = <span class="built_in">make_pair</span>(e[j].v, e[j].u);</span><br><span class="line">            &#125;</span><br><span class="line">            now += <span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        now += n * <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= ans; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>; p &lt;= k; p++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(blk[p]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(pos[p] == mov[j].first) &#123;</span><br><span class="line">                    pos[p] = mov[j].second;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot; %d %d&quot;</span>, p, pos[p]);</span><br><span class="line">                    blk[p] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k, &amp;s, &amp;T) == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;e[i].u, &amp;e[i].v);</span><br><span class="line">        &#125;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(sum &lt; k) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            t = cnt * n + T;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(e[i].u + (cnt - <span class="number">1</span>) * n, e[i].v + cnt * n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">addEdge</span>(e[i].v + cnt * n, e[i].u + (cnt - <span class="number">1</span>) * n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">addEdge</span>(e[i].v + (cnt - <span class="number">1</span>) * n, e[i].u + cnt * n, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">addEdge</span>(e[i].u + cnt * n, e[i].v + (cnt - <span class="number">1</span>) * n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i + (cnt - <span class="number">1</span>) * n, i + cnt * n, INF, <span class="number">0</span>);</span><br><span class="line">                <span class="built_in">addEdge</span>(i + cnt * n, i + (cnt - <span class="number">1</span>) * n, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sum += <span class="built_in">maxflow</span>(k - sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, cnt);</span><br><span class="line">        <span class="built_in">output</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> UVa </tag>
            
            <tag> 最大流 </tag>
            
            <tag> 分层图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 UVA11248 Frequency Hopping</title>
      <link href="/archives/2012849851/"/>
      <url>/archives/2012849851/</url>
      
        <content type="html"><![CDATA[<h2 id="题目分析">题目分析</h2><p>对于第一种情况，可以直接跑一遍最大流，如果最大流大于或等于 <span class="math inline">\(C\)</span> 就可以直接输出 <code>possible</code>。</p><p>如果最大流小于 <span class="math inline">\(C\)</span>，那么肯定是满流的边将其“卡住了”，所以应该依次枚举每条满流的边（没有满流的边增加容量也一定没用），将这些边的容量一个一个改为 <span class="math inline">\(C\)</span>，再对于每条边修改后都跑一次最大流，如果这条边的容量改为 <span class="math inline">\(C\)</span> 后最大流大于或等于 <span class="math inline">\(C\)</span> 就将其记录到答案中。</p><p>除此之外还有两个个必要的优化：一、没必要每次都从头开始跑一遍最大流。在跑完第一遍之后将残量网络备份下来，每次改变边的容量时在残量网络上跑最大流，少做很多无用功；二，不需要每次都把最大流求出来，可以在最大流达到 <span class="math inline">\(C\)</span> 时停止增广。</p><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> from, to, cap, flow, nxt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">10000</span> * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; ans;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">Edge e[MAXM], tmp[MAXM];</span><br><span class="line"><span class="type">int</span> head[MAXN];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dep[MAXN], cur[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, k, s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    tot = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(e, <span class="number">0</span>, <span class="built_in">sizeof</span>(e));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    e[tot].from = u;</span><br><span class="line">    e[tot].to = v;</span><br><span class="line">    e[tot].cap = c;</span><br><span class="line">    e[tot].flow = f;</span><br><span class="line">    e[tot].nxt = head[u];</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">0</span>; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap &gt; e[i].flow &amp;&amp; dep[e[i].to] == <span class="number">0</span>) &#123;</span><br><span class="line">                dep[e[i].to] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(e[i].to);</span><br><span class="line">                <span class="keyword">if</span>(e[i].to == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t || limit == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> limit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rest = limit;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; i = cur[u]; i != <span class="number">0</span>; i = e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].cap &gt; e[i].flow &amp;&amp; dep[e[i].to] == dep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">dinic</span>(e[i].to, <span class="built_in">min</span>(rest, e[i].cap - e[i].flow));</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">                dep[e[i].to] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e[i].flow += k;</span><br><span class="line">            e[i ^ <span class="number">1</span>].flow -= k;</span><br><span class="line">            rest -= k;</span><br><span class="line">            <span class="keyword">if</span>(rest == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> limit - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxflow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, head, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        res += <span class="built_in">dinic</span>(s, INF);</span><br><span class="line">        <span class="keyword">if</span>(res &gt;= k) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> kase = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        kase++;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span> &amp;&amp; k == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v, c;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;c);</span><br><span class="line">            <span class="built_in">addEdge</span>(u, v, c, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">addEdge</span>(v, u, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s = <span class="number">1</span>; t = n;</span><br><span class="line">        <span class="type">int</span> sum = <span class="built_in">maxflow</span>();</span><br><span class="line">        <span class="keyword">if</span>(sum &gt;= k) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case %d: possible\n&quot;</span>, kase);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">memcpy</span>(tmp, e, <span class="built_in">sizeof</span>(e)); <span class="comment">//备份残量网络</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= tot; i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i].cap == e[i].flow) &#123;</span><br><span class="line">                e[i].cap = k;</span><br><span class="line">                <span class="keyword">if</span>(sum + <span class="built_in">maxflow</span>() &gt;= k) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(e[i].from, e[i].to));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">memcpy</span>(e, tmp, <span class="built_in">sizeof</span>(tmp)); <span class="comment">//跑完最大流后将残量网络还原</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Case %d: not possible\n&quot;</span>, kase);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: possible option:(%d,%d)&quot;</span>, kase, ans[<span class="number">0</span>].first, ans[<span class="number">0</span>].second);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; ans.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;,(%d,%d)&quot;</span>, ans[i].first, ans[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> UVa </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3410 拍照</title>
      <link href="/archives/2787416393/"/>
      <url>/archives/2787416393/</url>
      
        <content type="html"><![CDATA[<h2 id="题目分析">题目分析</h2><p>如果我们将要求拍照的人和下属之间按照要求关系连有向边，我们就会发现题目实际上是要求我们求出有向图的最大权闭合子图。即，在一张有向图上选择一个点集，要求点集中的每一个点的后继也都在这个点集中，使点集中点权和最大。</p><p>对于这类问题，有一个结论：<strong>从源点向所有正权点连边，边权为原点权；从所有负权点向汇点连边，边权为原点权的绝对值；原图中的边权设为正无穷。则最大权闭合子图的权值和 = 所有正权点的权值和 - 新图的最小割。</strong></p><h3 id="对结论的证明">对结论的证明</h3><p>我们先做如下约定：</p><ol type="1"><li>割掉源点与正权点 <span class="math inline">\(u\)</span> 之间的边，表示不选择点 <span class="math inline">\(u\)</span> 进入子图。</li><li>割掉负权点 <span class="math inline">\(v\)</span> 与汇点之间的边，表示选择点 <span class="math inline">\(v\)</span> 进入子图。</li></ol><p>则我们跑一遍最小割后得到的一定是闭合子图，证明如下：考虑任意得到的子图内的任意正权点 <span class="math inline">\(u\)</span>，若存在其后继节点 <span class="math inline">\(v\)</span> 没有被选择进入子图，分为两种情况：如果 <span class="math inline">\(v\)</span> 权值为负，按照上述约定，点 <span class="math inline">\(v\)</span> 与汇点间的边会被保留，源点与汇点联通，与最小割的定义矛盾；如果 <span class="math inline">\(v\)</span> 权值为正，按照上述约定，源点与点 <span class="math inline">\(v\)</span> 间的边会被割掉，但点 <span class="math inline">\(u\)</span> 与点 <span class="math inline">\(v\)</span> 联通，不割掉源点与点 <span class="math inline">\(v\)</span> 间的边仍然是一个割，且权值和更小，与最小割的定义矛盾。</p><p>因为最大权闭合子图的权值和为：</p><p>被选的正权点权值和 - 被选的负权点权值和的绝对值</p><p>等价于</p><p>所有正权点的权值和 - (不被选的正权点的权值和 + 被选的负权点权值和的绝对值)</p><p>而根据先前的约定，我们可以得到：</p><p>最小割 = 不被选的正权点的权值和 + 被选的负权点权值和的绝对值</p><p>所以</p><p><strong>最大权闭合子图的权值和 = 所有正权点的权值和 - 新图的最小割</strong></p><h2 id="代码实现">代码实现</h2><p>因为最大流=最小割，所以跑一边最大流即可。笔者在这里选择使用 Dinic 算法来实现代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = INT_MAX;</span><br><span class="line"></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> head[MAXN], to[MAXM], nxt[MAXM], flow[MAXM], cap[MAXM];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dep[MAXN], cur[MAXN];</span><br><span class="line"><span class="type">int</span> m, n, s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> c, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    to[tot] = v;</span><br><span class="line">    nxt[tot] = head[u];</span><br><span class="line">    flow[tot] = f;</span><br><span class="line">    cap[tot] = c;</span><br><span class="line">    head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dep, <span class="number">0</span>, <span class="built_in">sizeof</span>(dep));</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    dep[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = head[u]; i != <span class="number">0</span>; i = nxt[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cap[i] &gt; flow[i] &amp;&amp; dep[to[i]] == <span class="number">0</span>) &#123;</span><br><span class="line">                dep[to[i]] = dep[u] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(to[i]);</span><br><span class="line">                <span class="keyword">if</span>(to[i] == t) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dinic</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == t || f == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> rest = f;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>&amp; i = cur[u]; i != <span class="number">0</span>; i = nxt[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span>(cap[i] &gt; flow[i] &amp;&amp; dep[to[i]] == dep[u] + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="built_in">dinic</span>(to[i], <span class="built_in">min</span>(rest, cap[i] - flow[i]));</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) &#123;</span><br><span class="line">                dep[to[i]] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flow[i] += k;</span><br><span class="line">            flow[i ^ <span class="number">1</span>] -= k;</span><br><span class="line">            rest -= k;</span><br><span class="line">            <span class="keyword">if</span>(rest == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f - rest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line">    s = m + n + <span class="number">1</span>;</span><br><span class="line">    t = m + n + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v, p;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">        sum += v;</span><br><span class="line">        <span class="built_in">addEdge</span>(s, i, v, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">addEdge</span>(i, s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">            <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">addEdge</span>(i, p + m, INF, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">addEdge</span>(p + m, i, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">        <span class="built_in">addEdge</span>(i + m, t, v, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">addEdge</span>(t, i + m, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> maxflow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>()) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cur, head, <span class="built_in">sizeof</span>(head));</span><br><span class="line">        maxflow += <span class="built_in">dinic</span>(s, INF);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum - maxflow);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 网络流 </tag>
            
            <tag> 最小割 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF940F Machine Learning</title>
      <link href="/archives/4081384378/"/>
      <url>/archives/4081384378/</url>
      
        <content type="html"><![CDATA[<h2 id="思路">思路</h2><p>一道带修莫队模板题。</p><p>看到题意中“单点修改，区间查询数字出现次数 <span class="math inline">\(mex\)</span>” 的操作后，不难想到用带修莫队维护，但时间复杂度的正确性需要证明。</p><p>假设区间当前区间的 <span class="math inline">\(mex\)</span> 为 <span class="math inline">\(n\)</span>，则这个区间的数的个数至少为</p><p><span class="math display">\[\sum\limits_{i = 1}^{n}i = \dfrac{n(n + 1)}{2}\]</span></p><p>所以任何区间的答案肯定在 <span class="math inline">\(O(\sqrt{n})\)</span> 级别，可以直接暴力查找 <span class="math inline">\(mex\)</span>。</p><p>代码中也有一些要注意的细节：<span class="math inline">\(x_i\)</span> 最大可以为 <span class="math inline">\(10^9\)</span>，所以序列中的数和修改中的数都必须离散化。</p><p>统计时开两个数组，一个数组 <code>cnt</code> 统计每个数出现了几次，<code>tot</code> 统计这个出现次数出现了几次。由于 <code>add</code> 和 <code>del</code> 操作都会使 <code>tot</code> 数组改变两次，所以每次操作都要更新两遍 <span class="math inline">\(mex\)</span>。具体操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    tot[cnt[x]]--;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">0</span>) &#123;</span><br><span class="line">        mex = <span class="built_in">min</span>(mex, cnt[x]); <span class="comment">//可能出现了更小的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    tot[cnt[x]]++;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">1</span> &amp;&amp; mex == cnt[x]) &#123; <span class="comment">//当前答案已经出现，向上寻找符合要求的 mex</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mex; i &lt;= siz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tot[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                mex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    tot[cnt[x]]--;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">0</span>) &#123;</span><br><span class="line">        mex = <span class="built_in">min</span>(mex, cnt[x]); <span class="comment">//可能出现了更小的答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    tot[cnt[x]]++;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">1</span> &amp;&amp; mex == cnt[x]) &#123; <span class="comment">//当前答案已经出现，向上寻找符合要求的 mex</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mex; i &lt;= siz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tot[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                mex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Query</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r, t, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Change</span> &#123;</span><br><span class="line">    <span class="type">int</span> pos, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span> * <span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">Query q[MAXN];</span><br><span class="line">Change c[MAXN];</span><br><span class="line"><span class="type">int</span> v[MAXN], cnt[MAXN], tot[MAXN], ans[MAXN], a[MAXN];</span><br><span class="line"><span class="type">int</span> cntQ, cntC;</span><br><span class="line"><span class="type">int</span> n, m, t, siz, mex = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Query&amp; a, Query&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.l / t != b.l / t) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.l &lt; b.l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a.r / t != b.r / t) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.t &lt; b.t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    tot[cnt[x]]--;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">0</span>) &#123;</span><br><span class="line">        mex = <span class="built_in">min</span>(mex, cnt[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[x]++;</span><br><span class="line">    tot[cnt[x]]++;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">1</span> &amp;&amp; mex == cnt[x]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mex; i &lt;= siz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tot[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                mex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    tot[cnt[x]]--;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">0</span>) &#123;</span><br><span class="line">        mex = <span class="built_in">min</span>(mex, cnt[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[x]--;</span><br><span class="line">    tot[cnt[x]]++;</span><br><span class="line">    <span class="keyword">if</span>(tot[cnt[x]] == <span class="number">1</span> &amp;&amp; mex == cnt[x]) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = mex; i &lt;= siz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tot[i + <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                mex = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q[i].l &lt;= c[t].pos &amp;&amp; c[t].pos &lt;= q[i].r) &#123;</span><br><span class="line">        <span class="built_in">del</span>(a[c[t].pos]);</span><br><span class="line">        <span class="built_in">add</span>(c[t].v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(a[c[t].pos], c[t].v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    t = <span class="built_in">pow</span>(n, <span class="number">2.0</span> / <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        v[++siz] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span>(op == <span class="number">1</span>) &#123;</span><br><span class="line">            cntQ++;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[cntQ].l, &amp;q[cntQ].r);</span><br><span class="line">            q[cntQ].t = cntC;</span><br><span class="line">            q[cntQ].id = cntQ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cntC++;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;c[cntC].pos, &amp;c[cntC].v);</span><br><span class="line">            v[++siz] = c[cntC].v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v + <span class="number">1</span>, v + siz + <span class="number">1</span>);</span><br><span class="line">    siz = <span class="built_in">unique</span>(v + <span class="number">1</span>, v + siz + <span class="number">1</span>) - (v + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = <span class="built_in">lower_bound</span>(v + <span class="number">1</span>, v + siz + <span class="number">1</span>, a[i]) - v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntC; i++) &#123;</span><br><span class="line">        c[i].v = <span class="built_in">lower_bound</span>(v + <span class="number">1</span>, v + siz + <span class="number">1</span>, c[i].v) - v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(q + <span class="number">1</span>, q + cntQ + <span class="number">1</span>, cmp);</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntQ; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &gt; q[i].l) <span class="built_in">add</span>(a[--l]);</span><br><span class="line">        <span class="keyword">while</span>(r &lt; q[i].r) <span class="built_in">add</span>(a[++r]);</span><br><span class="line">        <span class="keyword">while</span>(l &lt; q[i].l) <span class="built_in">del</span>(a[l++]);</span><br><span class="line">        <span class="keyword">while</span>(r &gt; q[i].r) <span class="built_in">del</span>(a[r--]);</span><br><span class="line">        <span class="keyword">while</span>(t &lt; q[i].t) <span class="built_in">modify</span>(i, ++t);</span><br><span class="line">        <span class="keyword">while</span>(t &gt; q[i].t) <span class="built_in">modify</span>(i, t--);</span><br><span class="line">        ans[q[i].id] = mex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cntQ; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
            <tag> 题解 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Codeforces Round 756 (Div. 3) 解题报告</title>
      <link href="/archives/1747842812/"/>
      <url>/archives/1747842812/</url>
      
        <content type="html"><![CDATA[<h1 id="a---make-even">A - Make Even</h1><h2 id="题意">题意</h2><p>输入一个数 <span class="math inline">\(n\)</span>，每次操作可以翻转 <span class="math inline">\(n\)</span> 的前 <span class="math inline">\(l\)</span> 位，问最少要进行多少次操作才能使 <span class="math inline">\(n\)</span> 变成偶数。</p><h2 id="思路">思路</h2><p>分情况讨论：</p><ol type="1"><li>如果这个数是偶数，答案显然为 0。</li><li>如果这个数是奇数，第一位为偶数，只需翻转整个数即可，答案为 1。</li><li>如果这个数是奇数，其中第 <span class="math inline">\(l\)</span> 位是偶数，那么先翻转 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(l\)</span> 位将它翻转到第一位，再翻转整个数即可。</li><li>否则，即如果这个数所有数位上都是奇数，那么不管进行多少次操作都无法变成偶数，输出 -1。</li></ol><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, a[<span class="number">15</span>], l = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="type">int</span> t = n;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(t != <span class="number">0</span>) &#123;</span><br><span class="line">            a[++l] = t % <span class="number">10</span>;</span><br><span class="line">            t /= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[l] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[l] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="b---team-composition-programmers-and-mathematicians">B - Team Composition: Programmers and Mathematicians</h1><h2 id="题意-1">题意</h2><p><span class="math inline">\(a\)</span> 个程序员和 <span class="math inline">\(b\)</span> 个数学家组队，每队 4 人。每支队伍至少要有一名程序员和一名数学家。求最多能组多少支队伍。</p><h2 id="思路-1">思路</h2><p>容易想到答案为 <span class="math inline">\(\lfloor \frac{a + b}{4} \rfloor\)</span>，但如果 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 中较小的数小于较大的数的三分之一，就无法得到这个答案。此时答案应该是 <span class="math inline">\(min\{a, b\}\)</span>，所以需要先特判一下。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; b) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((<span class="type">long</span> <span class="type">long</span>)a * <span class="number">3</span> &lt;= b) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, (a + b) / <span class="number">4</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="c---polycarp-recovers-the-permutation">C - Polycarp Recovers the Permutation</h1><h2 id="题意-2">题意</h2><p>有一个元素个数为 <span class="math inline">\(n\)</span> 的数组 <span class="math inline">\(p\)</span>，我们每次执行以下操作：</p><p>取 <span class="math inline">\(p\)</span> 最左边和最右边的数<strong>中较小的一个</strong>，如果选的是最左边，就加入新数组 <span class="math inline">\(a\)</span> 的左边，否则加入 <span class="math inline">\(a\)</span> 的右边。</p><p>现在给出 <span class="math inline">\(a\)</span>，求 <span class="math inline">\(p\)</span>。如果无解，输出 <code>-1</code>；如果多组解，输出任意一组即可。</p><p>（<a href="https://www.luogu.com.cn/discuss/385807">关于原翻译的错误。</a>）</p><h2 id="思路-2">思路</h2><p><del>说实话第一眼看到这道题时首先想到了今年 CSP-S T3。</del></p><p>这道题其实是一个模拟，我们只需要按照题意从最终结果反推初始状态就行。</p><p>题目中每次取左右较小值，我们反过来，取 <span class="math inline">\(a\)</span> 最左边和最右边的数中较<strong>大</strong>的一个，如果选的是最左边，就加入原数组 <span class="math inline">\(p\)</span> 的左边，否则加入 <span class="math inline">\(p\)</span> 的右边。</p><p>判断无解也比较简单：如果有解，<span class="math inline">\(n\)</span> 要么在 <span class="math inline">\(a\)</span> 的最左边，要么在最右边。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN], ans[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">1</span>] != n &amp;&amp; a[n] != n) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = <span class="number">1</span>, t = n;</span><br><span class="line">        <span class="keyword">while</span>(s &lt;= t) &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[s] &gt; a[t]) &#123;</span><br><span class="line">                q.<span class="built_in">push_front</span>(a[s++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.<span class="built_in">push_back</span>(a[t--]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="d---weights-assignment-for-tree-edges">D - Weights Assignment For Tree Edges</h1><h2 id="题意-3">题意</h2><p>输入一棵 <span class="math inline">\(n\)</span> 个节点的有根树和一个排列 <span class="math inline">\(p\)</span>，你需要给树上的每条边赋予一个权值，使得每个 <span class="math inline">\(p_{i - 1}\)</span> 到根结点的距离小于 <span class="math inline">\(p_i\)</span> 到根结点的距离。</p><h2 id="思路-3">思路</h2><p>因为题目要求每个 <span class="math inline">\(p_{i - 1}\)</span> 到根结点的距离小于 <span class="math inline">\(p_i\)</span> 到根结点的距离，不妨令 <span class="math inline">\(p_i\)</span> 到根结点的距离为 <span class="math inline">\(i - 1\)</span>，设为 <span class="math inline">\(dis_{p_i}\)</span>，那么 <span class="math inline">\(w_i\)</span> 就等于 <span class="math inline">\(dis_{p_i} - dis_{p_{fa_i}}\)</span>。</p><p>然后就需要判断无解。如果我们需要计算 <span class="math inline">\(p_i\)</span> 的答案时，<span class="math inline">\(p_i\)</span> 的父节点的答案还没被算出来，则可以直接判断为无解。另外，如果第一个 <span class="math inline">\(p_1\)</span> 不是根结点，显然无解，因为距离根结点最近的节点显然就是根结点本身，不可能是其他节点。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> fa[MAXN], pos[MAXN], ans[MAXN], dis[MAXN];</span><br><span class="line"><span class="type">int</span> n, rt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;fa[i]);</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fa[i] == i) &#123;</span><br><span class="line">                rt = i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            G[fa[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pos[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="built_in">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">        ans[rt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[fa[pos[i]]] == <span class="number">-1</span>) &#123;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos[i] == rt) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[pos[i]] = dis[pos[i - <span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line">            ans[pos[i]] = dis[pos[i]] - dis[fa[pos[i]]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag || pos[<span class="number">1</span>] != rt) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ans[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="e1---escape-the-maze-easy-version">E1 - Escape The Maze (easy version)</h1><h2 id="题意-4">题意</h2><p>Vlad 和他的朋友们玩游戏。游戏场地是一棵 <span class="math inline">\(n\)</span> 个节点的有根树。Vlad 开始在 1 号节点，他的朋友们在另外 <span class="math inline">\(k\)</span> 个节点。Vlad 每移动一次， Vlad 的朋友们可以任意沿着边移动一次也可以不移动。Vlad 如果能走到一个叶子结点，并且途中没有碰到任何一个朋友就获胜了。问 Vlad 是否有办法做到必胜。</p><h2 id="思路-4">思路</h2><p>跑两遍 BFS，一边计算 Vlad 到每个节点的最短距离，一遍计算 Vlad 的朋友们到每个节点的最短距离。最后，如果存在一个叶子结点，Vlad 到它的距离比 Vlad 的朋友们到它的距离更短，Vlad 只需要移动到这个叶子结点就能获胜。</p><p>（一下为了方便说明，记 Vlad 到每个节点的距离为 <span class="math inline">\(tmp_i\)</span>，Vlad 的朋友们到每个节点的最短距离为 <span class="math inline">\(dis_i\)</span>。满足条件的叶节点 <span class="math inline">\(i\)</span> 即 <span class="math inline">\(tmp_i &lt; dis_i\)</span>。）</p><p>这个方法的正确性很容易证明：从根结点到每个叶子节点只有一条路径，如果这条路径上有任意一个节点<span class="math inline">\(j\)</span> 出现了 <span class="math inline">\(tmp_j \ge dis_j\)</span> 的情况，这个叶子结点 <span class="math inline">\(i\)</span> 肯定也有 <span class="math inline">\(tmp_i \ge dis_i\)</span>。换句话说，只要叶子结点满足 <span class="math inline">\(tmp_i &lt; dis_i\)</span>，整条路径上所有节点也都满足 <span class="math inline">\(tmp_i &lt; dis_i\)</span>，即 Vlad 离该节点的距离比所有朋友都更近。</p><p>所以对于满足 <span class="math inline">\(tmp_i &lt; dis_i\)</span> 的叶子节点，Vlad 只要一开始就选择走这条路径，就可以在任何一个朋友到达该路径上的任何一个节点前到达该节点，并最终获胜。</p><h2 id="代码-4">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> pos[MAXN], dis[MAXN], tmp[MAXN];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> v = G[u][i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        tmp[i] = dis[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dis[i] = <span class="number">0</span>;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(pos[i]);</span><br><span class="line">        vis[pos[i]] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> v = G[u][i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(vis[v]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dis[v] = dis[u] + <span class="number">1</span>;</span><br><span class="line">            vis[v] = <span class="literal">true</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            G[i].<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;pos[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">            G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">bfs1</span>();</span><br><span class="line">        <span class="built_in">bfs2</span>();</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(G[i].<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; tmp[i] &lt; dis[i]) &#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="f---atm-and-students">F - ATM and Students</h1><h2 id="题意-5">题意</h2><p><a href="https://www.luogu.com.cn/paste/wrrwu53t">题面翻译</a></p><p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span class="math inline">\(a\)</span> 和一个整数 <span class="math inline">\(s\)</span>，求一段最长的区间 <span class="math inline">\([l,r]\)</span> 使得 <span class="math inline">\(\forall i \in [l,r] , s + \sum\limits_{j = l}^i a_j \geq 0\)</span>。</p><h2 id="思路-5">思路</h2><p>对于这种“求最长的符合要求的区间的问题”，由于它满足单调性，所以我们可以用“枚举左端点，二分右端点”的常用套路求解。</p><p>我们先求出 <span class="math inline">\(a\)</span> 数组的前缀和 <span class="math inline">\(sum\)</span>，那么问题就变成了求一段最长的区间 <span class="math inline">\([l,r]\)</span> 使得 <span class="math inline">\(s + \min_{j = l}^r sum_j - sum_{i - 1} \geq 0\)</span>。中间求区间最小值的部分可以用 ST 表预处理出来，然后 <span class="math inline">\(O(1)\)</span> 查询；而这个式子本身则可以用二分答案求解。</p><p>总复杂度 <span class="math inline">\(O(n \ log\ n)\)</span>。</p><h2 id="代码-5">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXB = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> st[MAXN][MAXB], lg[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> n, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">st[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="keyword">if</span>(i &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">lg[i] = lg[i / <span class="number">2</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; MAXB; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; j) - <span class="number">1</span> &lt;= n; i++) &#123;</span><br><span class="line">st[i][j] = <span class="built_in">min</span>(st[i][j - <span class="number">1</span>], st[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> t = lg[r - l + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(st[l][t], st[r - (<span class="number">1</span> &lt;&lt; t) + <span class="number">1</span>][t]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;s);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">            a[i] += a[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="type">int</span> ansl, ansr, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> l = i, r = n, res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(s + <span class="built_in">ask</span>(i, mid) &gt;= a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                    res = mid;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(res - i + <span class="number">1</span> &gt; ans) &#123;</span><br><span class="line">                ans = res - i + <span class="number">1</span>;</span><br><span class="line">                ansl = i;</span><br><span class="line">                ansr = res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, ansl, ansr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> 二分 </tag>
            
            <tag> ST表 </tag>
            
            <tag> CodeForces </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Educational Codeforces Round 116 (Rated for Div. 2) 解题报告</title>
      <link href="/archives/485584732/"/>
      <url>/archives/485584732/</url>
      
        <content type="html"><![CDATA[<h1 id="a---ab-balance">A - AB Balance</h1><h2 id="题意">题意</h2><p>给出一个只由字符 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 组成的字符串 <span class="math inline">\(s\)</span>，求最少的修改使 <span class="math inline">\(s\)</span> 中 <span class="math inline">\(ab\)</span> 的出现次数和 <span class="math inline">\(ba\)</span> 的出现次数相等。</p><h2 id="思路">思路</h2><p><span class="math inline">\(s\)</span> 中 <span class="math inline">\(ab\)</span> 和 <span class="math inline">\(ba\)</span> 都只会在连续段之间出现，并且交替出现，所以出现次数最多相差<span class="math inline">\(1\)</span>。如果一共有奇数段，两者的出现次数肯定相等；如果有偶数段，只需要修改第一个字符就会变成奇数段。</p><p>所以只要出现次数不相等就修改第一个字符即可。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">        n = <span class="built_in">strlen</span>(s + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> cntAB = <span class="number">0</span>, cntBA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27;b&#x27;</span>) &#123;</span><br><span class="line">                cntAB++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;b&#x27;</span> &amp;&amp; s[i + <span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                cntBA++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cntAB != cntBA) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">1</span>] == <span class="string">&#x27;a&#x27;</span>) &#123;</span><br><span class="line">                s[<span class="number">1</span>] = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s[<span class="number">1</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="b---update-files">B - Update Files</h1><h2 id="题意-1">题意</h2><p>有 <span class="math inline">\(n\)</span> 台计算机，<span class="math inline">\(k\)</span> 条数据线，每条数据线同一时刻只能连接两台计算机，问最少要几轮才能将第 <span class="math inline">\(1\)</span> 台计算机上的文件传输到全部 <span class="math inline">\(n\)</span> 台计算机上。</p><h2 id="思路-1">思路</h2><p>当目前有文件的计算机总数少于 <span class="math inline">\(k\)</span> 时，传输文件的计算机总数显然会每次翻倍，即 <span class="math inline">\(1\)</span>, <span class="math inline">\(2\)</span>, <span class="math inline">\(4\)</span>, <span class="math inline">\(8\)</span>, <span class="math inline">\(16\)</span>…… 但如果当前有文件的计算机总数超过 <span class="math inline">\(k\)</span>，就只能每次增加 <span class="math inline">\(k\)</span> 个，最后结果为 <span class="math inline">\(\lceil \frac{n - 2^m}{k} \rceil + m\)</span> (<span class="math inline">\(2^m \leq n\)</span> 且 <span class="math inline">\(2^m &gt; k\)</span>，<span class="math inline">\(2^{m - 1} \leq k\)</span>)。</p><h2 id="代码-1">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> b = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(b &lt;= k &amp;&amp; b * <span class="number">2</span> &lt;= n) &#123;</span><br><span class="line">            b *= <span class="number">2</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt += (n - b) / k;</span><br><span class="line">        <span class="keyword">if</span>((n - b) % k != <span class="number">0</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="c---banknotes">C - Banknotes</h1><h2 id="题意-2">题意</h2><p>给出 <span class="math inline">\(n\)</span> 种面值为 <span class="math inline">\(10^{a_i}\)</span> 的纸币，求最少的金额使其无法用 <span class="math inline">\(k\)</span> 张纸币表示出来。</p><h2 id="思路-2">思路</h2><p>可以转换为找到最小的必须用 <span class="math inline">\(k + 1\)</span> 种纸币表示出的金额，定义 <span class="math inline">\(s = k + 1\)</span>。对于第 <span class="math inline">\(i\)</span> 种纸币，令 <span class="math inline">\(s\)</span> 减去 <span class="math inline">\(10^{a_{i + 1} - a_i} - 1\)</span>，如果不能减去或者已经到了面值最大的纸币，就直接输出当前的数，并在后面用 <span class="math inline">\(a_i\)</span> 个 <span class="math inline">\(9\)</span> 填充。</p><h2 id="代码-2">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>, <span class="number">10000000</span>, <span class="number">100000000</span>, <span class="number">1000000000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN], ans[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            vis[a[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> s = k + <span class="number">1</span>, p = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">                ans[i] = s;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s &gt; base[a[i + <span class="number">1</span>] - a[i]] - <span class="number">1</span>) &#123;</span><br><span class="line">                ans[i] = base[a[i + <span class="number">1</span>] - a[i]] - <span class="number">1</span>;</span><br><span class="line">                s -= base[a[i + <span class="number">1</span>] - a[i]] - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans[i] = s;</span><br><span class="line">                p = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans[p]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a[p]; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="e---arena">E - Arena</h1><h2 id="题意-3">题意</h2><p>竞技场里有 <span class="math inline">\(n\)</span> 个英雄，每个英雄的生命值为 <span class="math inline">\(a_i\)</span>（<span class="math inline">\(1 \leq a_i \leq x\)</span>）。每一次战斗中，每个英雄都会对其他所有英雄造成 <span class="math inline">\(1\)</span> 点伤害，生命值降到 <span class="math inline">\(0\)</span> 后英雄就会退场，如果若干次战斗后只剩下一个英雄，这个英雄就是赢家。</p><p>求有多少种生命值方案使得最后没有赢家，答案模 <span class="math inline">\(998244353\)</span>。两种方案不同当且仅当至少有一个英雄的生命值不同。</p><h2 id="思路-3">思路</h2><p>直接思考没有赢家的方案数似乎没什么思路，我们不妨考虑计算有赢家的方案数。</p><p>定义 <span class="math inline">\(f_{i, j}\)</span> 为有 <span class="math inline">\(i\)</span> 个英雄，生命值最大为 <span class="math inline">\(j\)</span> 的方案数，就可以得到状态转移方程：</p><p><span class="math display">\[f_{i, j} = \sum_{k = 0}^{i - 1}f_{i - k, j - i + 1}(i - 1)^k C_i^k\]</span></p><p>其中 <span class="math inline">\(k\)</span> 为这一次战斗退场的英雄数。</p><p>要注意的一点是，这道题的时限会导致一般的快速幂不能过。我采取的方式是对幂进行预处理，具体内容参见代码。</p><h2 id="代码-3">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> C[MAXN][MAXN], f[MAXN][MAXN], qpow[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">C[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">C[i][j] = (C[i - <span class="number">1</span>][j - <span class="number">1</span>] + C[i - <span class="number">1</span>][j]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">qpow[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; MAXN; j++) &#123;</span><br><span class="line">qpow[i][j] = qpow[i][j - <span class="number">1</span>] * i % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">f[<span class="number">1</span>][j] = j;</span><br><span class="line">f[<span class="number">2</span>][j] = j * (j - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= m; j++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">f[i][j] = (f[i][j] + (f[i - k][j - i + <span class="number">1</span>] * qpow[i - <span class="number">1</span>][k]) % MOD * C[i][k] % MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ((qpow[m][n] - f[n][m]) % MOD + MOD) % MOD);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（剩下的题等会就补）</p><p>（咕咕咕）</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> 贪心 </tag>
            
            <tag> CodeForces </tag>
            
            <tag> 题解 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> DP </tag>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化 Trie 学习笔记</title>
      <link href="/archives/2541031305/"/>
      <url>/archives/2541031305/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><blockquote><p>看到异或便想到 Trie，便想到可持久化 Trie，OIer 的想象力唯在这一层面能如此跃进。——智子</p></blockquote><p>（这篇文章的诞生原因主要其实是 <span class="citation" data-cites="apple365">@apple365</span> 上星期说的某句话。）</p><h2 id="trie">Trie</h2><p>众所周知，Trie 树是一种用来处理字符串问题的数据结构。</p><h3 id="p2580-于是他错误的点名开始了">P2580 于是他错误的点名开始了</h3><p><a href="https://www.luogu.com.cn/problem/P2580">洛谷 P2580 于是他错误的点名开始了</a></p><p>输入若干个字符串，查询每个字符串是否在给定的字符串中，或者有没有重复查询。</p><p>暴力显然会超时，哈希能解决但是非常丑陋，而 Trie 树可以优美地解决这个问题。Trie 树和核心思想是尽可能重复利用相同的前缀，将所有的字符串从前往后作为一条从根节点到叶子的路径插入到树中。</p><p><img src="https://oi-wiki.org//string/images/trie1.png" /></p><p>（图片转载自 OI-Wiki，遵循 CC BY-SA 4.0 协议。）</p><p>例如这道题，直接建立一棵 Trie 树并在末尾标记是否有字符串结束和是否已经被查询过即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ch[MAXN][<span class="number">26</span>], end[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> * s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>, l = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line"><span class="type">int</span> v = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ch[p][v] == <span class="number">0</span>) &#123;</span><br><span class="line">ch[p][v] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line">p = ch[p][v];</span><br><span class="line">&#125;</span><br><span class="line">end[p] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">char</span> * s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>, l = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line"><span class="type">int</span> v = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ch[p][v] == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">p = ch[p][v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(end[p] == <span class="number">1</span>) &#123;</span><br><span class="line">end[p] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"><span class="built_in">insert</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">find</span>(s);</span><br><span class="line"><span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;WRONG\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(res == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;REPEAT\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="trie-1">01 Trie</h2><p>众所周知，Trie 树是一种用来处理字符串问题的数据结构。</p><p>但在实际的比赛和练习中，Trie 树也常常被用来处理一类“最大异或”的问题，即要在一定的限定条件下求出某种最大的异或和。这种形式的 Trie 树通常被称为“01 Trie”。</p><h3 id="p4551-最长异或路径">P4551 最长异或路径</h3><p>下面是一道简单的例题：</p><p><a href="https://www.luogu.com.cn/problem/P4551">洛谷 P4551 最长异或路径</a></p><blockquote><p>给定一棵 <span class="math inline">\(n\)</span> 个点的带权树，结点下标从 <span class="math inline">\(1\)</span> 开始到 <span class="math inline">\(n\)</span>。寻找树中找两个结点，求最长的异或路径。</p></blockquote><blockquote><p>异或路径指的是指两个结点之间唯一路径上的所有边权的异或。</p></blockquote><p>首先定义 <span class="math inline">\(sum_u\)</span> 为从根节点到节点 <span class="math inline">\(u\)</span> 的路径所有边的异或和，<span class="math inline">\(sum\)</span> 可以用一遍 DFS 预处理出来。设 <span class="math inline">\(dis(u, v)\)</span> 为从 <span class="math inline">\(u\)</span> 到 <span class="math inline">\(v\)</span> 的路径上所有边的异或和，则有：</p><p><span class="math display">\[dis(u, v) = sum_u \oplus sum_{LCA(u, v)} \oplus sum_v \oplus sum_{LCA(u, v)} =sum_u \oplus sum_v \]</span></p><p>所以这道题相当于求 <span class="math inline">\(sum_1\)</span> ~ <span class="math inline">\(sum_n\)</span> 的 <span class="math inline">\(n\)</span> 个数中的两个数的异或和的最大值。</p><p>将每一个 <span class="math inline">\(sum_i\)</span> 看作一个长度为 <span class="math inline">\(32\)</span> 的 <span class="math inline">\(01\)</span> 字符串，并将其全部插入一颗 Trie 树。（遍历时从前往后，因为求异或和时高位显然比低位影响更大。）然后对于每一个 <span class="math inline">\(sum_u\)</span>，进行一个贪心的策略，每次从根节点出发尝试访问与当前值的这一位相反的子节点。例如如果当前值为 <span class="math inline">\((010110)\)</span>，则每次尝试访问的子节点依次为 <span class="math inline">\((101001)\)</span>，如果该子节点不存在则只好访问当前值的这一位的字节点。</p><p>示例代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Line</span> &#123;</span><br><span class="line"><span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;Line&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> t[MAXN][<span class="number">2</span>], sum[MAXN];</span><br><span class="line"><span class="type">int</span> n, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> v = G[u][i].v, w = G[u][i].w;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(v == par) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum[v] = sum[u] ^ w;</span><br><span class="line"><span class="built_in">dfs</span>(v, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>); i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">bool</span> c = x &amp; i;</span><br><span class="line"><span class="keyword">if</span>(t[p][c] == <span class="number">0</span>) &#123;</span><br><span class="line">t[p][c] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line">p = t[p][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>); i != <span class="number">0</span>; i &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">bool</span> c = x &amp; i;</span><br><span class="line"><span class="keyword">if</span>(t[p][!c]) &#123;</span><br><span class="line">res += i;</span><br><span class="line">p = t[p][!c];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">p = t[p][c];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">G[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="built_in">insert</span>(sum[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, <span class="built_in">query</span>(sum[i]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可持久化-trie">可持久化 Trie</h2><p>可持久化数据结构的特点是能够维护数据结构的历史版本，但在 OI 中，大部分情况下“可持久化”的重点是能被用来处理序列乃至值域（如著名的主席树）上的问题，下面这道题就是对可持久化数据结构在 OI 中用途的一个经典阐述。</p><h3 id="p4735-最大异或和">P4735 最大异或和</h3><p><a href="https://www.luogu.com.cn/problem/P4735">洛谷 P4735 最大异或和</a></p><blockquote><p>给定一个非负整数序列 <span class="math inline">\(\{a\}\)</span>，初始长度为 <span class="math inline">\(n\)</span>。</p></blockquote><blockquote><p>有 <span class="math inline">\(m\)</span> 个操作，有以下两种操作类型：</p></blockquote><blockquote><ol type="1"><li><code>A x</code>：添加操作，表示在序列末尾添加一个数 <span class="math inline">\(x\)</span>，序列的长度 <span class="math inline">\(n+1\)</span>。</li></ol></blockquote><blockquote><ol start="2" type="1"><li><code>Q l r x</code>：询问操作，你需要找到一个位置 <span class="math inline">\(p\)</span>，满足 <span class="math inline">\(l \le p \le r\)</span>，使得： <span class="math inline">\(a[p] \oplus a[p+1] \oplus ... \oplus a[N] \oplus x\)</span> 最大，输出最大是多少。</li></ol></blockquote><p>类似的，设 <span class="math inline">\(sum_i\)</span> 为前 <span class="math inline">\(i\)</span> 个数的前缀异或和，那么题中要求的 <span class="math inline">\(a[p] \oplus a[p+1] \oplus ... \oplus a[N] \oplus x\)</span> 就等于 <span class="math inline">\(sum_{p - 1} \oplus sum_n \oplus x\)</span>。</p><p>所以题意即要求 <span class="math inline">\(sum_p \oplus sum_n \oplus x\)</span> 的最大值，其中 <span class="math inline">\(l - 1 \le p \le r - 1\)</span></p><p>假如没有 <span class="math inline">\(l - 1 \le p \le r - 1\)</span> 的要求，这道题的解法就和上一道题一样，直接在 01 Trie 中贪心地查找 <span class="math inline">\(sum_n \oplus x\)</span> 的每一位的相反子节点即可。</p><p>加上 <span class="math inline">\(p \le r - 1\)</span> 的要求后，我们发现这相当于要求在第 <span class="math inline">\(r - 1\)</span> 个数刚被插入后的 Trie 树上查询答案，即需要访问这颗 Trie 树的历史版本，使用可持久化 Trie 即可。 <strong>这就是可持久化思想在 OI 中的主要意义：将序列和值域上的问题转为历史版本之间的关系的问题，减少问题的维度。</strong></p><p>至于 <span class="math inline">\(l - 1 \le p \le r - 1\)</span> 的要求则需要一点小技巧。记 <span class="math inline">\(end_u\)</span> 为节点 <span class="math inline">\(u\)</span> 是第几个字符串的末尾节点，<span class="math inline">\(latest_u\)</span> 为以节点 <span class="math inline">\(u\)</span> 为根的子树内的所有节点的 <span class="math inline">\(end\)</span> 的最大值。当我们在可持久化 Trie 的第 <span class="math inline">\(r - 1\)</span> 个历史版本上查询时，只访问 <span class="math inline">\(latest\)</span> 大于等于 <span class="math inline">\(l - 1\)</span> 的节点，忽略其他的节点，这样就能保证最后找到的串所在的范围满足要求。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">600000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ch[MAXN * <span class="number">24</span>][<span class="number">2</span>], latest[MAXN * <span class="number">24</span>];</span><br><span class="line"><span class="type">int</span> s[MAXN], rt[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> k, <span class="type">int</span> last, <span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">latest[now] = i;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = s[i] &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(last) &#123;</span><br><span class="line">ch[now][c ^ <span class="number">1</span>] = ch[last][c ^ <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">ch[now][c] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(i, k - <span class="number">1</span>, ch[last][c], ch[now][c]);</span><br><span class="line">latest[now] = <span class="built_in">max</span>(latest[ch[now][<span class="number">0</span>]], latest[ch[now][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> val, <span class="type">int</span> k, <span class="type">int</span> left)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(k &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> s[latest[now]] ^ val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = val &gt;&gt; k &amp; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(latest[ch[now][c ^ <span class="number">1</span>]] &gt;= left) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ask</span>(ch[now][c ^ <span class="number">1</span>], val, k - <span class="number">1</span>, left);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">ask</span>(ch[now][c], val, k - <span class="number">1</span>, left);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">latest[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">rt[<span class="number">0</span>] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(<span class="number">0</span>, <span class="number">23</span>, <span class="number">0</span>, rt[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">s[i] = s[i - <span class="number">1</span>] ^ x;</span><br><span class="line">rt[i] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(i, <span class="number">23</span>, rt[i - <span class="number">1</span>], rt[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line"><span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">&#x27;A&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">rt[++n] = ++tot;</span><br><span class="line">s[n] = s[n - <span class="number">1</span>] ^ x;</span><br><span class="line"><span class="built_in">insert</span>(n, <span class="number">23</span>, rt[n - <span class="number">1</span>], rt[n]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="type">int</span> l, r, x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">ask</span>(rt[r - <span class="number">1</span>], x ^ s[n], <span class="number">23</span>, l - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> Trie </tag>
            
            <tag> 可持久化 </tag>
            
            <tag> 异或 </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1594C Make Them Equal</title>
      <link href="/archives/1281241727/"/>
      <url>/archives/1281241727/</url>
      
        <content type="html"><![CDATA[<h2 id="题意">题意</h2><p>输入一个整数 <span class="math inline">\(n\)</span> ，一个字符 <span class="math inline">\(c\)</span> 和一个长度为 <span class="math inline">\(n\)</span> 的字符串 <span class="math inline">\(s\)</span>。</p><p>选择若干个数 <span class="math inline">\(x\)</span>，对于 <span class="math inline">\(s\)</span> 的第 <span class="math inline">\(i\)</span> 个字符 <span class="math inline">\(s_i\)</span>，如果 <span class="math inline">\(i\)</span> 不能被 <span class="math inline">\(x\)</span> 整除，<span class="math inline">\(s_i\)</span> 就会被替换为 <span class="math inline">\(c\)</span>。</p><p>求最少的操作次数和任意一种方案。</p><h2 id="思路">思路</h2><p>本题的关键是，不论 <span class="math inline">\(s\)</span> 的内容如何，答案最多只为 <span class="math inline">\(2\)</span>。因为选取了 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(n - 1\)</span> 后肯定会将 <span class="math inline">\(s\)</span> 的所有字符全部变成 <span class="math inline">\(c\)</span>，所以只需要考虑是否只需要一步就能解决问题即可，如果不能就直接输出 <code>2</code> 和 <code>n n - 1</code>。</p><p>对于只需要一步的情况，直接枚举即可，复杂度 <span class="math inline">\(O(n \ln n)\)</span>。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">300000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> c, s[MAXN];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; c &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != c) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> p = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt;= n; j += i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j] != c) &#123;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                p = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造 </tag>
            
            <tag> CodeForces </tag>
            
            <tag> 题解 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 CF1594D The Number of Imposters</title>
      <link href="/archives/413439375/"/>
      <url>/archives/413439375/</url>
      
        <content type="html"><![CDATA[<h2 id="题意">题意</h2><p>有 <span class="math inline">\(n\)</span> 个玩家和 <span class="math inline">\(m\)</span> 句话，每个玩家可能是船员或内鬼，每句话的形式为“玩家 <span class="math inline">\(i\)</span> 说玩家 <span class="math inline">\(j\)</span> 是船员/内鬼”，求最多可能有多少个内鬼。（如果自相矛盾，输出 <span class="math inline">\(-1\)</span>。）</p><p>PS：题目背景出自国外的著名游戏 <em>Among Us</em> ，中文名为《我们之中》，也被叫做《内鬼杀》或《太空狼人杀》。游戏背景设置于太空，玩家将扮演船员（英语：Crewmate）或内鬼（英语：Impostor）之一。船员的目标是找出伪装者并完成任务，而伪装者的目标是杀死所有船员而不被发现。</p><h2 id="思路">思路</h2><p>这种题目很容易让人联想到并查集。就像 <a href="https://www.luogu.com.cn/problem/P2024">NOI2001 食物链</a> 一样，这道题可以用“扩展域”并查集来解决。</p><p>用 <span class="math inline">\(x\)</span> 表示玩家 <span class="math inline">\(x\)</span> 是船员，<span class="math inline">\(x + n\)</span> 表示船员 <span class="math inline">\(x\)</span> 是内鬼。</p><p>对于一句话，如果是“玩家 <span class="math inline">\(x\)</span> 说玩家 <span class="math inline">\(y\)</span> 是船员”，就意味着：</p><ul><li><p>如果这句话为真，那么玩家 <span class="math inline">\(x\)</span> 和玩家 <span class="math inline">\(y\)</span> 都是船员。</p></li><li><p>如果这句话为假，那么玩家 <span class="math inline">\(x\)</span> 和玩家 <span class="math inline">\(y\)</span> 都是内鬼。</p></li></ul><p>同理，如果是“玩家 <span class="math inline">\(x\)</span> 说玩家 <span class="math inline">\(y\)</span> 是内鬼”，就意味着：</p><ul><li><p>如果这句话为真，那么玩家 <span class="math inline">\(x\)</span> 是船员，玩家 <span class="math inline">\(y\)</span> 是内鬼。</p></li><li><p>如果这句话为假，那么玩家 <span class="math inline">\(x\)</span> 是内鬼，玩家 <span class="math inline">\(y\)</span> 是船员。</p></li></ul><p>按照这个规则合并并查集，然后检查如果存在 <span class="math inline">\(find(x) = find(x + n)\)</span>，说明无解，输出 <code>-1</code>。</p><p>否则，对于每一个点 <span class="math inline">\(i\)</span>，考虑分别包含 <span class="math inline">\(i\)</span> 和 <span class="math inline">\(i + n\)</span> 的两个集合，哪个集合包含的内鬼多就选取哪个集合，并累加答案。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[MAXN * <span class="number">2</span>], vis[MAXN * <span class="number">2</span>], cnt[MAXN * <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n, m, p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> k == f[k] ? k : f[k] = <span class="built_in">find</span>(f[k]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--) &#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            f[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y &gt;&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(s[<span class="number">0</span>] == <span class="string">&#x27;c&#x27;</span>) &#123;</span><br><span class="line">                f[<span class="built_in">find</span>(x)] = f[<span class="built_in">find</span>(y)];</span><br><span class="line">                f[<span class="built_in">find</span>(x + n)] = <span class="built_in">find</span>(y + n);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                f[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y + n);</span><br><span class="line">                f[<span class="built_in">find</span>(x + n)] = <span class="built_in">find</span>(y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(i) == <span class="built_in">find</span>(i + n)) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>; <span class="comment">// 无解</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; n) &#123;</span><br><span class="line">                cnt[<span class="built_in">find</span>(i)]++; <span class="comment">//统计每个集合的内鬼总数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[<span class="built_in">find</span>(i)] || vis[<span class="built_in">find</span>(i + n)]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//如果这个点已经访问过，就不再访问</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans += <span class="built_in">max</span>(cnt[<span class="built_in">find</span>(i)], cnt[<span class="built_in">find</span>(i + n)]); <span class="comment">//选取内鬼较多的集合，加上其内鬼总数</span></span><br><span class="line">            vis[<span class="built_in">find</span>(i)] = <span class="literal">true</span>;</span><br><span class="line">            vis[<span class="built_in">find</span>(i + n)] = <span class="literal">true</span>; <span class="comment">//标记访问</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CodeForces </tag>
            
            <tag> 题解 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>五分钟理解什么是 Monad</title>
      <link href="/archives/756150797/"/>
      <url>/archives/756150797/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>对于很多想要了解函数式编程（Functional Programming）或者是 Haskell 的 OIer 而言，Monad 是一个非常不友好的概念，但当你理解了它之后你就会不理解为什么你之前不理解它（</p><blockquote><p>一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，这有什么难以理解的？</p></blockquote><p>（上面这句话其实并不是 Monad 的严格定义，因为是“自函子范畴上的一个幺半群”的东西不一定是 Monad，比如 Applicative 也符合上述定义。）</p><p>由于 Monad 这一概念本身对新手并不友好，大众 Monad 的误解有一箩筐，包括但不限于：</p><ul><li>Monads are impure.</li><li>Monads are about effects.</li><li>Monads are about state.</li><li>Monads are about imperative sequencing.</li><li>Monads are about IO.</li><li>Monads are dependent on laziness.</li><li>Monads are a “back-door” in the language to perform side-effects.</li><li>Monads are an embedded imperative language inside Haskell.</li><li>Monads require knowing abstract mathematics.</li><li>Monads are unique to Haskell.</li></ul><p>虽然在实际的开发中，Monad 的应用确实很复杂，但如果只是要理解 Monad 的概念的话其实很简单。（？）</p><h2 id="解释">解释</h2><h3 id="functor">Functor</h3><p>要理解 Monad 是什么，首先要理解 Functor 是什么。</p><p>Functor 可以理解为一个装着函数或值的盒子（定义不切确，等会会提到）。</p><p>用 Maybe 类型来举例就是：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Just</span> a | <span class="type">Nothing</span></span></span><br></pre></td></tr></table></figure><p>这种数据类型无论在哪里都很常用，在 C++ 等语言里我们也经常处理除了 int，double 之外的各种复杂数据类型。但 Functor 并不是一个盒子那么简单，它还有一个重要定义是 <code>fmap</code>：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>具体来说，就是一个函数，输入一个 输入一个值输出一个值的函数 f(x) 和一个 Functor x，返回一个 Functor f(x)，简单来说就是对盒子里的值进行操作。</p><p>举个栗子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; fmap (*<span class="number">3</span>) <span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p><strong>总而言之，Functor 就是一个装着值的盒子，并且可以用 <code>fmap</code> 函数来用一个普通函数生成另一个 Functor。</strong></p><h3 id="applicative">Applicative</h3><p><strong>Applicative 是一种特殊的 Functor</strong>，它除了 <code>fmap</code> 外还实现了另一个函数 <code>&lt;*&gt;</code></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span>  </span><br><span class="line">    pure :: a -&gt; f a  </span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>（了解面对对象的同学可以理解为 Applicative 继承了 Functor）</p><p><code>&lt;*&gt;</code> 函数（熟悉 C++ 的同学可以理解为一个运算符）用来给给一个装在盒子里的值施加一个装在盒子里的函数，举个栗子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Just</span> (*<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>准确的说，<code>&lt;*&gt;</code> 函数接受一个<code>f (a -&gt; b)</code>，返回一个<code>f a -&gt; f b</code>。即输入一个含有函数的 Applicative 和一个含有值的 Applicative，输出一个含有结果的 Applicative。</p><p>《Haskell 趣学指南》中有一个典型的示例：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myAction</span> :: <span class="type">IO</span> <span class="type">String</span></span><br><span class="line"><span class="title">myAction</span> = (++) `fmap` getLine &lt;*&gt; getLine</span><br></pre></td></tr></table></figure><p>这段代码输入两行字符串并拼接，返回对应的 <code>IO Action</code>，它具体做了什么？首先，<code>geiLine</code>的返回值是一个 <code>IO Action</code>，它也属于一种 Applicative，所以也实现了<code>&lt;*&gt;</code> 函数。Applicative 作为 Functor 的子集当然也实现了 <code>fmap</code>，换句话说 <code>(++)</code>fmap<code>getLine</code>实际上是一个<code>IO ([Char] -&gt; [Char])</code>，即一个含有函数的 Applicative，所以还要使用<code>&lt;*&gt;</code> 函数将其应用到另一个<code>IO Action</code>即<code>getLine</code>，最后的结果也是一个 Applicative（<code>IO Action</code>）。</p><p>下面这个例子可能更好理解：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; (+) `fmap` <span class="type">Just</span> <span class="number">2</span> &lt;*&gt; <span class="type">Just</span> <span class="number">8</span></span><br><span class="line"><span class="type">Just</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>前面的 <code>fmap (+) Just 2</code>的值实际上等于<code>Just (+2)</code>，所以整个表达式就等于<code>Just (+2) &lt;*&gt; Just 8</code>，即<code>Just 10</code>。</p><p>Applicative的定义：一个实现了<code>&lt;*&gt;</code>函数的 Functor</p><p>总而言之，Applicative 就是一个装着值的盒子，并且可以用 <code>fmap</code> 函数来用一个普通函数生成另一个 Applicative，并且还可以用<code>&lt;*&gt;</code>函数来用一个装在盒子（Functor）里的函数生成另一个 Applicative。</p><h3 id="monad">Monad</h3><p>现在你已经了解了所有前置知识，可以了解 Monad 了。（大雾）</p><p><strong>Monad 是一种特殊的 Applicative</strong>，它除了 <code>&lt;*&gt;</code> 外还实现了另一个函数 <code>&gt;&gt;=</code></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Applicative</span> <span class="title">m</span>) =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">    return  :: a -&gt; m a</span><br></pre></td></tr></table></figure><p><code>&gt;&gt;=</code> 函数用把一个装在盒子里的值直接扔进一个“处理数据并自动打包盒子的函数”，举个栗子：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">threeTimes</span> x = <span class="type">Just</span> (x * <span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; threeTimes <span class="number">2</span></span><br><span class="line"><span class="type">Just</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>但是盒子里的值是无法被直接取出的，所以我们不能直接用这个函数处理装在盒子里的值，所以此时要用到 Monad：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Just</span> <span class="number">2</span> &gt;&gt;= threeTimes</span><br><span class="line"><span class="type">Just</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>总而言之，Monad 就是一个装着值的盒子，并且可以用 <code>fmap</code> 函数来用一个普通函数生成另一个 Monad，并且还可以用<code>&lt;*&gt;</code>函数来用一个装在盒子（Functor）里的函数生成另一个 Monad，并且还可以用<code>&gt;&gt;=</code>函数来用一个“处理数据并自动打包盒子的函数”生成另一个 Monad。</p><p>这只是一个通俗的解释，更形式化的，一个 Monad 必须符合以下三条规则才能被称为 Monad:</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(return x) &gt;&gt;= f == f x          <span class="comment">-- left unit law</span></span><br><span class="line"><span class="title">m</span> &gt;&gt;= return == m          <span class="comment">-- right unit law</span></span><br><span class="line">(m &gt;&gt;= f) &gt;&gt;= g == m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)   <span class="comment">-- associativity law</span></span><br></pre></td></tr></table></figure><p>Haskell 中的 <code>return</code> 是指把一个值打包进 Monad 里，和其他语言中的 <code>return</code> 没什么关系。</p><p>如果你要实现自己的 Monad，则必须符合上述三条规则。</p><p><strong>在数学中，符合上述三条定律的东西被称为幺半群。</strong>敏锐的读者可以立即察觉到，Monad 就是一个幺半群。</p><h4 id="left-unit-law">Left Unit Law</h4><p>这条规则指的是，将一个值打包进 Monad 然后再<code>&gt;&gt;=</code>到一个函数，等同于直接将值应用于这个函数。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; (return <span class="number">3</span>) &gt;&gt;= (\x -&gt; <span class="type">Just</span> (x * <span class="number">2</span>))</span><br><span class="line"><span class="type">Just</span> <span class="number">6</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (\x -&gt; <span class="type">Just</span> (x * <span class="number">2</span>)) <span class="number">3</span></span><br><span class="line"><span class="type">Just</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>考虑到<code>&gt;&gt;=</code>的定义，这是比较显然的。</p><h4 id="right-unit-law">Right Unit Law</h4><p>这条规则指的是，将一个 Monad <code>&gt;&gt;=</code>到<code>return</code>函数，得到的是原来的 Monad。用形式化的语言来说就是“Monad 是一个自相似的几何结构”。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Just</span> <span class="number">3</span> &gt;&gt;= return</span><br><span class="line"><span class="type">Just</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>我们可以参照 <code>&gt;&gt;=</code>的实现来理解：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    return x = <span class="type">Just</span> x</span><br><span class="line">    (&gt;&gt;=) <span class="type">Nothing</span> f = <span class="type">Nothing</span></span><br><span class="line">    (&gt;&gt;=) (<span class="type">Just</span> x) f = f x</span><br></pre></td></tr></table></figure><p>注意第四行代码，这里的<code>Just</code>中的值被拆出来放进函数<code>f</code>里，而这里的<code>f</code>就是<code>return</code>，所以又产生了原先的 Monad。</p><h4 id="associativity-law">Associativity Law</h4><p><code>&gt;&gt;=</code>函数符和结合律。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; f x = <span class="type">Just</span> (x + <span class="number">3</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; g x = <span class="type">Just</span> (x * <span class="number">2</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; (<span class="type">Just</span> <span class="number">1</span> &gt;&gt;= f) &gt;&gt;= g</span><br><span class="line"><span class="type">Just</span> <span class="number">8</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Just</span> <span class="number">1</span> &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</span><br><span class="line"><span class="type">Just</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><p>这里的结合律体现的不是很明显，我们考虑形如<code>a -&gt; v</code>普通函数之间的运算<code>.</code></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</span><br><span class="line"><span class="title">f</span> . g = (\x -&gt; f (g x))</span><br></pre></td></tr></table></figure><p>则有</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(f . g). h == f . (g . h)</span><br></pre></td></tr></table></figure><p>那么对于形如<code>Monad m =&gt; a -&gt; m b</code>的函数，有</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(&lt;=&lt;) :: (<span class="type">Monad</span> m) =&gt; (b -&gt; m c) -&gt; (a -&gt; m b) -&gt; (a -&gt; m c)</span><br><span class="line"><span class="title">f</span> &lt;=&lt; g = (\x -&gt; g x &gt;&gt;= f)</span><br></pre></td></tr></table></figure><p>易得</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(f &lt;=&lt; g) &lt;=&lt; h == f &lt;=&lt; (g &lt;=&lt; h)</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; f x = <span class="type">Just</span> (x + <span class="number">3</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; g x = <span class="type">Just</span> (x * <span class="number">2</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; h x = <span class="type">Just</span> (x + <span class="number">5</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; ((f &lt;=&lt; g) &lt;=&lt; h) <span class="number">7</span></span><br><span class="line"><span class="type">Just</span> <span class="number">27</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (f &lt;=&lt; (g &lt;=&lt; h)) <span class="number">7</span></span><br><span class="line"><span class="type">Just</span> <span class="number">27</span></span><br></pre></td></tr></table></figure><p>如果读者了解幺半群的概念，就会意识到这里<code>return</code>就是<code>&lt;=&lt;</code>运算的幺元（有时也称为单位元）：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; (f &lt;=&lt; return) <span class="number">7</span></span><br><span class="line"><span class="type">Just</span> <span class="number">10</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (return &lt;=&lt; f) <span class="number">7</span></span><br><span class="line"><span class="type">Just</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="monad-辟谣">Monad 辟谣</h2><p>谣言 1：Monad 不纯</p><p>回答：你才不纯！你全家都不纯！</p><p><span class="math inline">\(\lambda\)</span> 演算与图灵机等价，Haskell 显然也与 C++ 等价，纯函数本身就能解决所有问题。</p><p>谣言 2：Monad 能实现状态</p><p>回答：<span class="math inline">\(\lambda\)</span> 演算中状态可以用映射的方式模拟，Monad 只是一个更方便的语法用来处理状态。</p><p>谣言 3：Monad 是 Haskell 中的嵌入式命令式语言</p><p>回答：Haskell 是纯粹的函数式编程语言，<code>do</code> 语句只是长得像命令式而已。下面的例子会解释 <code>do</code> 其实只是 <code>&gt;==</code>的语法糖。</p><p>谣言 4：了解 Monad 必须理解范畴论</p><p>回答：不不不，在不了解范畴论的情况下并不是不能写出包含 Monad 的程序，只是要更进一步的话需要一些范畴论的知识。</p><p>谣言 5：Monad 是 Haskell 独有的</p><p>回答：Monad 一开始是范畴论的概念，后来被函数式编程（FP）借用。任何编程语言都可以实现 Monad，包括 C++ 也可以，这只是必要性的问题。</p><p>谣言 5：Monad 用来进行 IO 操作</p><p>回答：Monad 的特性确实使它很适合用来管理 IO，但 Monad 本身在定义上和 IO 半毛钱关系没有！</p><p>谣言 6：Monad 用来进行有副作用的操作</p><p>回答：同上！！！</p><p><strong>谣言 7</strong>：JavaScript 中的 <code>Promise</code>是 Monad</p><p><strong>回答</strong>：这个谣言流传的非常广泛，在网上很多地方都能看到“Promise 是一种 Monad”的观点。<code>Promise</code>确实看起来像一个 Monad，也有类似 Monad 的操作，但它并不符合上述三条定律，即不符合 Monad 的定义。如果你在 Haskell 中弄出类似的东西并将其作为 Monad 使用，肯定会在 <code>do</code>语句等地方出大问题！</p><p>让我们仔细审视一下 Promise 是否符合上述三条定律：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x).<span class="title function_">then</span>(f) === <span class="title function_">f</span>(x)</span><br><span class="line">m.<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(x)) === m</span><br><span class="line">m.<span class="title function_">then</span>(f).<span class="title function_">then</span>(g) === m.<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="title function_">f</span>(x).<span class="title function_">then</span>(g))</span><br></pre></td></tr></table></figure><p>仿佛是符合的，但如果<code>x</code>是一个 Promise，<code>Promise.resolve(x)</code>就会把<code>a</code>给<code>resolve</code>掉，也就不是一个 Promise 了，即不符合第一条Left Unit Law。</p><h2 id="monad-的具体应用">Monad 的具体应用</h2><h3 id="maybe-类型">Maybe 类型</h3><p>Haskell 中的 Maybe 类型在概念上与 Haskell 的 <code>Option&lt;T&gt;</code>类似，由一个值或者是<code>Nothing</code>组成，用来表示返回无意义值。</p><p>举个例子，用 Maybe 类型来写除法：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">safeDiv</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">safeDiv</span> _ <span class="number">0</span> = <span class="type">Nothing</span></span><br><span class="line"><span class="title">safeDiv</span> a b = <span class="type">Just</span> (a / b)</span><br></pre></td></tr></table></figure><p>假设我们要计算 <code>a / b / c / d / e</code>，在知道 Haskell 的模式匹配用法后，我们可以写出这样的代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calc</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">calc</span> a b c d e = <span class="keyword">case</span> safeDiv a b <span class="keyword">of</span></span><br><span class="line">    <span class="type">Just</span> x -&gt; <span class="keyword">case</span> safeDiv x c <span class="keyword">of</span></span><br><span class="line">        <span class="type">Just</span> y -&gt; safeDiv y d</span><br><span class="line">            <span class="type">Just</span> z -&gt; safeDiv z e</span><br><span class="line">            <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br></pre></td></tr></table></figure><p>令人头大，但利用 Monad 的 <code>&gt;&gt;=</code> 运算可以很方便地完成“模式匹配拆包再打包的过程”，具体代码如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calc</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">calc</span> a b c d e = </span><br><span class="line">    safeDiv a b &gt;&gt;= (\x -&gt;</span><br><span class="line">    safeDiv x c &gt;&gt;= (\y -&gt;</span><br><span class="line">    safeDiv y d &gt;&gt;= (\z -&gt;</span><br><span class="line">    safeDiv z e)))</span><br></pre></td></tr></table></figure><p>简单明了多了，但是嵌套的闭包第一眼看上去并不直观。所以 Haskell 还提供了 <code>do</code> 语句作为 <code>&gt;==</code> 的语法糖：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calc</span> :: <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">calc</span> a b c d e = <span class="keyword">do</span></span><br><span class="line">    x &lt;- safeDiv a b</span><br><span class="line">    y &lt;- safeDiv x c</span><br><span class="line">    z &lt;- safeDiv z d</span><br><span class="line">    safeDiv z e</span><br></pre></td></tr></table></figure><p>这就是常见的 <code>do</code> 语句的实际含义。注意，这并不是命令式编程，只是看起来像，它的本质是嵌套的闭包。</p><p>Maybe 的 Monad 实际上是这样实现的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">    return x = <span class="type">Just</span> x</span><br><span class="line">    (&gt;&gt;=) <span class="type">Nothing</span> f = <span class="type">Nothing</span></span><br><span class="line">    (&gt;&gt;=) (<span class="type">Just</span> x) f = f x</span><br></pre></td></tr></table></figure><p>第三行语句帮助我们略去了不断检查是否为<code>Nothing</code>的过程。</p><h3 id="io-monad">IO Monad</h3><p>可能您还是不明白 Monad 到底有什么用，这里就再举一个例子： IO</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line">    putStrLn <span class="string">&quot;What is your name?&quot;</span></span><br><span class="line">    name &lt;- getLine</span><br><span class="line">    putStrLn (<span class="string">&quot;Hello, &quot;</span> ++ name ++ <span class="string">&quot;!&quot;</span>)</span><br></pre></td></tr></table></figure><p>它等价于下面的代码：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">main</span> = putStrLn <span class="string">&quot;What is your name?&quot;</span> &gt;== (\_ -&gt;</span><br><span class="line">       getLine &gt;== (\name -&gt;</span><br><span class="line">       putStrLn (<span class="string">&quot;Hello, &quot;</span> ++ name ++ <span class="string">&quot;!&quot;</span>)))</span><br></pre></td></tr></table></figure><p>（<code>do</code> 语句实质上是 <code>&gt;==</code> 的语法糖）</p><p>这样写的原因是 Haskell 中对于语句的执行顺序并没有严格规定（惰性求值），但 IO 操作必须以顺序的方式执行。使用 Monad 嵌套后，第一行、第二行、第三行就肯定会按照严格的顺序执行。（被调用前会先被求值。）</p><h2 id="自函子范畴上的幺半群">自函子范畴上的幺半群</h2><p>这里解释一句老话“一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，这有什么难以理解的？”</p><p>(笔者并不了解范畴论，内容可能有错漏。)</p><h3 id="范畴">范畴</h3><p>要真正理解 Monad 实际上只能从范畴论的角度入手。</p><p>首先，范畴论中将所有事物都看作“对象”，1 是对象，<code>lambda x: x * 2</code> 是对象，<code>String::from("hello")</code> 是对象，姚明是对象，汽车的行驶是对象，加法是对象，考试作弊的方法是对象，范畴也是对象（这个很重要），你正在读的这句话也是对象。</p><p>对象时间的关系被称为“态射”，最常见的态射就是函数或者说映射（如集合论中），态射也是一种对象。</p><p>一个范畴 <span class="math inline">\(\mathcal{C}\)</span> 由两个类给定：一个对象的类和一个态射的类。用人话来说就是一些对象和对象之间的态射。</p><p>态射之间有组合操作，组合操作的幺元是单位态射 <span class="math inline">\(id\)</span>，它不改变对象，与任何态射组合都得到原态射本身。</p><h3 id="函子">函子</h3><p>前面说过范畴也是对象，所以说范畴之间也存在态射。<strong>函子就是范畴之间的态射</strong></p><p>以下内容摘自维基百科：</p><blockquote><p>设 <span class="math inline">\(\mathcal{C}\)</span> 和 <span class="math inline">\(\mathcal{D}\)</span> 为范畴。从 <span class="math inline">\(\mathcal{C}\)</span> 到 <span class="math inline">\(\mathcal{D}\)</span> 的函子为一映射 <span class="math inline">\(F\)</span> ：</p></blockquote><blockquote><ol type="1"><li>将每个对象 <span class="math inline">\(X \in \mathcal{C}\)</span> 映射至一对象 <span class="math inline">\(F(X) \in \mathcal{D}\)</span> 上，</li><li>将每个态射 $f:X Y  $ 映射至一态射上，使之满足下列条件：</li></ol><ul><li>对任何对象 <span class="math inline">\(X \in \mathcal{C}\)</span> ，恒有 <span class="math inline">\(F(id_X) = id_{F(X)}\)</span> 。</li><li>对任何态射 <span class="math inline">\(f:X \rightarrow Y\)</span>, <span class="math inline">\(g:Y \rightarrow Z\)</span> ，恒有 <span class="math inline">\(F(g \circ f) = F(g) \circ F(f)\)</span> 。换言之，函子会保持单位态射与态射的复合。</li></ul><p>由一范畴映射至其自身的函子称之为“自函子”。</p></blockquote><p>上面的两个条件在 Haskell 中的表述其实并不复杂：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> id = id</span><br><span class="line"><span class="title">fmap</span> (f . g) = fmap f . fmap g</span><br></pre></td></tr></table></figure><p>显而易见的，整个 Haskell 中只有一个范畴，即数据类型。<strong>所以在 Haskell 中，所有的函子都是自函子</strong>。</p><h3 id="cat-范畴">Cat 范畴</h3><p>Cat 范畴简单来说就是范畴的范畴，它的态射就是函子。Cat 范畴中也有单位态射，也称为单位函子 <span class="math inline">\(Id\)</span>，它是一个特殊的自函子。同理，单位函子不改变范畴，与任何函子组合都得到原函子本身。</p><h3 id="幺半群">幺半群</h3><p>幺半群（Monoid）简单来说就是有幺元的半群。</p><p>半群是指一个非空集合 <span class="math inline">\(S\)</span>，<span class="math inline">\(S\)</span> 上定义了一个闭合二元运算运算 <span class="math inline">\(\circ\)</span> （闭合是指 <span class="math inline">\(\circ: S \times S \rightarrow S\)</span>），满足结合律：</p><p>对于任意 <span class="math inline">\(a, b, c \in S\)</span>，<span class="math inline">\((a \circ b) \circ c = a \circ (b \circ c)\)</span></p><p>则 <span class="math inline">\(\langle S, \circ \rangle\)</span> 是一个半群。</p><p>幺半群是指对于一个半群 <span class="math inline">\(\langle S, \circ \rangle\)</span>，存在 <span class="math inline">\(e \in S\)</span>（幺元），使得其满足单位元定律：</p><p>对于任意 <span class="math inline">\(a \in S\)</span>，<span class="math inline">\(a \circ e = e \circ a = a\)</span></p><p>则 <span class="math inline">\(\langle S, \circ, e \rangle\)</span> 是一个幺半群。</p><p>例如 <span class="math inline">\(\langle N, +, 0 \rangle\)</span> 就是一个幺半群。</p><p>在 Haskell 中幺半群是这么定义的：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Monoid</span> m <span class="keyword">where</span></span></span><br><span class="line">    mempty :: m</span><br><span class="line">    mappend :: m -&gt; m -&gt; m</span><br><span class="line">    mconcat :: [m] -&gt; m</span><br><span class="line">    mconcat = foldr mappend mempty</span><br></pre></td></tr></table></figure><p>其中 <code>mempty</code>就是半群中的幺元，<code>mappend</code>就是半群中的二元运算。</p><p><span class="math inline">\(\langle N, +, 0 \rangle\)</span> 可以表示为</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="number">0</span></span><br><span class="line">    mappend = (+)</span><br></pre></td></tr></table></figure><p>同样的，<span class="math inline">\(\langle N, \times, 1 \rangle\)</span> （也是一个幺半群）可以表示为</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monoid</span> <span class="type">Int</span> <span class="keyword">where</span></span></span><br><span class="line">    mempty = <span class="number">1</span></span><br><span class="line">    mappend = (*)</span><br></pre></td></tr></table></figure><h3 id="monad-1">Monad</h3><p>Monad 说白了不过就是自函子范畴上的一个幺半群而已。</p><p>考虑一个 Cat 范畴，它只有一个对象：范畴 <span class="math inline">\(\mathcal{C}\)</span> ，那么它的态射就是就是范畴 <span class="math inline">\(\mathcal{C}\)</span> 的自函子，这些自函子构成一个自函子范畴。</p><p><strong>Haskell 中只有数据类型一个范畴，所以 Haskell 中的所有函子都是自函子，构成一个自函子范畴，Monad 是 Haskell 的自函子的一个子集。而前面说过这个子集本身符合幺半群的定义，所以 Monad 本质上就是自函子范畴上的一个幺半群。</strong></p><p>这就解释了那句老话“一个单子（Monad）说白了不过就是自函子范畴上的一个幺半群而已，这有什么难以理解的？”</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> Haskell </tag>
            
            <tag> 范畴论 </tag>
            
            <tag> 函数式编程 </tag>
            
            <tag> Monad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 GitHub Actions 部署 Hexo 博客</title>
      <link href="/archives/2228098991/"/>
      <url>/archives/2228098991/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-博客的自动部署">Hexo 博客的自动部署</h2><p>使用 Hexo 发布博客最原始的方法自然是直接编辑完文件后 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code>，但这种做法长期来看存在以下问题：</p><ol type="1"><li><p>迁移不便，在其他地方编写博客时，要么把笔记本背着到处跑，要么将整个文件夹复制到 U 盘里然后带着，并且事后同步博客也很不方便。</p></li><li><p>需要在本地配置 Node.js 环境，并且可能因为 Node.js 出现各种奇奇怪怪的问题。</p></li><li><p>本地部署消耗资源。</p></li></ol><p>所以自动部署就成了 Hexo 博客的常见部署方式。</p><h3 id="ci-cd-服务">CI / CD 服务</h3><p>常见的自动部署服务有 Travis CI、Netlify、Vercel 等，但这些自动部署服务大多在国内访问都不通畅，部署到 GitHub Pages 则需要通过 Token 这种不安全的方式。相较之下，GitHub Actions 就脱颖而出了：它是 GitHub 直接集成的！这就意味着 GitHub Actions 可以直接使用 GitHub 仓库的密钥，用 SSH 推送到 GitHub Pages 仓库。并且 GitHub Actions 的速度也足够快，部署 Hexo 博客往往只需要 30s 左右。同样的，因为本身是 GitHub 的集成服务，GitHub Actions 的使用也比其他服务要简单，只需新建一个文件即可。</p><h2 id="github-actions-的使用">GitHub Actions 的使用</h2><h3 id="ssh-密钥">SSH 密钥</h3><p>使用 GitHub Actions 时最好用 SSH 这种安全的方式推送到你的仓库，所以我们要先生成一个新的 SSH 密钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -f hexo-deploy-key -C <span class="string">&quot;yourname.github.io&quot;</span></span><br></pre></td></tr></table></figure><p>这个命令会在当前目录下生成 hexo-deploy-key.pub（公钥）和 hexo-deploy-key（私钥）两个文件</p><p><strong>注意</strong>：我的 Hexo 源文件存放在 blog 仓库，GitHub Pages 部署在 HeliumOI.github.io 仓库，后面的配置请读者按照自身情况进行调整。</p><p>首先进入你的页面文件仓库（即 yourname.github.io），打开 Settings -&gt; Deploy keys，添加一个 Deploy key，名称随意，内容为文件 hexo-deploy-key.pub 的内容。注意一定要勾选下面的 <code>Allow write access</code> 选项，否则部署时这个密钥无法用来推送到仓库。</p><p>然后进入你的 Hexo 源文件仓库，打开 Settings -&gt; Secrets，添加一个 Secret，名称为 <code>DEPLOY_KEY</code>，后面我们需要在 Workflow 中通过名称 <code>DEPLOY_KEY</code> 使用这个密钥，内容为文件 hexo-deploy-key 的内容。</p><h3 id="workflow-文件">Workflow 文件</h3><p>在 Hexo 源文件夹中新建一个文件 <code>.github/workflows/deploy.yml</code>，我的配置如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">Deploy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只监听 master 分支的改动</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build-and-deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">        <span class="comment"># 获取博客源码和主题</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 主题文件夹，如果你的主题不是 git submodule 可以不配置</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">repository:</span> <span class="string">jerryc127/hexo-theme-butterfly</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">master</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">themes/butterfly</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 这里用的是 Node.js 12.x</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Node.js</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">node-version:</span> <span class="string">&#x27;12&#x27;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 缓存 Node 模块，提高构建速度</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">yarn</span> <span class="string">cache</span> <span class="string">directory</span> <span class="string">path</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">yarn-cache-dir-path</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;::set-output name=dir::$(yarn cache dir)&quot;</span></span><br><span class="line"></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">yarn</span> <span class="string">cache</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/cache@v2</span></span><br><span class="line">        <span class="attr">id:</span> <span class="string">yarn-cache</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">path:</span> <span class="string">$&#123;&#123;</span> <span class="string">steps.yarn-cache-dir-path.outputs.dir</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">key:</span> <span class="string">$&#123;&#123;</span> <span class="string">runner.os</span> <span class="string">&#125;&#125;-yarn-$&#123;&#123;</span> <span class="string">hashFiles(&#x27;**/yarn.lock&#x27;)</span> <span class="string">&#125;&#125;</span></span><br><span class="line">          <span class="attr">restore-keys:</span> <span class="string">|</span></span><br><span class="line"><span class="string">            $&#123;&#123; runner.os &#125;&#125;-yarn-</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 安装依赖，我这里使用了 pandoc 渲染页面，所以先安装了 pandoc 再安装 Node 模块</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          wget https://github.com/jgm/pandoc/releases/download/2.10.1/pandoc-2.10.1-1-amd64.deb</span></span><br><span class="line"><span class="string">          sudo dpkg -i pandoc-2.10.1-1-amd64.deb</span></span><br><span class="line"><span class="string">          yarn install --prefer-offline --frozen-lockfile</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 从之前设置的 secret 获取部署私钥</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">environment</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.DEPLOY_KEY</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          sudo timedatectl set-timezone &quot;Asia/Shanghai&quot;</span></span><br><span class="line"><span class="string">          mkdir -p ~/.ssh</span></span><br><span class="line"><span class="string">          echo &quot;$DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      <span class="comment"># 生成并部署</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">npx</span> <span class="string">hexo</span> <span class="string">clean</span> <span class="string">&amp;&amp;</span> <span class="string">npx</span> <span class="string">hexo</span> <span class="string">g</span> <span class="string">&amp;&amp;</span> <span class="string">npx</span> <span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure><p>然后再修改一下 Hexo 源文件夹中的 <code>_config.yml</code>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span>  <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span>  <span class="string">git@github.com:yourname/yourname.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span>  <span class="string">master</span></span><br><span class="line">  <span class="attr">name:</span>  <span class="string">yourname</span></span><br><span class="line">  <span class="attr">email:</span>  <span class="string">yourmail@gmail.com</span></span><br></pre></td></tr></table></figure><p>这里注意一个问题：很多人（其中也包括我）会在安装主题时保留主题目录中的 <code>.git</code> 文件夹以方便更新，GitHub Actions 对 <code>git submodule</code> 的处理有点问题。（同为 CI 系统，Vercel、Cloudflare Pages 等就不存在这个问题）所以需要在 Workflow 文件中用 <code>with</code> 标注出你使用的 <code>submodule</code></p><h2 id="使用体验">使用体验</h2><p>Push 到仓库后自动触发 GitHub Actions 部署博客，大约 30s 左右就完成了，飞一般的速度！</p><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/githubactions1.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> GitHub </tag>
            
            <tag> GitHub Actions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Cloudflare Workers 反代 Blogger</title>
      <link href="/archives/1924021233/"/>
      <url>/archives/1924021233/</url>
      
        <content type="html"><![CDATA[<h2 id="缘起">缘起</h2><p><a href="https://sophonci117.me/archives/2811309648/">上一篇文章</a>中提到了利用自定义域名搭建可以在国内访问的 Blogger 博客的方法，但经过讨论和测试，这个方法存在以下几个问题：</p><ol type="1"><li><p>文章中的图片等资源会被 Google 服务器自动缓存。对国外的用户来说，这一机制可以大大提高页面加载的速度，但对国内用户来说则恰恰相反。目前除了在 Markdown 编辑器的预览中直接复制富文本外还没有别的解决方案。</p></li><li><p>地址 ghs.google.com 并不一定能解析到一个国内可以访问的地址。虽然只要使用自定义域名就可以规避 DNS 污染和 SNI 阻断，但是 Google 的服务器受到的是特殊待遇，直接针对 IP 地址进行阻断，自定义域名也经常抽风。</p></li></ol><p>反观另一个同样无法访问的网站 Pixiv，网上给出的解决方案是直接在本地运行 Nginx 进行反代就可以访问。这个解决方案本质上是利用了 SNI 协议的漏洞，即为了区分前往同一地址的不同域名，SNI 协议中会以明文展示你需要前往的域名。明文展示显然会导致在特定的地区访问不稳定等种种问题，所以互联网领域的开发者们创造了 ESNI，后来又再 ESNI 的基础上创造了 ECHO，然后是 ECH……然而根本问题是大多数网站根本就不打算去支持 ECH。为了解决在特定地区访问不稳定的问题，给 SNI 加密固然是一个方法，但另一个更简单粗暴的方法是：弄一个假的 SNI 或者根本不发 SNI！</p><p>（这里插播一个小故事：运营商有时会给官网等网站免流量，就是用 SNI 来判断你访问的是那个网站。曾经有人利用这个机制盗刷了价值数十万元的流量，然后成功地被判刑了……）</p><p>总而言之，网络上给出的 Pixiv 反代方案其实就是利用了 Nginx 反代时不支持 SNI，并且 Pixiv 并没有直接被封锁 IP，这就是为什么同样的方案不能被用来访问 Google，Blogger 使用自定义域名也偶尔抽风。</p><p>对于问题 2，套一层 CDN 看似是一个解决方案，但实践表明这会导致包括但不限于循环重定向/HTTPS 证书错误/404 Not Found 等问题……</p><h2 id="cloudflare-workers">Cloudflare Workers</h2><h3 id="缘起-1">缘起</h3><p><span class="citation" data-cites="PetrichorArk">[@PetrichorArk]</span>(https://t.me/PetrichorArk) 提出可以用 CF Workers 反代来解决上述问题。简单来说就是用一个 CF Workers 在访问时爬取 Blogger 的页面，将页面中的资源进行替换后再反会给访问者。<del>（万能的 Cloudflare Workers）</del></p><h3 id="代码实现">代码实现</h3><p>以下是 <span class="citation" data-cites="PetrichorArk">[@PetrichorArk]</span>(https://t.me/PetrichorArk) 编写的实现代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * URL:</span></span><br><span class="line"><span class="comment"> * https://something.something.workers.dev/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">addEventListener</span>(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    event.<span class="title function_">respondWith</span>(<span class="title function_">handleRequest</span>(event.<span class="property">request</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> blogHost = <span class="string">&#x27;something.blogspot.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Map</span>&#125; <span class="variable">error</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Number</span>&#125; <span class="variable">status</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Boolean</span>&#125; <span class="variable">cacheable</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">handleInvalidRequest</span>(<span class="params">error, status, cacheable</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(error), &#123;</span><br><span class="line">        <span class="attr">status</span>: status,</span><br><span class="line">        <span class="attr">statusText</span>: <span class="string">&#x27;Invalid Request&#x27;</span>,</span><br><span class="line">        <span class="attr">headers</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;strict-transport-security&#x27;</span>: <span class="string">&#x27;max-age=31536000; includeSubDomains; preload&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;timing-allow-origin&#x27;</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;x-server&#x27;</span>: <span class="string">&#x27;blog-proxy-2cff9aba&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;x-xss-protection&#x27;</span>: <span class="string">&#x27;1; mode=block&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (cacheable) &#123;</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;cache-control&#x27;</span>, <span class="string">&#x27;public, max-age=29030400, immutable&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">String</span>&#125; <span class="variable">url</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fromCache</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> cache = caches.<span class="property">default</span></span><br><span class="line">    <span class="keyword">const</span> matched = <span class="keyword">await</span> cache.<span class="title function_">match</span>(url)</span><br><span class="line">    <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">        <span class="keyword">return</span> matched</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">fetch</span>(url)</span><br><span class="line">    <span class="keyword">if</span> (resp.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; resp.<span class="property">status</span> &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">new</span> <span class="title class_">Response</span>(resp.<span class="property">body</span>, &#123;</span><br><span class="line">            <span class="attr">status</span>: resp.<span class="property">status</span>,</span><br><span class="line">            <span class="attr">statusText</span>: resp.<span class="property">statusText</span>,</span><br><span class="line">            <span class="attr">headers</span>: resp.<span class="property">headers</span></span><br><span class="line">        &#125;)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">delete</span>(<span class="string">&#x27;expires&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">delete</span>(<span class="string">&#x27;vary&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">delete</span>(<span class="string">&#x27;access-control-allow-origin&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;cache-control&#x27;</span>, <span class="string">&#x27;public, max-age=29030400, immutable&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;strict-transport-security&#x27;</span>, <span class="string">&#x27;max-age=31536000; includeSubDomains; preload&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;timing-allow-origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;x-mirrored-url&#x27;</span>, url)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;x-server&#x27;</span>, <span class="string">&#x27;blog-proxy-2cff9aba&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;x-xss-protection&#x27;</span>, <span class="string">&#x27;1; mode=block&#x27;</span>)</span><br><span class="line">        <span class="keyword">await</span> cache.<span class="title function_">put</span>(url, response.<span class="title function_">clone</span>())</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">handleInvalidRequest</span>(&#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;status_error&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: url,</span><br><span class="line">    &#125;, resp.<span class="property">status</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">URL</span>&#125; <span class="variable">url</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">proxy</span>(<span class="params">url</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> proxyHost = url.<span class="property">hostname</span></span><br><span class="line">    url.<span class="property">hostname</span> = blogHost</span><br><span class="line">    <span class="keyword">const</span> urlStr = url.<span class="property">href</span></span><br><span class="line">    <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">fetch</span>(urlStr)</span><br><span class="line">    <span class="keyword">if</span> (resp.<span class="property">status</span> &gt;= <span class="number">200</span> &amp;&amp; resp.<span class="property">status</span> &lt; <span class="number">400</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> body</span><br><span class="line">        <span class="keyword">const</span> type = resp.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&#x27;content-type&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> (type &amp;&amp; type.<span class="title function_">startsWith</span>(<span class="string">&#x27;text/&#x27;</span>)) &#123;</span><br><span class="line">            body = <span class="keyword">await</span> resp.<span class="title function_">text</span>()</span><br><span class="line">            body = body.<span class="title function_">replaceAll</span>(blogHost, proxyHost)</span><br><span class="line">            body = body.<span class="title function_">replace</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">`&lt;link href=&#x27;(.*?)<span class="subst">$&#123;proxyHost&#125;</span>/(.*?)&#x27; rel=&#x27;canonical&#x27;/&gt;`</span>), <span class="string">`&lt;link href=&#x27;$1<span class="subst">$&#123;blogHost&#125;</span>/$2&#x27; rel=&#x27;canonical&#x27;/&gt;`</span>)</span><br><span class="line">            body = body.<span class="title function_">replace</span>(<span class="regexp">/lh\w*?.googleusercontent.com/g</span>, proxyHost + <span class="string">&#x27;/_image&#x27;</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            body = resp.<span class="property">body</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">new</span> <span class="title class_">Response</span>(body, &#123;</span><br><span class="line">            <span class="attr">status</span>: resp.<span class="property">status</span>,</span><br><span class="line">            <span class="attr">statusText</span>: resp.<span class="property">statusText</span>,</span><br><span class="line">            <span class="attr">headers</span>: resp.<span class="property">headers</span></span><br><span class="line">        &#125;)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">delete</span>(<span class="string">&#x27;vary&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">delete</span>(<span class="string">&#x27;access-control-allow-origin&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;strict-transport-security&#x27;</span>, <span class="string">&#x27;max-age=31536000; includeSubDomains; preload&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;timing-allow-origin&#x27;</span>, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;x-mirrored-url&#x27;</span>, urlStr)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;x-server&#x27;</span>, <span class="string">&#x27;blog-proxy-2cff9aba&#x27;</span>)</span><br><span class="line">        response.<span class="property">headers</span>.<span class="title function_">set</span>(<span class="string">&#x27;x-xss-protection&#x27;</span>, <span class="string">&#x27;1; mode=block&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> response</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">handleInvalidRequest</span>(&#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;status_error&#x27;</span>,</span><br><span class="line">        <span class="attr">url</span>: urlStr,</span><br><span class="line">    &#125;, resp.<span class="property">status</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">Request</span>&#125; <span class="variable">request</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">handleRequest</span>(<span class="params">request</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> url</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">handleInvalidRequest</span>(&#123; <span class="attr">msg</span>: <span class="string">&#x27;url_parse_error&#x27;</span>, <span class="attr">url</span>: request.<span class="property">url</span> &#125;, <span class="number">400</span>, <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (url.<span class="property">pathname</span>.<span class="title function_">startsWith</span>(<span class="string">&#x27;/_image/&#x27;</span>)) &#123;</span><br><span class="line">        url.<span class="property">hostname</span> = <span class="string">&#x27;lh3.googleusercontent.com&#x27;</span></span><br><span class="line">        url.<span class="property">pathname</span> = url.<span class="property">pathname</span>.<span class="title function_">substr</span>(<span class="number">7</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">fromCache</span>(url)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="title function_">proxy</span>(url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用时记得将代码开头处的 <code>blogHost</code> 赋值为你自己的 Blogger 的 Blogspot 域名。原先的域名要接触与 Blogger 的绑定，这样 CF Workers 才能访问到你的真实博客页面而不是一个重定向页面。再将你的自定义域名解析到你的 CF Workers。（并在 Workers 面板设置路由。）</p><h2 id="总结">总结</h2><p>Blogger 的地址 <code>ghs.google.com</code> 如果解析到国内可以访问的 IP，访问速度其实比 Cloudflare 的节点更快，但对于主题模版的修改的资源的处理则让人头大。相比之下，Cloudflare Workers 反代的方式更稳定也更便捷。<del>不过折腾得这么麻烦为什么不直接用 Hexo，果然生命不止折腾不息吗。</del></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Blogger </tag>
            
            <tag> Google </tag>
            
            <tag> Cloudflare </tag>
            
            <tag> SNI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现 Blogger 国内访问</title>
      <link href="/archives/2811309648/"/>
      <url>/archives/2811309648/</url>
      
        <content type="html"><![CDATA[<h2 id="关于-blogger">关于 Blogger</h2><p><a href="https://www.ruanyifeng.com/blog/">阮一峰</a>曾经提出过博客的“三个阶段”理论：</p><blockquote><p>第一阶段，刚接触Blog，觉得很新鲜，试着选择一个免费空间来写。 第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。 第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p></blockquote><p>这一理论在现实中未必正确，因为在有个人服务器的情况下，更多的人还是愿意选择 WordPress 或 Typecho 等自建的动态博客。但在没有服务器时，按照阮一峰老师的说法使用 Hexo、Jekyll 等静态页面生成器并部署在 GitHub Pages 上同样不失为一个好的选择，但所需要的技术对部分人并不友好。</p><p>所以部分人更愿意在简书、CSDN 等博客平台上写作，由博客平台直接提供软件，自己只需要写作内容。这类博客平台的优点是便捷，SEO 好，缺点是界面单调，广告繁多，并且有时内容并不由自己控制。博客园是这类平台中较为优秀的一个，可以自定义网页样式，吸引了大量的用户，但前段时间的网站整改让很多人心寒。相较之下，Blogger 创立二十余年，作为世界上最早的博客平台之一，在被 Google 收购后功能更是不断晚上，各方面的指标都很优秀，但是作为 Google 的产品，Blogger 在国内访问有时并不稳定，这个问题可以靠自定义域名来解决。</p><h2 id="自定义域名">自定义域名</h2><p>点击 Blogger 的“设置 -&gt; 正在发布 -&gt; 自定义域名”，在其中输入你的域名。</p><p>然后再设置DNS记录，一下用 Cloudflare 演示：</p><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/blogger1.png" /></p><p>（代理状态必须是“仅限DNS”，否则无法认证。）</p><p>将你的域名关联到 <code>ghs.google.com</code>。此时你的 Blogger 已经可以从自定义域名访问了，只是还不支持 HTTPS，所以还要在 Blogger 中将“设置 -&gt; HTTPS -&gt; HTTPS 可用性”打开，以产生你的自定义域名的 HTTPS 证书。这个操作需要十几分钟的时间，当“HTTPS 可用性”显示为“状态：可用”时就可以用 HTTPS 访问了。</p><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/blogger2.png" /></p><h2 id="替换资源">替换资源</h2><p>这时你的 Blogger 虽然已经能从国内访问了，但背景图片、头像、CSS、JavaScript 等资源仍然需要从 Google 的服务器加载，在国内仍然无法正常使用，所以我们需要编辑主题。</p><p>点击 “设置 -&gt; 主题背景 -&gt; 修改HTML”</p><h3 id="背景图片">背景图片</h3><p>在主题源码中查找</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(https://themes.googleusercontent.com/image?id=L1lcAxxz0CLgsDzixEprHJ2F38TyEjCyE3RSAjynQDks0lT1BDc1OxXKaTEdLc89HPvdB11X9FDw)</span><br></pre></td></tr></table></figure><p>将内容替换成你自己的背景图片的地址。</p><h3 id="头像">头像</h3><p>在主题源码中查找</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&#x27;profile-img&#x27;</span> <span class="attr">expr:alt</span>=<span class="string">&#x27;data:messages.myPhoto&#x27;</span> <span class="attr">expr:height</span>=<span class="string">&#x27;data:authorPhoto.height&#x27;</span> <span class="attr">expr:src</span>=<span class="string">&#x27;data:authorPhoto.image&#x27;</span> <span class="attr">expr:width</span>=<span class="string">&#x27;data:authorPhoto.width&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&#x27;profile-img&#x27;</span> <span class="attr">src</span>=<span class="string">&quot;你的头像地址&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="cssjavascript">CSS、JavaScript</h3><h4 id="屏蔽">屏蔽</h4><p>将<code>&lt;/head&gt;</code>替换为<code>&amp;lt;/head&amp;gt;&amp;lt;!--&lt;/head&gt;--&amp;gt;</code></p><p>将<code>&lt;/body&gt;</code>替换为<code>&amp;lt;!--&lt;/body&gt;--&amp;gt;&amp;lt;/body&amp;gt;</code></p><p>这样一来，自动插入的 CSS 和 JavaScript 就会被包含在注释里，不会被浏览器加载。</p><h4 id="加载">加载</h4><p><code>indie_compiled.js</code>这个文件必须被加载，否则页面无法正常显示，所以我们要把它替换成自己的资源。</p><p>在主题源码中查找</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b:template-script</span> <span class="attr">async</span>=<span class="string">&#x27;true&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;indie&#x27;</span> <span class="attr">version</span>=<span class="string">&#x27;1.0.0&#x27;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>将其替换为</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span>=<span class="string">&#x27;async&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/2404877392-indie_compiled.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了稳定，更好的办法是下载<code>https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/2404877392-indie_compiled.js</code>这个文件，上传到自己的空间里再引用。</p><h3 id="示例">示例</h3><p>示例可以参见<a href="https://blog.sophonci117.me/">我的 Blogger</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Blogger </tag>
            
            <tag> Google </tag>
            
            <tag> 域名 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「Ringo」- 朴素的 Hexo 主题</title>
      <link href="/archives/4016581467/"/>
      <url>/archives/4016581467/</url>
      
        <content type="html"><![CDATA[<h2 id="缘起">缘起</h2><p>第一次接触 Hexo 是在一片教程上，当时采用的是教程中使用的 <a href="https://github.com/theme-next/hexo-theme-next">Next</a> 主题。作为一款非常流行的 Hexo 主题，Next 确实十分优秀，外观简洁且功能完备，但在网络上还是太千篇一律。后来又改用了 <a href="https://github.com/bollnh/hexo-theme-material">Material</a> 主题，但因为该主题长期未更新，换成了风格类似的 <a href="https://github.com/Molunerfinn/hexo-theme-melody">Melody</a> 主题，过了一段时间又换成了基于 Melody 但功能更丰富的 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 主题。 <del>博客美化就和 Linux 桌面美化一样纠结。</del></p><h2 id="为什么要自己写">为什么要自己写</h2><blockquote><p>当你看到你用的主题出现在两个以上的博客的时候，那你就要考虑自己写一个了。 ——《Hexo 主题开发指南》</p></blockquote><p>这句话或许太过暴论，但确实说明了一点：博客主题应该是自己个人需要的主题，而不是直接从流行的教程上复制。虽然 <a href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a> 主题功能丰富而且美观，但抱着写一个完全符合自己审美的主题以及锻炼前端水平的想法，最终仍然决定进行 <a href="https://github.com/HeliumOI/hexo-theme-ringo">Ringo</a> 主题的开发。 <del>但说来说去还是在用别人的设计。</del></p><h2 id="ringo">Ringo</h2><h3 id="过程">过程</h3><p>Ringo 主题最初来自 <a href="https://github.com/memset0">memset0</a> 开发的 Typecho 主题 <a href="https://github.com/memset0/typecho-theme-ringo">typecho-theme-ringo</a>。但贫穷的 Sophon 并没有多余的零花钱能用来购买服务器，一直以来都在使用 Hexo 作为博客系统，所以就有了将其移植到 Hexo 上的想法。</p><p>因为在前端领域几乎没什么基础，所以开始时大多数地方都是在按照 landscape 等知名主题依样画葫芦，遇到问题则在 Google 上搜索大佬们的解决方案。其实 Hexo 的官方文档中对于一些 API 和机制都有比较详细的阐述，EasyHexo 则记录了一些小坑，很多问题都在 <a href="https://hqcfly.github.io/index.html">Yifei Zhang</a> 大佬的 <a href="https://hqcfly.github.io/2016/06/19/hexo-theme-guide/">Hexo 主题开发指南</a>中得到了解答。</p><p>实际开发遇到的问题主要有喜闻乐见的代码高亮等，阅读生成页面源码后发现 Hexo 实际上是使用 <code>table</code> 标签来支持行号显示，而主题的 CSS 中已经对表格进行了渲染，最终显示出来的代码便才不忍睹。因此最后的选择是关闭 Hexo 原生的 Highlight 代码渲染，在主题内部使用 Highlight。Ringo 主题支持的另一个代码高亮方案则是 Prettify，这是我所知道的几个代码渲染方案中唯一一个原生支持行号的，主要参考了 <a href="https://blog.skk.moe/post/add-prettify-to-hexo/">SukkaW 大佬的博客</a></p><p>一开始，主题中很多部分都使用了 jQuery，但在阅读了一些大佬们的博客后决定将使用 jQuery 的代码都换成原生 JS 实现，而负责图片显示的 FancyBox 因为本身就基于 jQuery，被换成了原生 JS 实现的 Viewer.js。由于经验不足，刚发布的主题中也有很多低级错误，例如在 <code>head</code> 标签中加载 JavaScript。</p><p>移植的过程中也因为静态博客和动态博客的区别遇到过一些问题。静态博客和动态博客的最大区别在于，动态博客可以直接调用博客系统提供的数据实现搜索等功能，而静态博客则不得不使用 JavaScript 在前端处理数据，这算是移植过程中遇到的困难之一。</p><p>博客的评论系统开始使用的是灵活的 Disqus，但考虑到通用性也增加了对 Gitalk 的支持，后来又加入了 Livere 和 Valine 评论系统。后来考虑到 Disqus 在国内访问不便，又使用了 <a href="https://skk.moe">SukkaW</a> 大佬的 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 项目渲染评论列表。 <del>（因经济条件而使用 Cloudflare Workerers 搭建 DisqusJS 反向代理）</del></p><h3 id="功能">功能</h3><p>一路踩坑后，还只是个雏形的 Ringo 主题已经拥有了以下功能：</p><ul class="task-list"><li><input type="checkbox" disabled="" checked="" />归档、标签、分类页面</li><li><input type="checkbox" disabled="" checked="" />i18n 支持</li><li><input type="checkbox" disabled="" checked="" />访问次数统计</li><li><input type="checkbox" disabled="" checked="" />数学公式（MathJax）</li><li><input type="checkbox" disabled="" checked="" />代码高亮（Highlight.js / Prettify）</li><li><input type="checkbox" disabled="" checked="" />图片（Viewer.js）</li><li><input type="checkbox" disabled="" checked="" />无 jQuery，纯原生 JavaScript</li><li><input type="checkbox" disabled="" checked="" />评论系统（Gitalk / Disqus / Valine / Livere）</li><li><input type="checkbox" disabled="" checked="" />页脚备案信息</li><li><input type="checkbox" disabled="" checked="" />Google Analytics</li></ul><h2 id="关于主题">关于主题</h2><h3 id="预览">预览</h3><ul><li><a href="https://ringo.sophonci117.me/">Hexo-Theme-Ringo</a></li></ul><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/ringo-demo.png" /></p><h3 id="下载">下载</h3><p><a href="https://github.com/HeliumOI/hexo-theme-ringo">HeliumOI/hexo-theme-ringo</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/HeliumOI/hexo-theme-ringo.git themes/ringo</span><br></pre></td></tr></table></figure><p>求 Star qwq</p><h3 id="license">License</h3><p><a href="https://github.com/HeliumOI/hexo-theme-ringo/blob/master/LICENSE"><img src="https://img.shields.io/github/license/HeliumOI/hexo-theme-ringo.svg?style=flat-square" alt="license" /></a></p><p>Open sourced under the GPL v3.0 license.</p><p>根据 GPL V3.0 许可证开源。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> Ringo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo更新到5.4.0</title>
      <link href="/archives/2192384774/"/>
      <url>/archives/2192384774/</url>
      
        <content type="html"><![CDATA[<h2 id="缘起">缘起</h2><p>因为更新后的的butterfly主题需要新版的Hexo，所以将Hexo更新到了5.4.0。但直接<code>npm install hexo</code>产生了一堆Warning，修改<code>package.json</code>有可能会破坏依赖。查找了相关资料后才得知更新Node.js项目需要使用<code>npm-check</code>和<code>npm-upgrade</code>两个包。</p><h2 id="更新">更新</h2><h3 id="安装">安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g npm-check</span><br><span class="line">npm install -g npm-upgrade</span><br></pre></td></tr></table></figure><h3 id="使用">使用</h3><p>运行<code>npm-check</code>会检测可用的更新。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">hexo                      😍  UPDATE!   Your <span class="built_in">local</span> install is out of <span class="built_in">date</span>. https://hexo.io/</span><br><span class="line">                                       npm install --save hexo@5.4.0 to go from 5.0.1 to 5.4.0</span><br><span class="line"></span><br><span class="line">hexo-abbrlink             😕  NOTUSED?  Still using hexo-abbrlink?</span><br><span class="line">                                       Depcheck did not find code similar to require(<span class="string">&#x27;hexo-abbrlink&#x27;</span>) or import from <span class="string">&#x27;hexo-abbrlink&#x27;</span>.</span><br><span class="line">                                       Check your code before removing as depcheck isn<span class="string">&#x27;t able to foresee all ways dependencies can be used.</span></span><br><span class="line"><span class="string">                                       Use --skip-unused to skip this check.</span></span><br><span class="line"><span class="string">                                       To remove this package: npm uninstall --save hexo-abbrlink</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">hexo-deployer-git         😎  MAJOR UP  Major update available. https://hexo.io/</span></span><br><span class="line"><span class="string">                                       npm install --save hexo-deployer-git@3.0.0 to go from 2.1.0 to 3.0.0</span></span><br><span class="line"><span class="string">                          😕  NOTUSED?  Still using hexo-deployer-git?</span></span><br><span class="line"><span class="string">                                       Depcheck did not find code similar to require(&#x27;</span>hexo-deployer-git<span class="string">&#x27;) or import from &#x27;</span>hexo-deployer-git<span class="string">&#x27;.</span></span><br><span class="line"><span class="string">                                       Check your code before removing as depcheck isn&#x27;</span>t able to foresee all ways dependencies can be used.</span><br><span class="line">                                       Use --skip-unused to skip this check.</span><br><span class="line">                                       To remove this package: npm uninstall --save hexo-deployer-git</span><br></pre></td></tr></table></figure><p><code>npm-upgrade</code>则会更新你的<code>package.json</code>文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Checking <span class="keyword">for</span> outdated dependencies <span class="keyword">for</span> <span class="string">&quot;/Users/sophon/Documents/blog/package.json&quot;</span>...</span><br><span class="line">[====================] 15/15 100%</span><br><span class="line"></span><br><span class="line">New versions of active modules available:</span><br><span class="line"></span><br><span class="line">  hexo                    ^5.0.1   →   ^5.4.0</span><br><span class="line">  hexo-deployer-git       ^2.1.0   →   ^3.0.0</span><br><span class="line">  hexo-generator-search   ^2.4.0   →   ^2.4.3</span><br><span class="line">  hexo-renderer-pug       ^1.0.0   →   ^2.0.0</span><br><span class="line">  hexo-renderer-stylus    ^1.1.0   →   ^2.0.1</span><br><span class="line"></span><br><span class="line">? Update <span class="string">&quot;hexo&quot;</span> <span class="keyword">in</span> package.json from ^5.0.1 to ^5.4.0? Yes</span><br><span class="line"></span><br><span class="line">? Update <span class="string">&quot;hexo-deployer-git&quot;</span> <span class="keyword">in</span> package.json from ^2.1.0 to ^3.0.0? Yes</span><br><span class="line"></span><br><span class="line">? Update <span class="string">&quot;hexo-generator-search&quot;</span> <span class="keyword">in</span> package.json from ^2.4.0 to ^2.4.3? Yes</span><br><span class="line"></span><br><span class="line">? Update <span class="string">&quot;hexo-renderer-pug&quot;</span> <span class="keyword">in</span> package.json from ^1.0.0 to ^2.0.0? Yes</span><br><span class="line"></span><br><span class="line">? Update <span class="string">&quot;hexo-renderer-stylus&quot;</span> <span class="keyword">in</span> package.json from ^1.1.0 to ^2.0.1? Yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">These packages will be updated:</span><br><span class="line"></span><br><span class="line">  hexo                    ^5.0.1   →   ^5.4.0</span><br><span class="line">  hexo-deployer-git       ^2.1.0   →   ^3.0.0</span><br><span class="line">  hexo-generator-search   ^2.4.0   →   ^2.4.3</span><br><span class="line">  hexo-renderer-pug       ^1.0.0   →   ^2.0.0</span><br><span class="line">  hexo-renderer-stylus    ^1.1.0   →   ^2.0.1</span><br><span class="line"></span><br><span class="line">? Update package.json? Yes</span><br></pre></td></tr></table></figure><p>此时再运行<code>npm install --save</code>按照<code>package.json</code>文件内容进行更新。</p><p>查看Hexo版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hexo: 5.4.0</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Darwin 20.5.0 darwin x64</span><br><span class="line">node: 12.22.1</span><br><span class="line">v8: 7.8.279.23-node.46</span><br><span class="line">uv: 1.40.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.16.1</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 2.1.3</span><br><span class="line">http_parser: 2.9.4</span><br><span class="line">openssl: 1.1.1k</span><br><span class="line">cldr: 39.0</span><br><span class="line">icu: 69.1</span><br><span class="line">tz: 2021a</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure><p>完结，撒花！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LOJ#10202. 「一本通 6.2 练习 5」樱花</title>
      <link href="/archives/1693663400/"/>
      <url>/archives/1693663400/</url>
      
        <content type="html"><![CDATA[<h2 id="题意简述">题意简述</h2><p>求不定方程：</p><p><span class="math display">\[\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\]</span></p><p>的正整数解 <span class="math inline">\((x, y)\)</span> 的数目。</p><h2 id="题目分析">题目分析</h2><h3 id="数学推导">数学推导</h3><p>这道题给人的第一印象是难以解决，因为<span class="math inline">\(n!\)</span>是一个很大的数，不可能一一枚举答案。所以我们必须对题目中给出的式子进行处理。</p><p><span class="math display">\[\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}\]</span> <span class="math display">\[\frac{x + y}{xy} = \frac{1}{n!}\]</span> <span class="math display">\[n!(x + y) = xy\]</span></p><p>可得 <span class="math inline">\(x \geq n!, y \geq n!\)</span>，代入<span class="math inline">\(x = n! + a, y = n! + b\)</span>得</p><p><span class="math display">\[n!(n! + a + n! + b) = (n! + a)(n! + b)\]</span> <span class="math display">\[n!(2(n!) + a + b) = (n!)^2 + n!(a + b) + ab\]</span> <span class="math display">\[2(n!)^2 + n!(a + b) = (n!)^2 + n!(a + b) + ab\]</span> <span class="math display">\[(n!)^2 = ab\]</span></p><p>因为每一组不同的<span class="math inline">\((a, b)\)</span>都对应一组正整数解<span class="math inline">\((x, y)\)</span>，所以本体的答案就是<span class="math inline">\((n!)^2的因子个数。\)</span></p><h3 id="朴素算法40分">朴素算法（40分）</h3><p>先筛出从 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(N\)</span> 之间每一个质数，在依次枚举<span class="math inline">\(n!\)</span>的质因数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; p[j] &lt;= i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> k = i;</span><br><span class="line">            <span class="keyword">while</span>(k % p[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                s[j]++;</span><br><span class="line">                k /= p[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    ans = (<span class="type">long</span> <span class="type">long</span>)ans * (s[i] * <span class="number">2</span> + <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正解">正解</h3><p>事实上，<span class="math inline">\(n!\)</span>的质因数的个数可以直接计算出来，不需要一个一个枚举。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j = p[i]; j &lt;= n; j *= p[i]) &#123;</span><br><span class="line">        s[i] = (s[i] + n / j) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    ans = (<span class="type">long</span> <span class="type">long</span>)ans * (s[i] * <span class="number">2</span> + <span class="number">1</span>) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码实现">代码实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b[MAXN];</span><br><span class="line"><span class="type">int</span> p[MAXN], s[MAXN];</span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!b[i]) &#123;</span><br><span class="line">            p[++m] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i * <span class="number">2</span>; j &lt; MAXN; j += i) &#123;</span><br><span class="line">                b[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> j = p[i]; j &lt;= n; j *= p[i]) &#123;</span><br><span class="line">            s[i] = (s[i] + n / j) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        ans = (<span class="type">long</span> <span class="type">long</span>)ans * (s[i] * <span class="number">2</span> + <span class="number">1</span>) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 质数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整除分块学习笔记</title>
      <link href="/archives/1697030016/"/>
      <url>/archives/1697030016/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识">前置知识</h2><ul><li><del>莫比乌斯反演</del></li></ul><p><del>上面的标题应该改为后置知识</del></p><h2 id="前言">前言</h2><p>最近在嗑莫比乌斯函数时嗑到了这个知识点，本质上是一个经常与莫比乌斯反演一起出现的小技巧，包括在很多莫比乌斯反演的题目中。</p><h2 id="算法过程">算法过程</h2><p>整除分块通常被用来处理类似下方的式子：</p><p><span class="math display">\[\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor\]</span></p><h3 id="暴力">暴力</h3><p>首先我们可以暴力解决：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">ans += n / i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[N \leq 10^9\]</span></p><p>然后就歇菜了</p><h3 id="规律">规律</h3><p>我们可以通过打表的方式来寻找<span class="math inline">\(\sum_{i=1}^n \lfloor \frac{n}{i} \rfloor\)</span>的规律</p><p>当<span class="math inline">\(n=5,sum=5+2+1+1+1\)</span></p><p>当<span class="math inline">\(n=9,sum=9+4+3+2+1+1+1+1+1\)</span></p><p>当<span class="math inline">\(n=12,sum=12+6+4+3+2+2+1+1+1\)</span></p><p>可以看到有很多数是重复的，当<span class="math inline">\(n\)</span>更大时，重复的数会更多。可以证明，这些数的数量是<span class="math inline">\(O(\sqrt{n})\)</span>的。换句话说，我们可以将每一段连续且相同的数分开计算，实现<span class="math inline">\(O(\sqrt{n})\)</span>的时间复杂度。</p><h3 id="实现">实现</h3><p>可以证明，对于一段相同且连续的数，若其左端点为<span class="math inline">\(l\)</span>，则右端点为<span class="math inline">\(\lfloor \frac{n}{\lfloor \frac{n}{l} \rfloor} \rfloor\)</span></p><p>即这一段<span class="math inline">\(r-l+1\)</span>个数都为<span class="math inline">\(\lfloor \frac{n}{l} \rfloor\)</span>，<span class="math inline">\(l\)</span>到<span class="math inline">\(r\)</span>的总和为<span class="math inline">\(\lfloor \frac{n}{l} \rfloor * (r - l + 1)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ans += (n / l) * (r - l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用">应用</h2><h3 id="cqoi2007余数求和">「CQOI2007」余数求和</h3><p>这道题的关键是求<span class="math inline">\(\sum_{i=1}^n i * \lfloor \frac{n}{i} \rfloor\)</span></p><p>在此题中，<span class="math inline">\(l\)</span>到<span class="math inline">\(r\)</span>的总和为<span class="math inline">\(\sum_{i=l}^{r} i * \lfloor \frac{n}{l} \rfloor = \lfloor \frac{n}{l} \rfloor \sum_{i=l}^{r} i = \lfloor \frac{n}{l} \rfloor * \frac{(l + r)(r - l + 1)}{2}\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ans += (n / l) * (l + r) * (r - l + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="莫比乌斯反演">莫比乌斯反演</h3><p>在莫比乌斯反演中，我们经常需要求<span class="math inline">\(\sum_{i=1}^n \mu(i) * \lfloor \frac{n}{i} \rfloor\)</span></p><p>在同一段内的和为<span class="math inline">\(\sum_{i=l}^{r} \mu(i) * \lfloor \frac{n}{l} \rfloor = \lfloor \frac{n}{l} \rfloor \sum_{i=l}^{r} \mu(i) = \lfloor \frac{n}{l} \rfloor (\sum_{i=1}^{r} \mu(i) - \sum_{i=1}^{l-1} \mu(i))\)</span></p><p>使用线性筛可以在<span class="math inline">\(O(n)\)</span>的时间内预处理所有的<span class="math inline">\(\sum_{i=1}^{k} \mu(i)\)</span>，整除分块复杂度为<span class="math inline">\(O(\sqrt{n})\)</span>，总复杂度<span class="math inline">\(O(n)\)</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= n; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">    r = n / (n / l);</span><br><span class="line">    ans += (n / l) * (sum[r] - sum[l - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 整除分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「SCOI2009」windy 数</title>
      <link href="/archives/1092015460/"/>
      <url>/archives/1092015460/</url>
      
        <content type="html"><![CDATA[<h2 id="题意简述">题意简述</h2><p>不含前导零且相邻两个数字之差至少为 <span class="math inline">\(2\)</span> 的正整数被称为 windy 数。windy 想知道，在 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> 之间，包括 <span class="math inline">\(a\)</span> 和 <span class="math inline">\(b\)</span> ，总共有多少个 windy 数？</p><h2 id="题目分析">题目分析</h2><p>数位DP模板题</p><p>定义状态 <span class="math inline">\(dp_{i, j}\)</span> 为长度为 <span class="math inline">\(i\)</span> 的windy数中，最高位为 <span class="math inline">\(j\)</span> 的数的数目。</p><p>状态转移方程也很容易得到，可以直接从前一位转移过来：</p><p><span class="math display">\[dp_{i, j} = \sum dp_{i - 1, k} (|j - k| \geq 2)\]</span></p><p>主要的难点是在计算 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(n\)</span> 之间的 windy 数，这可以分为几个步骤处理。</p><p>第一步，求出所有长度小于等于 <span class="math inline">\(len - 1\)</span> （<span class="math inline">\(len\)</span> 为 <span class="math inline">\(n\)</span> 的长度）的，以 <span class="math inline">\(1\)</span> ~ <span class="math inline">\(9\)</span> 为最高位的 windy 数的总数。</p><p>第二步，求出所有长度为 <span class="math inline">\(len\)</span>，最高位小于 <span class="math inline">\(n\)</span> 的最高位的 windy 数的总数。</p><p>第三步，求出所有长度为 <span class="math inline">\(len\)</span>，最高位等于 <span class="math inline">\(n\)</span> 的最高位的 windy 数的总数。这一步是最难想的，需要从第二位开始，依次枚举每一位，并累加所有以与上一位的差小于 <span class="math inline">\(2\)</span> 的数为最高位的 windy 数的总数。（前几位之前已经补足。）</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">        a[++len] = n % <span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出所有长度小于等于 len - 1 的，以 1 ~ 9 为最高位的 windy 数的总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            ans += f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出所有长度为 len，最高位小于 n 的最高位的 windy 数的总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; a[len]; i++) &#123;</span><br><span class="line">        ans += f[len][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求出所有长度为 len，最高位等于 n 的最高位的 windy 数的总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//依次枚举每一位上的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; a[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(j - a[i + <span class="number">1</span>]) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//符合要求，累加</span></span><br><span class="line">                ans += f[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(a[i + <span class="number">1</span>] - a[i]) &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//已经不是 windy 数了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        f[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">9</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(k - j) &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    f[i][j] += f[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="built_in">solve</span>(r + <span class="number">1</span>) - <span class="built_in">solve</span>(l));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数位DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解「CF1200E」Compress Words</title>
      <link href="/archives/159643862/"/>
      <url>/archives/159643862/</url>
      
        <content type="html"><![CDATA[<h2 id="题意简述">题意简述</h2><ul><li><p>给定 <span class="math inline">\(n\)</span> 个单词，将这 <span class="math inline">\(n\)</span> 个单词从前往后拼接在一起，若相邻两个单词的后缀和前缀相同则将其重合在一起。</p></li><li><p>如输入 sample please ease in out，sample 与 please 拼接得 samplease，samplease 与 ease 拼接仍得 samplease，最终得 sampleaseinout</p></li></ul><h2 id="题目分析">题目分析</h2><p>题目的关键在于求出两个字符串之间的最长公共部分，即相等的前缀与后缀。这很容易让人联想到 KMP 的 <span class="math inline">\(next\)</span> 数组，它的定义是一个字符串的前缀的最长的相同的前缀与后缀的长度，<span class="math inline">\(next[len - 1]\)</span> 的定义就是这个字符串的最长的相同的前缀与后缀的长度。</p><p>因此，对于字符串 <span class="math inline">\(s1\)</span> 和 <span class="math inline">\(s2\)</span>，我们只需要将 <span class="math inline">\(s2\)</span> 拼接在 <span class="math inline">\(s1\)</span> 前面，例如将 sample 与 please 拼接为 pleasesample，再求出这个字符串的 <span class="math inline">\(next[len - 1]\)</span> 等于 <span class="math inline">\(2\)</span>，就可以简单地得到公共部分为 ple，再从 <span class="math inline">\(2\)</span> 开始截取 please 的后半部分 ease 拼接到 sample 后面即可。</p><p>对于 <span class="math inline">\(n\)</span> 个字符串，则应该按照上面的方法依次拼接。</p><p>P.S. 一个优化：因为两个字符串之间的最长公共部分的长度显然不可能大于其中任意一个字符串的长度，所以在一开始拼接时，只需要求出两个字符串中较短的的长度 <span class="math inline">\(l\)</span>，将第一个字符串的后 <span class="math inline">\(l\)</span> 个字符拼接到第二个字符串后面，再求 <span class="math inline">\(next[len - 1]\)</span> 的值。</p><p>同时，为了防止求next时将另一个字符串也算进来，导致“共同部分”跨过两个字符串之间，要在中间插入一段数据中几乎不可能出现的字符串。因为如果某个真子串在字符串中只出现一次，最长的相同前后缀就不可能包括这个字串，也就杜绝了求出的长度越过两个字符之间的可能性。</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span> + <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> nxt[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getNext</span><span class="params">(string s2)</span> </span>&#123;</span><br><span class="line">nxt[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> len2 = s2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(i &lt; len2) &#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">-1</span> || s2[i] == s2[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j++;</span><br><span class="line">nxt[i] = j;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">j = nxt[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string s, ans;</span><br><span class="line"><span class="type">int</span> n, len;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">ans = s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">len = <span class="built_in">min</span>(ans.<span class="built_in">size</span>(), s.<span class="built_in">size</span>()); <span class="comment">//显然，共同部分的长度不会超过两个字符串中的任何一个</span></span><br><span class="line">        <span class="comment">//为了防止求next时将另一个字符串也算进来，导致“共同部分”跨过两个字符串之间，要在中间插入一段数据中几乎不可能出现的字符串</span></span><br><span class="line">string tmp = s + <span class="string">&quot;Idealistoj neniam maljuniĝas.&quot;</span> + ans.<span class="built_in">substr</span>(ans.<span class="built_in">size</span>() - len);</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">getNext</span>(tmp); <span class="comment">//求出相同的最长前缀和后缀，即两个字符串的公共部分的长度</span></span><br><span class="line">ans += s.<span class="built_in">substr</span>(res); <span class="comment">//0 ~ res-1 的部分都是与s的公共部分，只要将res之后的部分接到ans后面既可以了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 题解 </tag>
            
            <tag> KMP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解「CF161D」Distance in Tree</title>
      <link href="/archives/1350111558/"/>
      <url>/archives/1350111558/</url>
      
        <content type="html"><![CDATA[<h2 id="题意简述">题意简述</h2><p>给定一颗<span class="math inline">\(N\)</span>个节点的树，求树上长度为<span class="math inline">\(K\)</span>的路径的数量</p><h3 id="输入">输入</h3><p>第一行两个数字<span class="math inline">\(N\)</span>，<span class="math inline">\(K\)</span>，如题意</p><p>接下来的<span class="math inline">\(N−1\)</span>行中，每行两个整数<span class="math inline">\(u,v\)</span>表示一条树边<span class="math inline">\((u,v)\)</span></p><h3 id="输出">输出</h3><p>一个整数<span class="math inline">\(ans\)</span>，如题意</p><h3 id="数据范围">数据范围</h3><p><span class="math inline">\(1 \leq N \leq 50000\)</span></p><p><span class="math inline">\(1 \leq K \leq 500\)</span></p><h2 id="题目分析">题目分析</h2><p>虽然此题可以看出是个点分治模板，但由于<span class="math inline">\(K\)</span>的范围较小（小于等于<span class="math inline">\(500\)</span>），所以树形DP也可以解决这道题</p><p>定义状态<span class="math inline">\(f_{u,i}\)</span>为从<span class="math inline">\(u\)</span>开始的路径中长度为<span class="math inline">\(i\)</span>的路径的数量，可以很容易得出状态转移方程</p><p><span class="math display">\[f_{u, i} = \sum_{v \in son_u} f_{v, i - 1}\]</span></p><p>回到题目本身，题目中要求我们找出所有长度为<span class="math inline">\(K\)</span>的路径</p><p>以<span class="math inline">\(u\)</span>为根节点考虑，可以将所有的路径分为两种：经过点<span class="math inline">\(u\)</span>的和不经过点<span class="math inline">\(u\)</span>的</p><p>对于后者，可以直接递归处理；对于前者，我们可以以点<span class="math inline">\(u\)</span>将其分为两条路径，两条路径的长度和为<span class="math inline">\(K\)</span>。所以，根据乘法原理，我们只需累加<code>f[v][i] * f[u][k - i - 1]</code>即可。</p><p>另外，累加答案必须在更新<span class="math inline">\(f_{u, i}\)</span>之前，因为在更新之前，<span class="math inline">\(f_{u, i}\)</span>是从点<span class="math inline">\(u\)</span>开始，不经过点<span class="math inline">\(v\)</span>的长度为<span class="math inline">\(i\)</span>的路径数量，乘以<span class="math inline">\(f_{u, K - i - 1}\)</span>就可以得到经过<span class="math inline">\(u, v\)</span>的长度为<span class="math inline">\(K\)</span>的路径数量。但如果先更新<span class="math inline">\(f_{u, i}\)</span>，则<span class="math inline">\(f_{u, i}\)</span>是从点<span class="math inline">\(u\)</span>开始，经过点<span class="math inline">\(v\)</span>和其他子节点的长度为<span class="math inline">\(i\)</span>的路径数量，会出现重复：即一条路径从<span class="math inline">\(v\)</span>走到<span class="math inline">\(u\)</span>，又走回<span class="math inline">\(v\)</span>的“重复”现象</p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">500</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; G[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXK];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> par)</span> </span>&#123;</span><br><span class="line">f[u][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="type">int</span> v = G[u][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(v == par) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dp</span>(v, u);</span><br><span class="line">        <span class="comment">//这两重循环的顺序不能反，因为如果ans累加前就更新了f[u][i]，累加时就会出现重复，即两条路径的边重合</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">ans += (<span class="type">long</span> <span class="type">long</span>)f[v][i] * f[u][k - i - <span class="number">1</span>]; <span class="comment">//乘法原理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">f[u][i + <span class="number">1</span>] += f[v][i]; <span class="comment">//更新f[u][i]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">G[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">G[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 树 </tag>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【TJOI2013】单词-题解</title>
      <link href="/archives/1361164098/"/>
      <url>/archives/1361164098/</url>
      
        <content type="html"><![CDATA[<h2 id="题意简述">题意简述</h2><p>给出<span class="math inline">\(n\)</span>个单词，统计每个单词在全体单词（包括自身）中的出现次数</p><h2 id="题目分析">题目分析</h2><p>对多个模式串进行匹配，求每个模式串的出现次数，显然是AC自动机模版题</p><p>本题与<a href="https://www.luogu.com.cn/problem/P3796">模版</a>的区别在于，本题中单词可能会有重复，因此要用一个<span class="math inline">\(cnt\)</span>数组记录<span class="math inline">\(Trie\)</span>树上每个节点被覆盖了几次，再用一个<span class="math inline">\(vis\)</span>数组记录当前节点是否已经被累加过了</p><p>如果当前节点<span class="math inline">\(i\)</span>还没有被累加过（<span class="math inline">\(vis_i = false\)</span>），就将它往上能跳到的节点都加上<span class="math inline">\(cnt_i\)</span>，扫完后再将<span class="math inline">\(vis_i\)</span>变为<span class="math inline">\(true\)</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">string s[MAXM];</span><br><span class="line"><span class="type">bool</span> vis[MAXN];</span><br><span class="line"><span class="type">int</span> t[MAXN][<span class="number">26</span>], sum[MAXN], cnt[MAXN], ed[MAXN], ans[MAXN];</span><br><span class="line"><span class="type">int</span> fail[MAXN];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[p][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            t[p][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">        &#125;</span><br><span class="line">        p = t[p][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        cnt[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t[<span class="number">0</span>][i]) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(t[<span class="number">0</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(t[u][i]) &#123;</span><br><span class="line">                fail[t[u][i]] = t[fail[u]][i];</span><br><span class="line">                q.<span class="built_in">push</span>(t[u][i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                t[u][i] = t[fail[u]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">query</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        p = t[p][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = p; j != <span class="number">0</span> &amp;&amp; !vis[p]; j = fail[j]) &#123;</span><br><span class="line">            ans[j] += cnt[p];</span><br><span class="line">        &#125;</span><br><span class="line">        vis[p] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        ed[i] = <span class="built_in">insert</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">getFail</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">query</span>(s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; ans[ed[i]] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> AC自动机 </tag>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC自动机学习笔记</title>
      <link href="/archives/915640971/"/>
      <url>/archives/915640971/</url>
      
        <content type="html"><![CDATA[<p><del>再不更新这里都长草了</del></p><h2 id="前置知识">前置知识</h2><ul><li>KMP</li><li>Trie树</li></ul><h2 id="前言">前言</h2><p>AC自动机是一个字符串匹配算法，与KMP的区别在于，AC自动机可以用<span class="math inline">\(O(\sum |s_i| + |S|)\)</span>的复杂度在文本串中同时查找多个模式串，例如<a href="https://www.luogu.com.cn/problem/P3808">这道题</a></p><p>对于初学者 <del>就是我</del> 而言，可以简单地将AC自动机理解为KMP + Trie树，整个算法分为三步：</p><ol type="1"><li>将所有的模式串建成一颗Trie树</li><li>求出Trie树上每一个节点的失配指针（fail）（类似KMP的next）</li><li>将文本串在Trie树上进行匹配</li></ol><h2 id="算法过程">算法过程</h2><h3 id="建立trie">建立Trie</h3><p>这一步和普通的字典树一样，不解释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(t[p][s[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">t[p][s[i] - <span class="string">&#x27;a&#x27;</span>] = ++tot;</span><br><span class="line">&#125;</span><br><span class="line">p = t[p][s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line">num[p]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求失配指针">求失配指针</h3><p><span class="math inline">\(fail_u\)</span>的定义为，Tire树内所有字符串的所有前缀中，后缀匹配长度最大的的位置；如下图中，<span class="math inline">\(fail_i = j\)</span></p><p>（图中不同颜色的边代表字符）</p><p align="center"><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/AC_fail1.jpg" alt="fail指针" width='50%' height='50%'/></p><p>如图，节点<span class="math inline">\(i\)</span>与节点<span class="math inline">\(j\)</span>的后缀匹配最长，所以<span class="math inline">\(fail_i = j\)</span></p><p align="center"><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/AC_fail2.jpg" alt="fail指针" width='50%' height='50%'/></p><p>如图，<span class="math inline">\(fail_i = j\)</span>，则<span class="math inline">\(i\)</span>的粉色子节点（此处用颜色表示字符）必然也与<span class="math inline">\(j\)</span>的粉色子节点有最长的后缀，因此该子节点的<span class="math inline">\(fail\)</span>指针就是<span class="math inline">\(k\)</span></p><p>具体求法：对于<span class="math inline">\(u\)</span>的子节点<span class="math inline">\(v\)</span>，其<span class="math inline">\(fail\)</span>指针为<span class="math inline">\(u\)</span>的<span class="math inline">\(fail\)</span>指针的字符与<span class="math inline">\(v\)</span>相同的子节点，证明很简单，因为<span class="math inline">\(fail_u\)</span>与<span class="math inline">\(u\)</span>的后缀匹配最长，而<span class="math inline">\(v\)</span>节点上的字符<span class="math inline">\(i\)</span>显然与<span class="math inline">\(trie[fail_u][i]\)</span>上的字符<span class="math inline">\(i\)</span>相同，所以<span class="math inline">\(fail_v = trie[fail_u][i]\)</span></p><p>理解原理后我们很容易就能求出所有的<span class="math inline">\(fail\)</span>指针：在字典树上跑一遍BFS，根节点的子节点的<span class="math inline">\(fail\)</span>指针显然为0，所以先将这些点放入队列；</p><p>对于每一个当前搜索到的节点<span class="math inline">\(u\)</span>，它的<span class="math inline">\(fail\)</span>指针肯定已经被求出，所以我们只需要枚举它的所有子节点<code>t[u][i]</code>，建立<span class="math inline">\(fail\)</span>指针 <code>fail[t[u][i]] = t[fail[u]][i]</code></p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFail</span><span class="params">()</span> </span>&#123; <span class="comment">//bfs构建fail数组</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123; <span class="comment">//根结点下面直接连的第一层结点，fail直接指向根结点0 </span></span><br><span class="line"><span class="keyword">if</span>(t[<span class="number">0</span>][i]) &#123;</span><br><span class="line">q.<span class="built_in">push</span>(t[<span class="number">0</span>][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123; <span class="comment">//队列中维护能够拓展fail值的结点 </span></span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(t[u][i]) &#123;</span><br><span class="line">                <span class="comment">//失配时，以trie[u][i]结尾的后缀尽量在trie中找一个与之相同的前缀（类似KMP）</span></span><br><span class="line">fail[t[u][i]] = t[fail[u]][i];</span><br><span class="line">q.<span class="built_in">push</span>(t[u][i]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//节点不存在，往上连，最多回到根结点0, 注意是trie不是fail数组</span></span><br><span class="line">t[u][i] = t[fail[u]][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串匹配">字符串匹配</h3><p>这一部分理解难度不大，看代码注释即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">0</span>, res = <span class="number">0</span>; <span class="comment">//p表示trie中的结点，res表示总和</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">p = t[p][s[i] - <span class="string">&#x27;a&#x27;</span>]; <span class="comment">//获取当前节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = p; j != <span class="number">0</span> &amp;&amp; num[j] != <span class="number">-1</span>; j = fail[j]) &#123; <span class="comment">//从p开始一直往上跳</span></span><br><span class="line">res += num[j]; <span class="comment">//num[j]表示以当前位置结尾字符串的总数，它们肯定都是</span></span><br><span class="line">num[j] = <span class="number">-1</span>; <span class="comment">//避免重复计算</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<span class="math inline">\(p\)</span>表示将字符串在<span class="math inline">\(Trie\)</span>树上匹配时的位置，在每一轮循环中以<span class="math inline">\(p\)</span>为起点向上跳，寻找匹配即可</p><h2 id="复杂度分析">复杂度分析</h2><p>Trie树的大小为<span class="math inline">\(\sum |s_i|\)</span>，建立<span class="math inline">\(fail\)</span>指针的复杂度与其相同，遍历文本串需要<span class="math inline">\(O(|S|)\)</span>，总时间复杂度为<span class="math inline">\(O(\sum |s_i| + |S|)\)</span></p><h2 id="参考资料">参考资料</h2><p><a href="https://oi-wiki.org/string/ac-automaton/">AC 自动机 - OI Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【开新坑】《南极狂想曲》</title>
      <link href="/archives/2263194458/"/>
      <url>/archives/2263194458/</url>
      
        <content type="html"><![CDATA[<p><strong>郑重声明：本作品为奇幻小说，不涉及也不参与任何现实中的意识形态纠纷。对于作品中的任何魔怔设定，本人一概不负任何责任。</strong></p><h2 id="起源">起源</h2><p>这个系列来源于@<a href="https://www.luogu.com.cn/user/251723">Schwarzkopf_Henkal</a> 的脑洞：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bzf1dim1.png" /></p><p><del>然后我和SH就在犇犇里有一句没一句地语C</del></p><h2 id="简介">简介</h2><p>借助高度发达的魔法技术，人类征服了地球上最后一块丰饶的大陆——南极。然而，大量的资源从冰盖中被开采出来后，只是让原本就十分尖锐的社会矛盾雪上加霜。就在这时，一具被封冻在南极冰盖中70年的躯体引起了全世界的注意……</p><p>为了解决问题，从左翼到右翼的所有人都在用魔法实践自己的观点。随意识形态的激烈交锋而来的，是全世界范围的激烈战争，战火从南极，南美洲，北美洲，东亚，西伯利亚一直烧到欧洲。进步同盟与联合国的疆界每天都在反复进退，没人知道这一切何时才会结束……</p><h2 id="人物设定">人物设定</h2><h3 id="schwarzkopf-henkal">Schwarzkopf Henkal</h3><p>姓名：Schwarzkopf Henkal</p><p>昵称：Henkal</p><p>工作单位：南极国际科学考察团 -&gt; 南苏维埃共和国主席团</p><p>现居地点：阿蒙森-斯科特永久中立自治区 -&gt; 南极苏维埃共和国</p><p>政治立场：马克思列宁主义</p><p>爱好：甜点，意大利面，哲学，共产主义</p><p>“Henkal，你的考察报告怎么还没写完！”——Tomoko</p><p>经常在工作时摸鱼的大姐姐，在被问起「为什么要到南极来工作」时，队友们纷纷回答“是为了将自己的青春和生命献给这无尽的雪原，谱写人类探索未知的诗歌”，只有她回答“感觉在南极工作很有趣的样子。”</p><p>对待意识形态的问题特别严肃，不喜欢别人把政治当作升官发财的渠道；有时会看一些关于哲学的书，经常沉浸在关于世界观的各种讨论中。</p><p>以下是在南极海边散步时，Tomoko拍的一张照片：</p><figure><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/2bfibrwz.png" alt="在南极海边散步的Schwarzkopf Henkal" /><figcaption aria-hidden="true">在南极海边散步的Schwarzkopf Henkal</figcaption></figure><h3 id="nanami-tomoko">Nanami Tomoko</h3><p>姓名：Nanami Tomoko</p><p>昵称：智子</p><p>工作单位：南极国际科学考察团 -&gt; 南苏维埃共和国主席团</p><p>现居地点：阿蒙森-斯科特永久中立自治区 -&gt; 南极苏维埃共和国</p><p>政治立场：正统马克思主义</p><p>爱好：冰淇淋，计算机，历史书，共产主义</p><p>“Tomoko你到底打算什么时候还书！”——Henkal</p><p>在人前大大咧咧但是又不善言辞的小姐姐，有时候为了缓解气氛而开的玩笑经常时气氛更冷了。经常给自己身边的人“传教”但总是受到拒绝。在被问起「为什么要到南极来工作」时回答“啊，反正这份工作也不需要经常处理各种人情世故，再加上自己也很喜欢就来了。”</p><p>经常表现得特立独行，在使用计算机时经常叨念些莫名其妙的名词并解释「这样能更好的保护隐私」，坚持不用别人常用的社交软件，这使得Tomoko与朋友通讯时经常刚遇到麻烦。由于太过专注于技术，又是对于自己身边的问题浑然不觉。（Henkal借给Tomoko的《路易·波拿巴的雾月十八日》已经两个月了，如果不是Henkal偶然到Tomoko房间来，可能再过两个月也还不回去。）</p><p>比较关注历史和平权主义，能够和不同思想的人乃至自由主义者（？）讨论，但绝对不能容忍别人贬低或侮辱自己热爱的事物。但不管你持有什么观点，和她讨论历史的话她都会很欢迎的。</p><p>以下为Tomoko在逛街时摆拍的一张照片</p><figure><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/51nsimeu.png" alt="拿着照相机逛街的Tomoko" /><figcaption aria-hidden="true">拿着照相机逛街的Tomoko</figcaption></figure><h3 id="charleyxiao">Charleyxiao</h3><p>姓名：<a href="https://www.luogu.com.cn/user/223392">Charleyxiao</a></p><p>昵称：白鹅（实际上它是一只企鹅）</p><p>工作单位：南极苏维埃共和国武装力量</p><p>现居地点：阿蒙森-斯科特永久中立自治区 -&gt; 南极苏维埃共和国</p><p>政治立场：托洛茨基主义</p><p>爱好：发明讽刺的意识形态以讽刺其他意识形态（？）</p><p>“政委，人类破坏分子在冰盖下面安了水雷，刚刚巡逻的时候有几个水兵发现了！”</p><p>“什么？！让我去看看！”</p><p>在南极苏维埃需要援助时，白鹅总是走在最前线。白鹅是托洛茨基企鹅大军的一个小政委，负责给企鹅作思想工作，拨乱反正。对于企鹅军内的修正主义，以及对任何人的个人崇拜，它都十分厌恶。</p><p>白鹅最开始其实是一个无政府主义者，这可能与它曾经被禁锢在阿根廷的动物园里的经历有一定联系。但是核电站事故之后，它了解到了托洛茨基主义，并对这种有组织的反权威的思想有了浓厚的兴趣。因此它加入了托洛茨基的企鹅大军军队。在南苏维埃共和国主席团上，白鹅认识了Schwarzkopf Henkal和Nanami Tomoko，虽然他们都是人类，但是白鹅还是经常和他们一起讨论政治。一般来说，如果不惹怒白鹅的话，它能和任何意识形态的人有好的交谈，甚至是超革命主义者也是一样。</p><p>白鹅发明了一些魔怔的意识形态，比如新环形主义、双环形调和主义、星际不断革命论。军队里学历最高的企鹅也无法理解这些东西，但是白鹅还是乐在其中。当白鹅自称中心主义者的时候，你知道它实际上是在讽刺中心主义，它称这是通过对现实的讽刺发现自己是在讽刺这种讽刺，以让他人知道这是在讽刺所谓讽刺的讽刺，简而言之，就是魔怔。</p><p>白鹅不喜欢拍照，它在自己的魔怔理论中提到拍照的本质是一种人类中心主义的体现，所以这里只找到它参军时在某个旗帜下拍的照片：</p><figure><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/doaqkdn4.png" alt="旗帜下的白鹅" /><figcaption aria-hidden="true">旗帜下的白鹅</figcaption></figure><h3 id="布列斯特奥克佳布里斯卡娅">布列斯特·奥克佳布里斯卡娅</h3><p>姓名：<a href="https://space.bilibili.com/351214065">布列斯特·奥克佳布里斯卡娅</a></p><p>昵称：布列斯特（Brest）</p><p>工作单位：苏维埃社会主义共和国联盟武装力量 -&gt; 新苏维埃社会主义共和国联盟武装力量</p><p>现居地点：斯摩棱斯克 -&gt; 斯大林格勒</p><p>政治立场：斯大林主义（？）</p><p>爱好：吹奏小号，讨论政治电视剧，复兴苏联（？）</p><p>"我没有任何地位，但我必须成为一切！"</p><p>奥克佳布里斯卡娅并非斯拉夫人的传统姓氏，这个词汇在俄语中是“十月”的意思。在十月革命后，许多俄国人纷纷将自己的姓氏改为“奥克佳布里”。（如果是女性，翻译成中文时要翻译成“奥克佳布里斯卡娅”）</p><p>布列斯特在伟大的卫国战争时参军，并作为补充兵员奔赴斯大林格勒前线，然后就和其他战士一样殒命于枪林弹雨中。一名德军狙击手注意到了她时，几秒钟后，布列斯特的意识坠入一片黑暗。当她再度睁开双眼时，时间已经到了21世纪，联盟早已解体，而她，将于其他同样被斯大林的英灵召唤出的英灵（参见美狄亚和葛木宗一郎）一起，重建这个无产阶级的国度。作为英灵，即使是因为利用漏洞的大规模召唤而被大幅度削弱，布列斯特的力量仍然远超一般人。从新苏联建立开始，新西伯利亚战役，乌拉尔战役，第二次斯大林格勒战役等大大小小的战役，布列斯特基本上都参与过，在第二次斯大林格勒战役中更是引导了一辆魔法加持过的T-34/85击毁了一辆T-90。</p><p>专精于各种左翼理论，经常发表一些炮轰“资本主义阵营”的文章。努力维持自己严肃的形象，时不时会喊“我怎么可能会卖萌啊” <del>然后立即开始卖萌</del> ，每次都会被新苏联的其他战友拍照记录下来并作为留念。</p><p>以下就是某次被战友拍到的瞬间：</p><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/pm5pun13.png" /></p><h2 id="目录">目录</h2><h3 id="特别篇">特别篇</h3><p><a href="https://www.luogu.com.cn/blog/sophon/post-na-ji-kuang-xiang-qu-21-shi-ji-xin-xing-yi-shi-xing-tai">21世纪新兴意识形态</a></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 小说 </tag>
            
            <tag> 架空历史 </tag>
            
            <tag> 南极狂想曲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1977年欧洲局势（小说世界线）</title>
      <link href="/archives/494428169/"/>
      <url>/archives/494428169/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/imghost@latest/History_End_Europe_1977.jpg" /></p><p>图片加载可能要等一会……</p><p>图片很大有3.5M，大家耐心点</p><hr /><p>自1453年东罗马帝国灭亡后，君士坦丁堡，这座城中之城再度易手。</p><p>在走上未曾设想的道路后，充满宗教热忱的罗斯人高呼着“恢复东罗马帝国荣光！”的口号，如潮水般涌向了西亚，企图收复拜占庭时代的五大牧首区——罗马，君士坦丁堡，安条克，耶路撒冷，亚历山大港</p><p>战姬骑士团首先将矛头对准了土耳其。那些带有“上帝赐予的力量”，或者说是“玛丽亚在人间的代言者”的姑娘们，挥舞着十字剑和战锤冲过多瑙河，踏上了巴尔干半岛的东色雷斯地区。经过三个星期的“圣战”，被凯末尔改为博物馆的圣索菲亚大教堂重新成为一座东正教的教堂。假如不是宗教狂热让她们不敢破坏这座神圣的城市，君士坦丁堡战役的持续时间可能还会更短。</p><p>攻占君士坦丁堡后，罗斯人们作出了更让其他国际震惊与困惑的举动：进攻叙利亚。</p><p>她们没有理会仍然盘踞在安纳托利亚半岛东北部的土耳其残余势力，挥师南下，直取古城安条克（今称安塔基亚），随后又对叙利亚发起猛攻。</p><hr /><p>“也就是说……”穿着礼服的黑发少女眨了眨眼睛。</p><p>“那些疯子的行动根本就没有什么原因”，秘书耸了耸肩，“他们根本就不是出于什么政治或经济上的目的，纯粹就是对东正教的狂热，就像近千年前那些西欧的十字军一样，疯狂地向「圣城」发起猛攻，只不过罗斯人成功了。”</p><p>”所以她们又在筹划进攻哪里？“</p><p>”我想是安塔基亚，一座除了大理石什么都不产的城市。这是拜占庭帝国的牧首区之一。“</p><p>”你是说东罗马帝国吧？“</p><p>”就说拜占庭帝国，总统小姐。神圣罗马帝国的人就是这么叫的，当然那是因为那些日耳曼人想给自己弄个威严一点的称呼，但至少我们同样在嘲讽他们自封罗马的举动。事实上，如果非要说谁是罗马，前些日子在巴尔干半岛上大杀四方的意大利人还更有合法性，起码那些意大利人占据着罗马城。“</p><p>总统对此似乎不以为然：”拿破仑战争结束之后就再也没有哪个国家像意大利这样野蛮地吞并其他国家的领土了，意大利人不学着希腊人成立阿尔巴尼亚联邦，而是将其直接纳为自己的领土。在别的地方这么干也就罢了，在有火药桶之称的巴尔干地区这么干，我很佩服他们的勇气。更别提这帮家伙居然在南斯拉夫和阿尔巴尼亚地区陷入苦战，搞定的区域只有亚得里亚海沿岸。如果不是罗斯人在东线的进攻重创了南斯拉夫，这帮家伙十有八九会陷入二战时一样的境地。咳，还有那个难以理解的‘塞浦路斯分治’，我百思不得其解他们是出于什么原因和罗斯人商议把一个小岛拆成三块。“</p><p>“这已经不是我们有必要担忧的问题了，总统小姐。接下来我有两个消息，都是关于那些罗斯人的。”</p><p>“你是不是还想说，一个是好消息一个是坏消息？”</p><p>“从某种意义上来说，两个消息都是既不好也不坏。第一个消息是，CIA传来情报，那些罗斯人貌似是想占领耶路撒冷，不过只是装装样子而已，他们的领导人绝对没疯，不至于干蠢事。”</p><p>“这种由狂信徒统治的国家必然会有诸多问题，极度不理智的行为就是其一。例如费好大功夫，与好几个国家为敌，就为了攻打一个除了文化之外毫无意义的城市。”总统的语调中带着明显的嘲讽，“毕竟，连以色列和中东国家都没有在耶路撒冷发生激战。那么，另一个消息是什么？”</p><p>“额……”秘书犹豫了一下，“罗斯向我们提出了申请……”</p><p>“什么申请？”</p><p>“他们说，既然环太平洋联盟是维护世界和平的组织，罗斯共和国作为世界大国自然也有维护世界和平的义务，换句话说……罗斯共和国申请加入环太平洋联盟。”</p><hr /><p><strong>罗斯共和国方面的传单</strong></p><p>就在昨天，罗斯外交部向PRA（Pacific Rim Alliance，环太平洋联盟）提交了加入申请，但这一申请旋即遭到了回绝。</p><p>PRA是东亚战争结束后，以北大西洋公约为基础，美国主导组建的军事一体化联盟组织。建立时，PRA宣称其宗旨为“维护世界和平”，但PRA具体是怎么做的？看一下地图就能明白，PRA的成员国除了美国，韩国，日本，菲律宾，等太平洋沿岸国家外，还包括英国，法国，西班牙，葡萄牙，西德，冰岛，瑞典，挪威，芬兰，丹麦等大西洋沿岸国家，甚至包括意大利，希腊等地中海沿岸国家，这哪里是“环太平洋联盟”？倒不如说是“环罗斯联盟（RRA）”更贴切一点。</p><p>如果PRA真的如他们所声称的那样，是维护世界和平的组织，那么他们为何会拒绝罗斯的加入？这只说明一个问题，PRA根本就不是什么维护世界和平的组织，而是一个世界性的“反罗斯联盟”。这次事件让全世界都看请了PRA的丑恶嘴脸，更让我们明白，只有通过不断的战斗，罗斯民族才有未来！</p><p>为了罗斯民族的荣耀！</p><hr /><p><strong>《沙皇格勒是罗斯自古以来不可分割的一部分》</strong></p><p>罗斯至今为止已经有2700年源远流长的历史，从罗穆路斯建立罗马城开始，罗斯民族的血脉就在欧罗巴大地上流传。沙皇格勒[1]自从306年建立以来，就是罗斯民族的土地。早在罗马共和国时期，罗斯民族就生活在沙皇格勒，在后来的罗马帝国历史中，沙皇格勒都是罗斯民族最重要的城市之一。这证实了沙皇格勒是罗斯自古以来不可分割的一部分，也驳回了外国势力关于沙皇格勒归属的谬论。</p><p>直到1435年，沙皇格勒被突厥人攻占，从此，“城中之城”就一直沦落在异族手中，直到1977年罗斯军队收复沙皇格勒，“城中之城”才重新回归罗斯母亲的怀抱。</p><p>对于任何企图分裂罗斯领土的行为，罗斯都会对其进行最严厉的谴责，这是对罗斯民族尊严的挑衅。尤其是近日大批沙皇格勒的流氓无产者受到外国势力挑拨，公然打出要求突厥人统治沙皇格勒的口号。这些人要么是愚蠢到认为在突厥人的暴政下沙皇格勒的人会生活得更好，要么就是坏到向外国势力出卖了自己的祖国。</p><p>在上帝的指引下，罗斯民族将捍卫自己的所有合法权利。我们不畏惧任何战争，正如凯撒所说：</p><p>“我来，我见，我征服。（Veni, vidi, vici.）”</p><p>[1]：斯拉夫人将伊斯坦布尔（凯末尔推行世俗化之前称君士坦丁堡）称为沙皇格勒（Царьград）</p><hr /><p><strong>1977年局势</strong></p><p>东亚战争开始时，RPK集团并未停止动作，瓦莱里娅动用经济手段，将联盟解散后陷入混乱中的东欧各国的经济进行整合，成立了“东欧经济合作组织”，甚至创造出“多瑙河联合体”这个莫名其妙的政权。在欧洲的社会主义阵营中，几乎只有南斯拉夫一国没有收到这场超级风波的影响。一夜之间，整个东欧都被迫走上与罗斯共和国相同的道路。对于这场将整个社会主义阵营在短时间内瞬间击垮的事变，未来的历史学家们给予它如下称呼：「东欧剧变」</p><p>随后，罗斯人再度发起侵略战争，她们再度越过多瑙河，以剑与火的游行横扫南斯拉夫东部。南斯拉夫原本就因为东欧剧变而遭受严重损失，面对罗斯的入侵更加无力。最后，是罗斯的魔法少女们停下脚步竟然是这几个原因：</p><p>1.以瓦莱里娅为首的RPK集团认为只要建立以塞尔维亚为基础的傀儡政权就足够了，继续扩张只会带来不必要的麻烦和损失。</p><p>2.“科索沃抵抗军”的坚持反抗让罗斯人的损失不断增加。</p><p>3.意大利与希腊在巴尔干半岛的扩张。罗斯共和国还没有做好与PRA（环太平洋联盟）发生正面冲突的准备，不得不停止军事扩张。</p><p>但这决不意味着铁托和他的南斯拉夫的噩梦停止了。相反，意大利军队向东开进，先后占领了斯洛文尼亚，克罗地亚，波斯尼亚和黑塞哥维那乃至塞尔维亚的部分疆域，直接与罗斯的傀儡塞尔维亚政权接壤，剑锋直指萨拉热窝。但同样为了避免与罗斯的冲突，意大利军队又向南进发，占领了黑山和阿尔巴尼亚的部分领土并将南斯拉夫和阿尔巴尼亚变成内陆国，统治整个亚得里亚海。阿尔巴尼亚，这个自称为“世界上第一个无神论国家”和“世界上唯一的社会主义国家”的国度，最终还是在与帝国主义的斗争中彻底落败。</p><p>与此同时，希腊也在尝试进行着扩张。与意大利不同，他们只是谨慎地占领了阿尔巴尼亚的西南部，并扶植了“阿尔巴尼亚联邦”这一傀儡政权。</p><p>随后，1977年最滑稽的一场闹剧开始了。事情的缘由只是希腊右翼在塞浦路斯共和国发动政变，早就就凯觎此地的罗斯立即以协调为由出兵，意大利也因此卷入。由于环太平洋联盟的特殊性（对任意成员国宣战等于对全体成员国宣战），罗斯共和国一直没有以官方身份宣布军事干涉塞浦路斯事件。在经过一场混乱的冲突后，联合国才慢吞吞地宣布介入此事并组织和谈。最终结果是，希腊占有塞浦路斯岛西南部，意大利占有塞浦路斯岛东南部，“北塞浦路斯共和国”（一建国就加入了东欧经济合作组织）占有塞浦路斯岛的北部。</p><p>中东方向，罗斯人占领叙利亚后停止了扩张。直接与全体阿拉伯国家敌对的代价不是在东亚陷入战争泥潭的罗斯能承受的，这一点罗斯的决策层看的很清楚。而且占领君士坦丁堡也只是“复兴罗斯民族”计划的一环而已，列昂尼德和瓦莱里娅不是P社玩家，“东罗马帝国”只是临时般过来作为法理依据而已，除了在论证时没人会把它当回事。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 小说 </tag>
            
            <tag> 架空历史 </tag>
            
            <tag> 历史终结之日 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【架空历史】【短篇】伏尔加格勒的夜色</title>
      <link href="/archives/189028723/"/>
      <url>/archives/189028723/</url>
      
        <content type="html"><![CDATA[<p>1971年7月，伏尔加格勒</p><p>夜深了。</p><p>伏尔加格勒的月光从未如此清冷，仿佛坟墓中散发出的荧光，喃喃着不知是谁的坟墓主人的姓名。星星死气沉沉地排列在月亮周围，如同穿着黑衣一言不发的随从。假若一个虔诚的基督教徒同时看到天上与地上的情景，一定会想起《圣经》中关于审判日的描写，月亮与星星是于天中排列的天使，将要审判世间的一切罪恶。</p><p>街道上传来人们的尖叫与呐喊，时不时还闪烁着几点火光。有人在奔跑，有人在哭号，有人在喊叫试图维持秩序，也有人带着颤抖的声音怒吼着，但随即嘎然而止。</p><p>但最后，都被轰鸣的机械碰撞声所取代。</p><p>——这就是年仅六岁的欧若拉对那天晚上的全部记忆。</p><p>外面嘈杂的声音持续了很长时间，欧若拉好奇地忍不住爬到窗台上去看，但立马就被父亲拽了下来，严厉地小声了呵斥一句，但父亲的神色立即又被一种被压抑着的悲哀所取代。在困惑与茫然中，欧若拉懵懵懂懂地被父亲哄到卧室里。</p><p>“你就呆在这里，赶快睡觉，不管听到什么都不要喊叫。外面有人撞车了，很快就会没事的。”</p><p>父亲用严肃的语气向她解释。年幼的欧若拉并没有意识到，父亲额头上渗出的汗珠已经出卖了他此刻的心情，对她而言，父亲是撑起天空的支柱一样的存在，是绝对正确、任何问题都能解决的的。</p><p>就在欧若拉期盼的目光中，父亲一言不发地走出了房间，然后轻轻地关上了房门。</p><p>一转身，安德烈的脸上立刻阴云密布。他努力调整着自己的呼吸，犹豫了一下，将手伸向电话，随手拨了一个早已烂熟于心的电话号码。糟糕！他慌乱地想道。但此时他已经没有回头路了，在十秒钟前还可以立即销毁全部记录，假装自己与动乱毫无关系，但现在这种机会已经离他而去了。他甚至不能挂断电话——这会立即引起怀疑。因为动乱而焦头烂额的罗斯共和国虽然不能二十四小时监控全部官僚系统的电话，但一名从主教的家中发出如此奇怪的通讯必然会得到“重点关照”。相反，就这样拨通的电话会因为属于“普通工作交流”而不进行备份。</p><p>按下按钮，他心中又涌起一阵恐慌。尽管安德烈竭力安慰自己“再也不会有比这更差的结果了”，双手却不住地颤抖着，仿佛在嘲笑他的愚蠢与不自量力。电话几秒钟后就接通了——显然对方也正绷紧着神经，这一点从对方同样不怎么冷静的音调就能听出来。</p><p>“安德烈？你那边还好吧？”</p><p>“不好，空降兵已经开始行动了，但我现在所在的街区属于政府用地，目前还没有受到波及，不过过不了多久肯定会被调查的。怎么，你们那边的行动没有成功吗？”</p><p>电话的另一边似乎苦笑了一下，干涩地说：</p><p>“你现在只要看看周围就应该知道了，亚历山大提出的倡议被否决了，现在对直接镇压提出反对的人都自身难保。老人们似乎还在争论，但我觉得他们最终还是会支持这场运动的，问题是民众不这么认为……他们根本就不明白自己的处境到底是谁造成的。”</p><p>“永远不要觉得民众愚昧，他们有自己的立场。”安德烈的声音重新变得冷静，更像一位战士。</p><p>“啧啧……总而言之，你那边可能还没出现，但现在民众已经开始用抢来的武器对抗军队，而委员会则批准军队用实弹镇压……事态已经升级为内战了，对于参与群众的称呼也改成了‘叛军’……我们全都被摆了一道。”</p><p>“什么！”啪地一声响，终于失去所有希望的安德烈瘫倒在沙发上，但他的手里却仍然死死攥着电话，仿佛可以给他带来一线生机，“上层的动向呢？老人们怎么说的？复兴派都支持镇压吗？”</p><p>“同志……我知道的都跟你说了，现在高层还没来得及表态，但他们无疑都不会容忍在伏尔加格勒发生内战……而孤立无援的群众们，最好的下场也不过是像巴黎公社一样，将死神的降临推迟几个星期……我们也该寻求自保了，再见。”</p><p>似乎是察觉到对方的心理，又补充了一句：</p><p>“有新动向我会随时通知你，同志。”</p><p>不用了。这是安德烈此时的唯一想法，他僵硬地转动着收音机的旋钮，调到了罗斯共和国的官方声明：“卫戍部队已经彻底封锁伏尔加格勒……严重缺少重武器的叛军只能用公交车与汽车来阻挡军队的装甲力量，但这甚至不能延迟装甲部队完成任务的时间……极少数叛军残余还被包围在部分区域负隅顽抗，但随着装甲部队的扫荡已经无法逃脱被歼灭的命运……”</p><p>收音机里慷慨激昂的声音持续了整整十五分钟，与之相对应的是外面仍然轰鸣着的金属碰撞声，安德烈从未感觉自己如此渺小。仿佛是看到他的绝望还不足以将它击垮，电话铃声又响了起来，在安德烈听来却像死神的脚步，但他还是无力地拿起了电话：</p><p>“安德烈……现在列昂尼德已经争取到了绝大多数‘复兴派’力量的支持，而老人们也支持采取强硬政策，一切都结束了，运气好的话我们还能继续原来的生活，运气不好就可以做好准备了。”</p><p>电话中的声音嘎然而止。</p><p>安德烈如同坠入深渊。</p><p>尘封的回忆开始在他的脑海中浮现：他想起自己在革命时呱呱坠地，想起青年时经历的工业化与集体农庄的新闻，想起在伟大的卫国战争时他和其他同志一样在枪林弹雨中冲锋，想起“秘密报告”后的迷茫、质疑与骚乱，然后是“复兴罗斯”……</p><p>收音机还在喋喋不休地吵着，但内容已经换成了经济；“委员会总书记列昂尼德发表讲话，强调经济改革绝不能停息，复兴罗斯的道路仍然艰难……经济增长较去年出现突破性发展……已与多家外国企业达成合作，全力推进多元化，市场化，国际化……抛弃原有的僵化思维，引进国外先进经济制度……莫斯科大牧首发言祝贺……”</p><p>他目睹了自己的祖国从废墟中升起，走入壮年，在烈焰中浴血奋战，经历混乱与迷茫，现在则看着自己的祖国终于灰飞烟灭。收音机里歌颂着“祖国”的富强，但他知道，从今夜起，这就不再是他的祖国了。从1917年的彼得格勒，半个世纪，对于一个国家而言太短。</p><p>充斥着子弹与烈焰的城市中，谁也没有注意到，在一座防守严密的建筑群中，一个人跪坐在打扫得一尘不染得地板上，喉咙里发不出声音，那是在为死者默哀，为名存实亡的祖国默哀。</p><p>与此同时，千里之外的沈阳正电闪雷鸣，那是暴风雨的前奏。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 小说 </tag>
            
            <tag> 架空历史 </tag>
            
            <tag> 历史终结之日 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo踩坑记录（一）</title>
      <link href="/archives/2851103091/"/>
      <url>/archives/2851103091/</url>
      
        <content type="html"><![CDATA[<p>最近几天翻找自己的学习笔记时，忽然发现自己的Hexo博客已经长了几个月的草，于是一时兴起又更新了一下Hexo博客，但在构建博客时出现了问题：</p><h2 id="hexo与node.js的兼容性">Hexo与Node.js的兼容性</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">mike@MacBook-Pro ~/hexo $ hexo g                                            [15:13:57]</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Files loaded in 3.05 s</span><br><span class="line">(node:18613) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(Use `node --trace-warnings ...` to show where the warning was created)</span><br><span class="line">(node:18613) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:18613) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">(node:18613) Warning: Accessing non-existent property &#x27;lineno&#x27; of module exports inside circular dependency</span><br><span class="line">(node:18613) Warning: Accessing non-existent property &#x27;column&#x27; of module exports inside circular dependency</span><br><span class="line">(node:18613) Warning: Accessing non-existent property &#x27;filename&#x27; of module exports inside circular dependency</span><br><span class="line">INFO  Generated: tags/index.html</span><br><span class="line">INFO  Generated: about/index.html</span><br><span class="line">INFO  Generated: categories/index.html</span><br><span class="line">INFO  Generated: archives/364215652.html</span><br><span class="line">INFO  Generated: archives/2019/index.html</span><br><span class="line">INFO  Generated: archives/2019/03/index.html</span><br><span class="line">INFO  Generated: archives/2019/04/index.html</span><br><span class="line">INFO  Generated: archives/2019/05/index.html</span><br><span class="line">INFO  Generated: archives/2019/06/index.html</span><br><span class="line">INFO  Generated: archives/2019/07/index.html</span><br><span class="line">INFO  Generated: archives/2020/index.html</span><br><span class="line">INFO  Generated: archives/2020/08/index.html</span><br><span class="line">INFO  Generated: archives/2020/02/index.html</span><br><span class="line">INFO  Generated: categories/游记/index.html</span><br><span class="line">INFO  Generated: categories/网络/index.html</span><br><span class="line">INFO  Generated: categories/随笔/index.html</span><br><span class="line">INFO  Generated: categories/学习笔记/index.html</span><br><span class="line">INFO  Generated: categories/题解/index.html</span><br><span class="line">INFO  Generated: categories/洛谷/index.html</span><br><span class="line">INFO  Generated: categories/洛谷/题解/index.html</span><br><span class="line">INFO  Generated: categories/洛谷/题解/数学/index.html</span><br><span class="line">INFO  Generated: tags/网络安全/index.html</span><br><span class="line">INFO  Generated: tags/NOIP/index.html</span><br><span class="line">INFO  Generated: tags/数据结构/index.html</span><br><span class="line">INFO  Generated: tags/网络/index.html</span><br><span class="line">INFO  Generated: tags/平衡树/index.html</span><br><span class="line">INFO  Generated: tags/Telegram/index.html</span><br><span class="line">INFO  Generated: tags/随笔/index.html</span><br><span class="line">INFO  Generated: tags/转载/index.html</span><br><span class="line">INFO  Generated: tags/天文/index.html</span><br><span class="line">INFO  Generated: tags/SCP/index.html</span><br><span class="line">INFO  Generated: tags/洛谷/index.html</span><br><span class="line">INFO  Generated: tags/计算几何/index.html</span><br><span class="line">INFO  Generated: tags/题解/index.html</span><br><span class="line">INFO  Generated: img/algolia.svg</span><br><span class="line">INFO  Generated: tags/SPOJ/index.html</span><br><span class="line">INFO  Generated: archives/4021524966.html</span><br><span class="line">INFO  Generated: archives/3790557036.html</span><br><span class="line">INFO  Generated: archives/3811762271.html</span><br><span class="line">INFO  Generated: archives/1389482586.html</span><br><span class="line">INFO  Generated: archives/1301002429.html</span><br><span class="line">INFO  Generated: archives/3299158642.html</span><br><span class="line">INFO  Generated: archives/2032683215.html</span><br><span class="line">INFO  Generated: archives/142292747.html</span><br><span class="line">INFO  Generated: archives/1438989892.html</span><br><span class="line">INFO  Generated: archives/2197869946.html</span><br><span class="line">INFO  Generated: archives/3769932704.html</span><br><span class="line">INFO  Generated: archives/3735749857.html</span><br><span class="line">INFO  Generated: archives/index.html</span><br><span class="line">INFO  Generated: archives/2552852216.html</span><br><span class="line">INFO  Generated: archives/2078626702.html</span><br><span class="line">INFO  Generated: img/icp.png</span><br><span class="line">INFO  Generated: img/favicon.png</span><br><span class="line">INFO  Generated: images/algolia_logo.svg</span><br><span class="line">INFO  Generated: images/avatar.gif</span><br><span class="line">INFO  Generated: images/apple-touch-icon-next.png</span><br><span class="line">INFO  Generated: images/cc-by-nc-nd.svg</span><br><span class="line">INFO  Generated: images/cc-by-nc-sa.svg</span><br><span class="line">INFO  Generated: images/cc-by-nd.svg</span><br><span class="line">INFO  Generated: images/cc-by.svg</span><br><span class="line">INFO  Generated: images/cc-zero.svg</span><br><span class="line">INFO  Generated: images/cc-by-nc.svg</span><br><span class="line">INFO  Generated: images/cc-by-sa.svg</span><br><span class="line">INFO  Generated: images/favicon-16x16-next.png</span><br><span class="line">INFO  Generated: images/favicon.png</span><br><span class="line">INFO  Generated: images/loading.gif</span><br><span class="line">INFO  Generated: images/logo.svg</span><br><span class="line">INFO  Generated: images/favicon-32x32-next.png</span><br><span class="line">INFO  Generated: images/placeholder.gif</span><br><span class="line">INFO  Generated: images/searchicon.png</span><br><span class="line">INFO  Generated: images/quote-r.svg</span><br><span class="line">INFO  Generated: images/quote-l.svg</span><br><span class="line">INFO  Generated: archives/3581552066.html</span><br><span class="line">INFO  Generated: archives/2251452003.html</span><br><span class="line">INFO  Generated: archives/704167021.html</span><br><span class="line">INFO  Generated: archives/1580237458.html</span><br><span class="line">INFO  Generated: archives/1827780785.html</span><br><span class="line">INFO  Generated: index.html</span><br><span class="line">INFO  Generated: images/Jietu20190416-142149@2x.jpg</span><br><span class="line">INFO  Generated: archives/2019/page/2/index.html</span><br><span class="line">INFO  Generated: archives/page/2/index.html</span><br><span class="line">INFO  Generated: img/404.jpg</span><br><span class="line">INFO  Generated: css/var.css</span><br><span class="line">INFO  Generated: archives/1401793044.html</span><br><span class="line">INFO  Generated: page/2/index.html</span><br><span class="line">INFO  Generated: img/loading.gif</span><br><span class="line">INFO  Generated: page/3/index.html</span><br><span class="line">INFO  Generated: archives/page/3/index.html</span><br><span class="line">INFO  Generated: js/utils.js</span><br><span class="line">INFO  Generated: js/search/local-search.js</span><br><span class="line">INFO  Generated: js/third-party/ClickShowText.js</span><br><span class="line">INFO  Generated: img/friend_404.gif</span><br><span class="line">INFO  Generated: images/Jietu20190408-204825@2x.jpg</span><br><span class="line">INFO  Generated: images/Jietu20190416-142524@2x.jpg</span><br><span class="line">INFO  Generated: images/avatar2.jpg</span><br><span class="line">INFO  Generated: js/search/algolia.js</span><br><span class="line">INFO  Generated: js/third-party/activate-power-mode.js</span><br><span class="line">INFO  Generated: js/third-party/canvas-nest.js</span><br><span class="line">INFO  Generated: js/third-party/canvas-ribbon.js</span><br><span class="line">INFO  Generated: js/third-party/click_heart.js</span><br><span class="line">INFO  Generated: js/third-party/fireworks.js</span><br><span class="line">INFO  Generated: js/third-party/piao.js</span><br><span class="line">INFO  Generated: images/right_rotate.jpg</span><br><span class="line">INFO  Generated: images/1583162215202.jpg</span><br><span class="line">INFO  Generated: images/left_rotate.jpg</span><br><span class="line">INFO  Generated: images/no.jpg</span><br><span class="line">INFO  Generated: js/main.js</span><br><span class="line">INFO  Generated: js/tw_cn.js</span><br><span class="line">INFO  Generated: images/1582504823938.jpg</span><br><span class="line">INFO  Generated: search.xml</span><br><span class="line">INFO  Generated: css/index.css</span><br><span class="line">INFO  Generated: images/avatar1.jpg</span><br><span class="line">INFO  Generated: images/1583165079891.jpg</span><br><span class="line">INFO  Generated: images/avatar.jpg</span><br><span class="line">INFO  114 files generated in 1.74 s</span><br></pre></td></tr></table></figure><p>首先，Sophon酱自然是发挥自己作为一名OIer搜（xun）索（zhao）资（ti）料（jie）的能力，找到了这个<a href="https://github.com/hexojs/hexo/issues/4257">Hexo的GitHub Issue</a></p><p>按照这里面的大牛的说法，这是Node.js 14的一个兼容性问题，Sophon酱使用的版本是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sophon@MacBook-Pro ~/hexo $ hexo version                                      [15:14:07]</span><br><span class="line">INFO  Validating config</span><br><span class="line">hexo: 5.0.1</span><br><span class="line">hexo-cli: 4.2.0</span><br><span class="line">os: Darwin 19.6.0 darwin x64</span><br><span class="line">node: 14.4.0</span><br><span class="line">v8: 8.1.307.31-node.33</span><br><span class="line">uv: 1.37.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.7</span><br><span class="line">ares: 1.16.0</span><br><span class="line">modules: 83</span><br><span class="line">nghttp2: 1.41.0</span><br><span class="line">napi: 6</span><br><span class="line">llhttp: 2.0.4</span><br><span class="line">openssl: 1.1.1g</span><br><span class="line">cldr: 37.0</span><br><span class="line">icu: 67.1</span><br><span class="line">tz: 2019c</span><br><span class="line">unicode: 13.0</span><br></pre></td></tr></table></figure><p>Node.js 14目前与Hexo存在兼容性问题（目前Hexo官方让然没有修好），所以只要将Node.js降级就可以了。</p><p>以下是在macOS系统上的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew unlink node #Homebrew操作，解除原来的Node.js在/usr/local/bin/内的链接</span><br><span class="line">brew install node@12 #安装Node.js 12</span><br><span class="line">brew link --overwrite --force node@12 #将新安装的Node.js 12连接到/usr/local/bin/node</span><br></pre></td></tr></table></figure><h2 id="macos升级后npm更新报错">macOS升级后NPM更新报错</h2><p>在写这篇文章之前，Sophon酱使用的Hexo版本号是4.2.1，在听说Hexo 5.0.1更新的消息后准备更新一下试试，然后就遇到了如下问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">mike@MacBook-Pro ~/hexo $ npm install --save                               [13:48:33]</span><br><span class="line"></span><br><span class="line">&gt; fsevents@1.2.11 install /Users/mike/hexo/node_modules/nunjucks/node_modules/fsevents</span><br><span class="line">&gt; node-gyp rebuild</span><br><span class="line"></span><br><span class="line">No receipt for &#x27;com.apple.pkg.CLTools_Executables&#x27; found at &#x27;/&#x27;.</span><br><span class="line"></span><br><span class="line">No receipt for &#x27;com.apple.pkg.DeveloperToolsCLILeo&#x27; found at &#x27;/&#x27;.</span><br><span class="line"></span><br><span class="line">No receipt for &#x27;com.apple.pkg.DeveloperToolsCLI&#x27; found at &#x27;/&#x27;.</span><br><span class="line"></span><br><span class="line">gyp: No Xcode or CLT version detected!</span><br><span class="line">gyp ERR! configure error</span><br><span class="line">gyp ERR! stack Error: `gyp` failed with exit code: 1</span><br><span class="line">gyp ERR! stack     at ChildProcess.onCpExit (/usr/local/Cellar/node@12/12.18.1/lib/node_modules/npm/node_modules/node-gyp/lib/configure.js:351:16)</span><br><span class="line">gyp ERR! stack     at ChildProcess.emit (events.js:315:20)</span><br><span class="line">gyp ERR! stack     at Process.ChildProcess._handle.onexit (internal/child_process.js:275:12)</span><br><span class="line">gyp ERR! System Darwin 19.6.0</span><br><span class="line">gyp ERR! command &quot;/usr/local/Cellar/node@12/12.18.1/bin/node&quot; &quot;/usr/local/Cellar/node@12/12.18.1/lib/node_modules/npm/node_modules/node-gyp/bin/node-gyp.js&quot; &quot;rebuild&quot;</span><br><span class="line">gyp ERR! cwd /Users/mike/hexo/node_modules/nunjucks/node_modules/fsevents</span><br><span class="line">gyp ERR! node -v v12.18.1</span><br><span class="line">gyp ERR! node-gyp -v v5.1.0</span><br><span class="line">gyp ERR! not ok</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 (node_modules/nunjucks/node_modules/fsevents):</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.11 install: `node-gyp rebuild`</span><br><span class="line">npm WARN optional SKIPPING OPTIONAL DEPENDENCY: Exit status 1</span><br><span class="line"></span><br><span class="line">updated 2 packages in 28.613s</span><br><span class="line"></span><br><span class="line">9 packages are looking for funding</span><br><span class="line">  run `npm fund` for details</span><br></pre></td></tr></table></figure><p>其中，<code>gyp: No Xcode or CLT version detected!</code>可以看出这个错误是Xcode工具造成的，因此更新一下Xcode工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mike@MacBook-Pro ~/hexo $ xcode-select --install                            [14:18:11]</span><br><span class="line">xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates</span><br></pre></td></tr></table></figure><p>emmmm好吧，Xcode工具并没有更新，那就只能是上个星期macOS升级时出现了问题。先删除原来的Xcode工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf $(xcode-select -print-path)</span><br></pre></td></tr></table></figure><p>再执行这条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mike@MacBook-Pro ~/hexo $ xcode-select --install                            [14:19:06]</span><br><span class="line">xcode-select: note: install requested for command line developer tools</span><br></pre></td></tr></table></figure><p>这次再试试更新Hexo:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mike@MacBook-Pro ~/hexo $ npm install --save                                [14:19:19]</span><br><span class="line"></span><br><span class="line">&gt; fsevents@1.2.11 install /Users/mike/hexo/node_modules/nunjucks/node_modules/fsevents</span><br><span class="line">&gt; node-gyp rebuild</span><br><span class="line"></span><br><span class="line">  SOLINK_MODULE(target) Release/.node</span><br><span class="line">  CXX(target) Release/obj.target/fse/fsevents.o</span><br><span class="line">  SOLINK_MODULE(target) Release/fse.node</span><br><span class="line">added 71 packages from 33 contributors in 12.939s</span><br><span class="line"></span><br><span class="line">10 packages are looking for funding</span><br><span class="line">  run `npm fund` for details</span><br></pre></td></tr></table></figure><p>大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客 </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「习作」《红星照耀中国》读书笔记</title>
      <link href="/archives/364215652/"/>
      <url>/archives/364215652/</url>
      
        <content type="html"><![CDATA[<p>　　每一个中国人都知道，自己祖国的全名是“中华人民共和国”，其中的“人民”昭示着这是一个社会主义的国家。但或许有人不知道的是，社会主义的火种，是如何在这片几代人之前还是半封建半殖民地的国家扎下根的？</p><p>　　在今天，离我们那个时代或许已经十分遥远，但这并不能作为我们忘却斗争精神的理由。须知，我们今日的昌盛，不是资本家们施舍的，而是无数人民英雄们抛头颅、洒热血换得的！我们难道能因为出生在一个所谓“岁月静好”的年代，就忘记了革命年代的理想与信念吗？不！我们永不忘记！</p><p>　　《红星照耀中国》最早出版于1937年。</p><p>　　那个时代坏吗？坏，因为那个时代军阀混战，国土沦亡，最顶层的吸血鬼肆意掠夺人民的财产，用来充实自己家族的钱包。而底层的平民命如草芥，仅仅是活下去都要付出无法承受的代价。帝国主义肆虐，公然查收中国的政治，经济，在租界耀武扬威。买办阶级为一己私利打压民族工业，公然为帝国主义充当马前卒。牛鬼蛇神横行人间。可以说，那个时代是“坏”的。</p><p>　　那个时代好吗？好，因为那个时代共产运动风起云涌，共产党人踏过漫长的征途，在西北建立了革命的根据地。“地火在地下运行，奔突；熔岩一旦喷出，将烧尽一切野草，以及乔木，于是并且无可朽腐。”随着苏维埃共和国的红旗在瑞金升起，觉醒的中国人民向全世界展示自己的力量。红军从中国南部远征至西北，宣告了中华苏维埃共和国的成立，这片土地上站起了这里的第一个社会主义国家。从此在无产阶级先锋队的带领下，这片土地上的一切都将地覆天翻。随着第二次国内革命战争以共产党的胜利而告终，革命者们拥有了胜利的一切条件，“红日初升，其道大光”，剥削者们注定不能安睡。可以说，那个时代是“好”的。</p><p>　　这是最好的时代，这是最坏的时代。</p><p>　　倘若有消灭剥削阶级的希望，这就是最好的时代；</p><p>　　倘若长夜漫漫，看不见革命的星火，如同一沟绝望的死水，清风吹不起半点涟漪，这就是最坏的时代。</p><p>　　黎明前的黑暗是最黑暗的时候，是一切反革命势力都聚集在一起，企图绞杀新生的苏维埃政权的时候，尽管如此，社会主义的胜利最终会会点燃天边的朝霞，让黑夜无处遁形。</p><p>　　他们污蔑新生的红色政权，试图通过宣传机器让民众相信那只是藏在山坳里的几千饥饿的土匪，但他们如何解释自己的军队在一次次战斗中被自己口中的“藏在山坳里的几千饥饿的土匪”打得落花流水呢？纵使他们可以派出百万大军，让外国的军事顾问来做参谋，纵使他们可以靠兵力的优势取得战术上的胜利，但他们永远都不可能取胜，因为他们自己也不知道自己的敌人是如何获胜的。共产主义者胜利的基础是人民，哪怕他们能从肉体上消灭这片土地上所有的共产主义者，只要共产主义的精神还在，共产主义的胜利就一定会来临。</p><p>　　当他们在饥荒时哄抬米价，投机倒把时，是否知道有一个十六岁的少年看到被饿得不成人形的农民后，凭着少年时的一腔热血，带领农民攻打自己同乡的粮仓？</p><p>　　当他们趾高气扬的要求冒犯自己的“苦力”摆宴席，放鞭炮来给自己赔礼道歉时，是否知道有一个工人正因为自己和工友们被厂长因此欺压，并用罢工来想压迫者发出警告？</p><p>　　当他们让自己的走狗搜刮民脂民膏，试图从蚊子的腹中刳出最后一点脂油时，是否知道有一位被他们称作是“劣迹昭著”的“土匪头子”，用一把菜刀领导了当地民众的反抗，建立了一个位于腹地的苏维埃政权？</p><p>　　当他们血腥镇压因走投无路而起义的反抗队伍时，是否知道在一幢乡间小屋中，有一个青年正用帘子遮住自己房间的灯光读《盛世危言》？</p><p>　　他们是否想过，自己已习以为常的一举一动，都是在挖掘自己的坟墓？</p><p>　　肉食者们不会明白。</p><p>　　他们也一样。</p><p>　　有人指责我们，说我们对待那些剥削，压榨无产阶级的人过于残酷；但请问，过于“残酷”是指什么？是指我们改变了旧有的，从人民身上吸血的的生产关系吗？如果是，那我们会坦然的承认自己的所作所为。</p><p>　　诚然，我们何尝不想要和平的发展，迈入下一个阶段？但当时的中国真的有“和平发展”的道路可走吗？一开始，我们并没有到农村去发展革命事业，但资产阶级政府的军队在城市里大肆屠杀支持共产党工人和学生；一开始，红军并没有铲除地主阶级的人本身，但那些地主立即就勾结反动势力，组建“还乡团”反过来攻击红色政权；一开始，我们并没有全面向资产阶级政府开战，但他们每天都从外国手里拿“援助中国人民”的物资来镇压中国的人民。</p><p>　　有人指责我们对待就阶级不人道，但他们在三千年的历史中就对人民人道了吗？区别只是在于，这次是如同暴风骤雨般扫尽一切枯朽的，而他们的所作所为是在三千个春秋的漫长岁月里慢慢地折磨着无数代人。当我们消灭旧有阶级时，就有人跳出来，说我们不人道。但他们在数千年中鞭策上亿劳动者奔波一生，最后只换得一身疾病，以高利贷令佃户整日劳作，连晚上都无法安睡，一生都生活在屈辱，痛苦，贫穷与悲痛中时，他们是否想过半个“人道”？</p><p>　　有人指责我们是“赤匪”，但他们自己又是否是“政府”呢？如果是，是谁的“政府”呢？是资本家和地主的政府吗？如果是，那我们推翻它是天经地义的。</p><p>　　正如《钢铁是怎样炼成的》所说：</p><p>　　“他们传瓦莉亚到法庭上去作证。她回来跟我们说，斯涅古尔科承认他进行过共产主义宣传，但是断然否认他背叛祖国。他说：我的祖国是波兰苏维埃社会主义共和国。是的，我是波兰共产党党员。我当兵是被迫的。我一向所做的工作，不过是帮助那些跟我一样被你们赶到前线的士兵睁开眼睛。你们可以为了这个绞死我，但是我从来没有背叛自己的祖国，而且永远都不会背叛。只是我的祖国跟你们的不同。你们的祖国是地主贵族的，我的祖国是工人农民的！我深信，我的祖国一定会成为一个工农大众的国家，而在我的这个祖国里，决不会有人说我是叛徒。”</p><p>　　没错，我们的祖国是中华苏维埃共和国，而他们的祖国是中华民国。我们的祖国是无产阶级的，他们的祖国是资产阶级的。倘若他们坚持要爱自己的祖国的话，我们只会毫不迟疑的将他们和他们的祖国一起送进地狱。</p><p>　　正如马克思和恩格斯在《德意志意识形态》中所说：“民族是“虚幻共同体”，民族间的斗争是“虚幻的斗争”，目的是掩盖真实的阶级斗争”“民族主义不是天经地义的自然真理，而是资本主义时代的产物”</p><p>　　资产阶级宣传国家矛盾，要求无产阶级无条件妥协，是为了掩盖国内愈演愈烈的阶级矛盾。他们口中的“国家利益”其实就是“资产阶级利益”，与无产阶级的利益是相冲突的。只不过他们用“国家”这一概念巧妙地把所有阶级包括了，试图用虚幻的“最广大人民”来掩盖阶级斗争。国家之间的冲突，本质上是一个国家对另一个国家的剥削，当这一点被指出后，“国家利益”的神话也就不攻自破了。“工人没有祖国。决不能剥夺他们所没有的东西。因为无产阶级首先必须取得政治统治，上升为民族的阶级，把自身组织成为民族，所以它本身还是民族的，虽然完全不是资产阶级所理解的那种意思。”共产党永远都是代表是无产阶级利益，而非代表某个国家，某个民族的利益的。</p><p>　　在红军长征的路上，被压迫的不止汉族，还有彝族，藏族，回族……它们几千年来都生活在水深火热之中，在社会主义革命中迎来了解放，为何？因为“中华苏维埃共和国”不是某一个民族的国家，它不属于任何一个民族！所谓“民族”的概念是资产阶级革命后才被逐渐提出的，是为了迎合资产阶级的利益而被捏造出来的。资产阶级高呼着：“为了伟大的民族！”人民便蜂拥而至在战场上流尽了最后一滴血，到头来却只是充实了资产阶级的钱包。中华苏维埃共和国不是民族国家，而是无产阶级的国家；中华苏维埃共和国不会维护某一个民族的利益，更不会剥削其他民族，它是属于无产阶级的，是无产阶级的苏维埃。</p><p>　　社会主义革命，是一场燃遍整个中华大地的熊熊烈火，是这片土地上发生过的所有革命中最长久，最深刻，最彻底的：我们将骑在人民头上的吸血鬼和寄生虫枪毙，改革了原有的生产关系，甚至派出军队迎击侵略我们的日本帝国主义——哪怕立刻就被南京政府十一师精锐新军拦截。</p><p>　　这场革命与自陈胜吴广以来的任何一次革命都要不同，之前的革命，只是一小部分人推翻另一小部分人的统治，革命后，贵族仍然骑在人民头上作威作福，佃户仍然改变不了被迫借高利贷最后破产的命运。而这次是大多数人的革命，同时也是社会制度的革命，历史的车轮滚滚向前，自工业革命以来逐渐成型的新阶级——无产阶级，正在迎来属于自己的胜利。</p><p>　　在黎明前的黑暗中，共产主义者们转移到了中国最不发达的地区之一：西北。这里很少有高产的田地，工业基础为零，主要的产业是畜牧业。但共产主义者们并未因此气馁，他们穿越大半个中国，将战略转移时仅有的工业设备投入建设；开采原油的矿藏，经营着全国最丰富的钨矿；他们在当地展开扫盲运动，甚至将部分地区的识字率提高到了百分之八十。他们仅仅靠着自己的双手，在不久前还是白地的地方建立了欣欣向荣的城市。这一切都使资产阶级政府的反动宣传不攻自破，甚至不需要什么人去修饰一番，这些事件本身就已经证明了，中华苏维埃共和国，是一个比中国其他任何地方都要伟大的政权。</p><p>　　今天并不是和平的年代，阶级斗争从未熄灭，在实现共产主义前永远都不会熄灭。毫无疑问，帝国主义的阴云自二战结束以来，就一只萦绕在我们头顶：看吧，他们手握资产阶级政权的大棒，肆意镇压试图团结起来的人民；他们不顾人民的嗟伤，明目张胆地从工人身上剥削最后一点剩余价值；他们利用权力，在人民遇到劫难时中饱私囊；他们操纵舆论，故意令共产主义的理想被人弃之不顾。对战乱地区的军火输出，已经暴露了他们的帝国主义嘴脸。我们难道能忘记？几十年前的先驱者们，暴霜露，斩荆棘，在井冈山上吃着南瓜与帝国主义作斗争，二十一世纪的我们就没有这种精神了吗？</p><p>　　我们没有所谓的“岁月静好”，正相反，我们出生在一个矛盾激烈的年代。出生在红旗下的我们，更应该勇于前进，不畏艰难，与帝国主义势力作斗争。抬起头看看你眼前的红旗吧，左上角的符号——镰刀与锤头，昭示着无产阶级是这个国家的统治阶级；再看看我们的国徽，上面的齿轮与麦穗象征着工人与农民，才是这个国家的根本。</p><p>　　“并不是所有的人，都理解支持我们的建设，但并不能否认她的伟大。我们的战士，神圣的信仰，永远都不会磨灭，它照耀着我们每一个人。”</p><p>　　我们必须明白，只有革命的斗争，才能从敌人手中夺回本应属于我们的东西。身为中学生的我们，必须用知识武装自己的头脑，将马克思的名言“任何时候我也不会满足，越是多读书，就越是深刻地感到不满足， 越感到自己知识贫乏” 铭记在心，投身于共产主义的事业中去。</p><p>　　英特纳雄耐尔，就一定要实现！</p><p>　　东方太阳，正在升起，人民共和国正在成长！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telegram折腾记</title>
      <link href="/archives/3581552066/"/>
      <url>/archives/3581552066/</url>
      
        <content type="html"><![CDATA[<p>出于一些众所周知的原因，一些即时通讯软件不能很好地满足我们的需求：</p><ul><li>QQ/WeChat，国产+闭源+黑历史，不存在的</li><li>WhatsApp/iMessages，闭源的商业软件，再加上某Prism，不存在的</li><li>Signal/Jabber，在国内比较小众，用户数量太少</li></ul><h2 id="telegram是什么">Telegram是什么</h2><p>以下内容摘自维基百科：</p><blockquote><p>Telegram是跨平台的即时通信软件，其客户端是自由及开放源代码软件，但服务器是专有软件。用户可以相互交换加密与自毁消息，发送照片、影片等所有类型文件。官方提供手机版（Android、iOS、Windows Phone）、桌面版（Windows、macOS、Linux）和网页版等多种平台客户端；同时官方开放应用程序接口（API），因此拥有许多第三方的客户端可供选择，其中多款内置中文。</p></blockquote><p>在墙越来越高的今天，许多软件都被证实并不可靠，前段时间升至爆出过腾讯一个数据方面的小主管就能调取聊天记录的新闻。于是乎，Sophon开始找在某些方面更优秀的IM（即时通讯）软件，然后就找到了Telegram。</p><p>Telegram有以下几个优势：</p><ul><li>完全免费，多平台不限制同步消息，比微信QQ之流不知高到哪里去了</li><li>跨平台，支持Windows，macOS，Linux，iOS，Android，和Web端</li><li>分享单个文件最大可达1.5G（更新后为2G）</li><li>客户端开源，放心</li><li>可以选择端到端加密并销毁数据</li><li>服务器端虽然储存平时聊天的记录，但Telegram骨头硬啊，俄罗斯政府曾经找Telegram要密钥，被Telegram一句话怼回去了，后来被逐出俄罗斯也不松口</li><li>Signal之类的软件或许比Telegram更安全，但是如果你注册了，你会惊喜得发现，没什么人用，最后放在硬盘里吃灰</li></ul><h2 id="telegram的安装">Telegram的安装</h2><p>Telegram当然可以直接从官网下载，但大多数人是访问不了Telegram官网的，所以就要另辟蹊跷：</p><ol type="1"><li>Telegram被托管在GitHub上，因此可以从GitHub上下载Telegram，具体来说是https://github.com/telegramdesktop/tdesktop/releases</li></ol><p>但是，请注意，GitHub在国内是属于半被墙状态，因此可能要使用多线程下载器之类的“奇技淫巧”来克服困难了。</p><ol start="2" type="1"><li>如果你是Apple用户并且又一个美区AppleID，恭喜你，你可以直接从App Store下载Telegram</li></ol><p>当然，如果以上方案都不行，你还是老老实实用梯子吧，也不贵，有机场圈的朋友介绍的话就更简单了</p><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/HeliumOI.github.io/images/1582504823938.jpg" /></p><h2 id="telegram的注册">Telegram的注册</h2><p>因为Sophon酱在用macOS，所以暂时只有macOS的图例</p><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/HeliumOI.github.io/images/1583162215202.jpg" /></p><p>首先在这里输入你的手机号码，然后你就会很惊喜的发现……</p><p>无法连接</p><p>原因不言而喻，毕竟由于墙的存在，这类软件基本不可能直接连接，用VPN等梯子就能简单的解决这个问题；</p><p>当然，如果您实在是没钱，Telegram还提供了另一个选项：使用公益MTProxy代理</p><p>（不用担心，代理服务器看不到你的聊天内容）</p><p>比较靠谱的代理频道有@onessr <span class="citation" data-cites="socks5list">@socks5list</span> 等</p><p>顺带一提，MTPProxy代理经常会被屏蔽，所以平时最好多准备几个订阅频道以及梯子</p><p>连接上之后可以订阅代理频道，获取长期可用的链接</p><p>当然有条件的话最好还是用自己的代理</p><p>第一次打开时是无法设置代理的，这时不要慌，直接正常输入自己的电话号码，然后会弹出要求你设置代理的提示，按要求填写就可以了。</p><p>注册成功后会要求你填写自己的姓名<del>（当然不用填真名</del></p><h2 id="telegram的概念解释">Telegram的概念解释</h2><p>毕竟 <del>露西娅酱</del> 毛子开发的软件，在很多操作习惯上都和国人有区别，具体说来如下：</p><h3 id="telegram的好友机制">Telegram的好友机制</h3><p>国内的IM中，QQ，微信等都有“好友”的概念，但Telegram中没有。Telegram的概念是“联系人”，是单向的，即：你可以将对方加为你的联系人，但你不一定是对方的联系人。</p><h3 id="telegram的群组">Telegram的群组</h3><p>Telegram群组其实就和QQ群，微信群差不多，但Telegram群组最大容量有20万人</p><p>同时，Telegram的公开群组有所谓“分享链接”，这意味着你不需要像微信那样发个二维码，直接用链接就能分享。即使是非公开群组，也有“邀请链接”，但“邀请链接”需要管理员才能查看。</p><p>另外，Telegram上的公开群组是可以在Google上被搜索到的，直接搜索“关键词 site:t.me”即可</p><h3 id="telegram的频道">Telegram的频道</h3><p>“频道”其实和群组没有本质差别，但区别在于：“频道”中只有一个用户，即管理用户能发言</p><h2 id="telegram的注意事项">Telegram的注意事项</h2><h3 id="telegram汉化">Telegram汉化</h3><p>根据官方介绍，Telegram提供 英语， 西班牙语， 德语， 荷兰语， 意大利语， 葡萄牙语， 朝鲜语， 俄语， 法语， 印尼语， 马来语， 波斯语， 乌克兰语的界面文字，但偏偏就不提供中文的，暂时还不知道原因。</p><p>不过，虽然官方不提供，也有第三方的热心人士自己对Telegram的界面进行了翻译；使用方法如下：</p><p>进入频道@zh_CN</p><p><img src="https://cdn.jsdelivr.net/gh/HeliumOI/HeliumOI.github.io/images/1583165079891.jpg" /></p><p>点击“点击此处安装语言包”</p><h3 id="spam用户">Spam用户</h3><p>大概是由于某些“币圈”人士经常用Telegram来推广比特币，+86手机号注册后会被官方直接判断为Spam（垃圾）账号，判断自己是否是Spam账号的方法是向其他用户发送私聊信息时是否显示“只能发信给双向联系人”</p><p>如果你注册时使用的是大陆的手机号，那么你已经被判定为Spam用户了。要解封也不难，联系官方账号@SpamBot，说明情况（用英文）即可</p><h2 id="关于telegram的一些问题">关于Telegram的一些问题</h2><h3 id="qtelegram默认没有端到端加密这是否意味着telegram的安全性比whatsappfacebook-messenger更低">Q:Telegram默认没有端到端加密，这是否意味着Telegram的安全性比WhatsApp、Facebook Messenger更低？</h3><p>当然不是！</p><p>首先要明白一个概念，如果你进行真正的「端到端加密」，你的信息是无法在不同设备之间同步的。对于这一点，用过XMPP通讯的朋友应该很清楚，当你结束一次XMPP加密通讯后，在林一个地方登录账号，查看你的聊天记录时，只能看到一堆乱码。</p><p>这也是XMPP，Signal这类软件小众的原因之一，普通用户一半都有同步自己聊天记录的需求。</p><p>在WhatsApp等常用的通讯软件（微信、QQ等直接红牌罚下场，原因不言而喻）中，即使你选择了端到端加密，你的密钥也是保存在服务器端的，在你查看聊天记录是会使用保存的密钥解密。这意味着该软件公司或NSA等部门可以随时查看你的信息。</p><p>关于这一点的具体情况，大家可以下载爱德华·斯诺登的著作<a href="https://a.temporaryrecord.com/Permanent_Record_-_CN_edition_with_underlined_redactions.pdf">《永久记录》的电子版</a>来看，里面有很多关于大规模监听的内容。</p><p>而Telegram是如何处理这一点的？在默认情况下，Telegram也和普通的通讯软件一样，将密钥保存在云端。（没人愿意自己的聊天记录一下线就消失！）但Telegram也可以选择「加密对话」，在这种情况下，加密通讯的密钥会在对话结束之后销毁。</p><p>在这里Sophon酱给大家一个小建议，如果真的不希望某些聊天记录被别人知晓，最好还是用「加密对话」的方式进行。虽然Telegram公司曾经因为密钥的事和俄罗斯联邦安全局打过官司，但一定要记住一句话：在信息安全方面，除了自己之外，不要相信任何人。</p><h3 id="我注册了telegram账号我可以去看那些地方">我注册了Telegram账号，我可以去/看那些地方？</h3><p>推荐几个Telegram群组或频道：</p><p><a href="https://t.me/joinchat/Gueflk8USNj6n68rA7aCEw">洛谷TG群（非官方）</a>，这里是洛谷OIer的交流群，但不太活跃（大陆用户人数少</p><p><a href="https://t.me/joinchat/GaEGzlAec5HRSoSxW7o2kg">OI WIki群</a>，OI Wiki的群组，<del>其实里面主要是几个大佬在处理工作。</del></p><p>退役OIer交流群，各种现役/退役OIer的聚集地。邀请链接暂时没有，可以找别人邀请加入</p><p><a href="https://t.me/coder_ot">Coder Offtopic 中文群</a>，关于技术的各种杂谈，里面有一些计算机技术方面的大神，讨论氛围不错</p><p>最后插一句，Sophon酱的用户是@SophonCI，有别的问题可以联系哦～</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
            <tag> 网络安全 </tag>
            
            <tag> Telegram </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解P3197 [HNOI2008]越狱</title>
      <link href="/archives/4021524966/"/>
      <url>/archives/4021524966/</url>
      
        <content type="html"><![CDATA[<h1 id="思路">思路</h1><p>这道题可以从反面去考虑，即：先计算出不可能发生越狱的状态总数，并用它减去总状态数即为这道题要求的答案。</p><p>首先，在不失一般性的情况下，不妨设第一个房间里的犯人的宗教信仰为<span class="math inline">\(p\)</span>，则第二个房间里的烦人的宗教信仰不能为<span class="math inline">\(p\)</span>，因此第二个房间里的犯人的宗教信仰共有<span class="math inline">\((m - 1)\)</span>种可能性。同理，第三个房间里的犯人的宗教信仰也共有<span class="math inline">\((m - 1)\)</span>种可能性……故第二个到第<span class="math inline">\(n\)</span>个房间里的烦人的宗教信仰共有<span class="math inline">\((n - 1)^{(m - 1)}\)</span>种可能性。而第一个房间里的犯人的信仰有<span class="math inline">\(n\)</span>种可能，故不可能发生越狱的状态总数为 <span class="math display">\[n×(n - 1)^{(m - 1)}\]</span></p><p>那么，总状态数是多少呢？容易求的总状态数为<span class="math inline">\(n^m\)</span>，所以题目所求为 <span class="math display">\[n^m-n×(n - 1)^{(m - 1)}\]</span></p><p>这道题还有一个要注意的地方：<span class="math inline">\(m\)</span>最大为<span class="math inline">\(10^8\)</span>，因此要用快速幂来计算</p><p>AC代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">long</span> <span class="type">long</span> MOD = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="built_in">power</span>(b, p / <span class="number">2</span>);</span><br><span class="line">    ans = ans * ans % MOD;</span><br><span class="line">    <span class="keyword">if</span>(p % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        ans = ans * b % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m, n;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = ((<span class="built_in">power</span>(m, n) - m * <span class="built_in">power</span>(m - <span class="number">1</span>, n - <span class="number">1</span>)) % MOD + MOD) % MOD;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 数学 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 SP196 【MUSKET - Musketeers】</title>
      <link href="/archives/1389482586/"/>
      <url>/archives/1389482586/</url>
      
        <content type="html"><![CDATA[<p>在模拟赛中遇到了这道题。（后来才知道是SPOJ上的原题）</p><p>话不多说，开始动态规划三步走。<span class="math inline">\(Let&#39;s\ go!\)</span></p><h2 id="定义状态">定义状态</h2><p>假设第1个人能够赢得整场决斗：</p><p>倘若把这位仁兄复制一份，放在<span class="math inline">\(n + 1\)</span>的；那么，在一阵厮杀后，他和自己的分身应当能够相遇。那么，我们就和 在<a href="https://www.luogu.org/problem/P1880">[NOI1995]石子合并</a>中一样，将数组翻倍后再处理。</p><p><del>显而易见</del>定义状态如下：</p><p><span class="math inline">\(dp_{i,j}\)</span>为第<span class="math inline">\(i\)</span>人与第<span class="math inline">\(j\)</span>人是否能够相遇</p><h2 id="状态转移方程">状态转移方程</h2><p>现在思考一下：第<span class="math inline">\(i\)</span>人与第<span class="math inline">\(j\)</span>人是否能够相遇？</p><p>按照区间DP的思维，我们在<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>之间选取一个人<span class="math inline">\(k\)</span></p><p>若<span class="math inline">\(i\)</span>与<span class="math inline">\(k\)</span>能相遇，<span class="math inline">\(k\)</span>与<span class="math inline">\(j\)</span>能相遇，且<span class="math inline">\(i\)</span>与<span class="math inline">\(j\)</span>当中的任何一个人能干掉<span class="math inline">\(k\)</span></p><p>故状态转移方程为：</p><p><span class="math display">\[dp_{i,j} = dp_{i,k} \&amp;\&amp;\ dp_{k,j} \&amp;\&amp;\ (w_{i,k} || w_{j,k})\]</span></p><h2 id="边界条件">边界条件</h2><p><del>显然，</del> 若两人本来就相邻，则<span class="math inline">\(dp_{i,j} = 1\)</span></p><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span> * <span class="number">2</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[MAXN][MAXN], f[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f)); <span class="comment">//数组清零，我在这里掉了两次坑</span></span><br><span class="line">        <span class="built_in">memset</span>(w, <span class="number">0</span>, <span class="built_in">sizeof</span>(w));</span><br><span class="line"></span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> c;</span><br><span class="line">                cin &gt;&gt; c;</span><br><span class="line">                w[i][j] = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                w[i + n][j + n] = w[i + n][j] = w[i][j + n] = w[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> l = <span class="number">1</span>; l &lt;= n + <span class="number">1</span>; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + l - <span class="number">1</span> &lt;= n * <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(l &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    f[i][j] = <span class="number">1</span>; <span class="comment">//边界条件</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(f[i][k] &amp;&amp; f[k][j] &amp;&amp; (w[i][k] || w[j][k])) &#123;</span><br><span class="line">                        f[i][j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][i + n]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[i][i + n]) &#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> SPOJ </tag>
            
            <tag> 区间DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>慢慢的，就没有了，就像从未存在过</title>
      <link href="/archives/3811762271/"/>
      <url>/archives/3811762271/</url>
      
        <content type="html"><![CDATA[<center><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="510" height="86" src="//music.163.com/outchain/player?type=2&amp;id=511333096&amp;auto=0&amp;height=66"></iframe></center><p>几年以前，我曾经嘲笑过某科技界大佬。当时他说：也许90后、95后会慢慢不知道谷歌是什么网站。</p><p>　　那一年，这对于我来说简直就是世界上最好笑的笑话。谷歌，全世界最卓越的互联网公司，活在互联网的一代中国人，会不知道他们的网站？</p><p>　　今天，我收回这句嘲笑。因为这件不可能的事，它慢慢变成了现实。</p><p>　　没有人再关注什么谷歌不谷歌。对他们来说，百度也蛮好用的，反正他们几乎没用过谷歌。没有谷歌又怎样？大家还是开心的刷微博，看微信，听歌，看娱乐节目。对于从来就不知道谷歌的人来说，少了谷歌又有什么影响？</p><figure><img src="https://cdn.jsdelivr.net/gh/HeliumOI/HeliumOI.github.io@latest/images/no.jpg" alt="慢慢的，就没有了，就像从未存在过" /><figcaption aria-hidden="true">慢慢的，就没有了，就像从未存在过</figcaption></figure><p>　　多年前，我们也是可以登陆Facebook的。其实这个网站和校内一样，也挺蠢的。可在上面你能看到老外们的生活，可以轻易的跟一万公里以外的人互相拜访，可以看到很多根本不会开到校内上的主页。你用汉语回复，下面给你聊起来的可能是香港仔，可能是台湾人。你用英语回复，说不定有比你英语用的更蹩脚的寂寞的北欧人来跟你搭讪。你感觉地球真的变成了地球村，你还没拉门走出去，别人就推门走了进来。</p><p>　　然后，它就没有了。起初，它的失踪激起了很大的声音，后来，声音就消失了。</p><p>　　多年前，我们也是可以登陆Twitter的。其实这个网站和微博一样，也不过是些信息流，刷上一整天，也不见得有什么用处。但至少，你可以以最快速度获取你想知道的任何新事，你会真正了解什么事情在全世界是流行的，而不是经过各种截图、翻译、转发，甚至曲解、断章取义、黑白颠倒的东西。你知道的是真相，赤裸裸的，也许有点太短的真相。但至少中间不会有无数人的加工与再加工，偏激、片面，就在这个过程中产生了，不管后来者有意还是无意。</p><p>　　然后，它就没有了。首先是它的本体没有了，然后它的模仿者也没有了，模仿者的模仿者也没有了。只剩一个模仿者的模仿者的模仿者，现在你每天能在上面看到无数广告。</p><p>　　多年前，我们也是可以登陆YouTube的。对于有的人来说，这个网站就是个大型优酷，当年有人信誓旦旦的说，没有YouTube，我们中国人会很快让优酷超过YouTube。可这么多年过去了，视频还是那么卡，内容还是那么垃圾，原创还是那么容易被盗窃，视频丰富度还是那么的可怜。在YouTube上，你能看到全世界最棒的手艺人，最逗乐的笑话，最天马行空的创意，最激荡人心的音乐，最美好的完美瞬间，可在优酷上，你想看一分钟视频，请先看半分钟广告。</p><p>　　哦，对了。Instagram，有些人可能感觉它和QQ空间也差不多。可我在上面关注了六百多个摄影师，它们都是顶好顶好的影像记录者，每天看他们的作品，我感觉到很幸福，那种即使没有到那里去，也身临其境的幸福。我还在上面认识了一个日本的爱自拍的帅小伙，一个爱喝酒的韩国大叔，一个十年前到过中国今天会在每张我发的紫禁城照片下点赞的美国大爷，一个美丽无比的俄罗斯妹子，我和他们基本上都难以交流，语言是很大的障碍，但几个简单的单词，心意也就到了，这种感觉，有时候比多年老友相聚还兴奋。因为这是人类不同族群自由交流互相沟通的过程，这种过程很神奇，真的很神奇。</p><p>　　可现在，它没有了，它之所以没有就因为在某个特定的时间你在搜索特定的词汇时，会搜出来特定的照片。虽然这么搜的人并不多，虽然看到的人也不会大惊小怪，也不会觉得天黑了，天亮了，天要塌了，天要变了。可它就是没了，Instagram，就这么没了。谷歌也是这么没的，Twitter也是这么没的，Facebook也是这么没的。不知道是什么人，在什么场合，说了什么话，下了什么决定。就要有超过十亿人像陷于哥谭市的孤岛里一样，看着一座又一座桥梁被炸掉，又被炸掉，又被炸掉，然后，就什么都没了。</p><p>　　我时常觉得悲哀，真的好悲哀，一个我根本不认识也不知道是谁的人，也许是一个群体，在不断抢走我身边的东西，而我却无能为力。我抱怨一声，他听不到，任何人都听不到。我怒吼一句，身边的大多数人却像看疯子一样的看着我。我哀嚎一声，这声音被阻碍在黑黑的幕墙以里。我发出尖锐的嘶吼，这声音传不了多远，就和我那被抢走的东西一样，消失了，不见了，就像从来没存在过一样。</p><p>　　对于本来就没存在过的东西，有谁又会觉得在意呢？那些本来拥有又被掠夺的人的哀愁，后来的人又怎么懂呢？我曾经是拥有一切的，我曾经是拥有世界的，我站在这片土地上，呼吸的是自由的空气，饮下的是自由的琼浆玉液。就在长的无法计数的时间里，我自由生命的一部分又一部分就这么被杀死了，突然就杀死了。可我还始终觉得，它们还奄奄一息的活着，就像它们是慢慢的死去的一样。</p><p>　　可它们终归是死了，而且随着它们的死，愈来愈多的事情慢慢的发生了，很慢很慢，几乎不被人察觉，可还是发生了。</p><p>　　没有谷歌，我可以用百度呀。可某些结果被越挪越后，越挪越后，最后就不见了。就像本来就不该搜出这个结果一样。</p><p>　　没有Facebook，我可以用校内呀。可你想发只有在Facebook上能发的文章，很快在校内上就失踪了。接着，校内变成了人人，话题变成了人人都关心的话题。大家都在抢着看星座、明星、八卦、娱乐。没有人会关心什么消失了，反正它们本来也没多少存在感。</p><p>　　没有YouTube，我可以用优酷呀。可你却经常只能在优酷上看到抄袭别人的作品，而且还不署名，而且还洋洋得意，而且还自我陶醉，就好像那个idea本来属于他自己一样。你看了还要惊呼，他是如此的有创意！好一个抄袭的创意，可你却不知道，因为你不知道这个世界上有个网站叫YouTube。</p><p>　　没有Twitter，我还可以用微博呀。可你想知道最近发生了什么，你搜的越勤快，越能看到越明显的“根据相关法律法规，相关搜索结果不予显示”。时间长了，你想，反正知道了也没什么用，不如不看了。</p><p>　　慢慢的，一扇又一扇的门关上了。今天你打开世界上最大的博客网站，发现它没了。明天你一看，世界上最好的设计师分享网站没了，一开始是刷新的很慢很慢，后来它就没了。过两天再一看，平常每天都会读两篇文章的媒体网站没了，那里的文章缤纷多彩，最后都变成了该页无法显示几个字。再过几个月，大学的网站不让上了，摄影师的网站不让上了，就连百度日本这种自家网站，也没了。</p><p>　　接着，漫画看不了了，接着，动画看不成了。接着，美剧英剧失踪了。下载美剧英剧的网站又又又失踪了。尊重正版，保护权益，行吧，然后字幕网站也没了。</p><p>　　游戏没了，你习惯性登陆的游戏网站，发现下载栏正在整治中。论坛关了，天天都在看的论坛，突然接到相关部门的电话，因为“报备问题”不让办了。个人网站，私人博客，对不起，说没就没有，你在上面存了多少多年辛勤耕耘的东西都没用。</p><p>　　你关注的人，有一天你登陆微博，发现他怎么好久都没说话了，然后你搜索了一下，发现他的账号不存在了，而且你搜他的名字，他的名字未予显示。</p><p>　　一盏一盏的灯，灭了。四面八方的光源，消失了。我们生活的五光十色的世界，变成了一片黑色。</p><p>　　天黑了，那么睡觉吧，但愿长醉不复醒。</p><p>　　最后，我们变成了一群做梦的人，这个梦的名字，叫根据相关法律法规，相关搜索结果不予显示梦。</p><p>　　作者：小海，来源：豆瓣网，<a href="http://www.douban.com/note/456932116/">原文</a>已被和谐</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OIer&#39;s News 【创刊期】</title>
      <link href="/archives/3790557036/"/>
      <url>/archives/3790557036/</url>
      
        <content type="html"><![CDATA[<h2 id="创刊期">创刊期</h2><h3 id="创刊期-1">创刊期</h3><p>大家坚定一个信念吧:</p><p><img src="https://i.loli.net/2019/03/16/5c8c92d2107f5.png" /></p><h2 id="我们是oier">我们是OIER</h2><h3 id="我们是oier-1">我们是O——I——E——R！</h3><p>我们是OIer， 所以我们 不用在跑道上挥汗如雨； 不用在球场上健步如飞； 更不用在没事的时候， 经受非人的体能训练……</p><p>但是， 我们却要把头脑 高速运转， 还要接受一大堆 大学生也只是 “了解即可”的知识， 把一个个抽象的问题 转化为一篇篇 优美的代码， 才能在F9按下以后 获得欢呼。</p><p>不要以为我们 机房里没有风吹， 没有日晒， 就比勤劳的体育生们轻松， 只不过是大脑和四肢 的区别罢了。</p><p>可是， OIer的寂寞和委屈又有谁能懂？ 自习课鏖战机房， 却被认为而是逃课上网； 为荣耀耽误考试去比赛， 却被认为是逃避。 体育的同学们虽然辛苦， 但在挥汗如雨的背后， 有人在喝彩鼓掌； 在风吹日晒的同时， 有粉丝在仰慕。</p><p>而我们呢？ 与UnAC较劲的时候， 只有那一遍遍的运行窗口， 知道我们的不屈； 刷题的漫漫长夜， 只有陪伴我们的笔记本电脑， 知道我们的不懈； 在自习课别人学习的时候， 只有板砖般的算法导论， 知道我们的进取； 在机房泡得抢不上饭的时候， 只有五毛一包的干脆面， 知道我们的执着……</p><p>没有人会理解， OIer见面， 除了程序、算法之外 别无他言。 我们的世界里， 从来不会有游戏、歌星的出现。 这不是被家长逼迫的“小三门”， 是我们的兴趣， 我们的爱好， 乃至我们的事业。</p><p>每一个OIer都幻想着 自己脖子上可以 挂上一块沉甸甸的金牌， 而不是 万恶的应试教育的枷锁。 没准哪个OIer， 就是下一个艾伦•图灵， 挑战头脑的极限， 去做最不平凡的自己。。。。。。。</p><h4 id="版权">版权</h4><figure><img src="https://i.loli.net/2019/03/23/5c95ec9f01e9f.png" alt="版权.PNG" /><figcaption aria-hidden="true">版权.PNG</figcaption></figure><h3 id="一天">一天</h3><p>一天,我听我同学说:</p><p>“有一群人,<del>她</del>们天天不分昼夜的从床上爬起来,说什么“0点打卡祭”什么鬼的。</p><p>每天坐在电脑前敲着一些奇奇怪怪的看不懂的鬼东西。</p><p>然后为了一个看不懂的绿色框框和一个<span class="math inline">\(\color{green}AC\)</span>不分昼夜的坐在电脑前。</p><p>还有,天天坐在电脑前不开一个游戏!</p><p>开什么叫做LuoGu啊,CSDN啦,博客园什么的鬼网页。</p><p>以及……</p><p>真搞不懂！”</p><p>我笑了,这不就是我吗?</p><p>我转身归去。</p><p>他叫道:“喂！别跑！”</p><p>我没有停,只静静地留下一句:“有朝一日,你也会像他们一样,而我,已经是了……”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>写代码的小女孩</title>
      <link href="/archives/1301002429/"/>
      <url>/archives/1301002429/</url>
      
        <content type="html"><![CDATA[<p>　　天冷极了，下着雪，又快黑了。这是NOIP的前夜。在这又冷又黑的晚上，一个衣衫破烂的小女孩在机房敲着代码。她从班里逃出来的时候还拿着一本算导，但是有什么用呢？那是一本很破旧的书——那么大，一向是她妈妈垫桌角的。她默写SPFA的时候，年级主任突然冲进机房，吓得她把算导都丢掉了。书叫一个学数竞捡起来拿着跑了。他说，他可以用那本书当草纸，证明切比雪夫定理。</p><p>　　小女孩只好自己写二叉堆，一双小脚冻得红一块青一块的。她面前的草纸堆得满满的，上面全是DP转移方程。这一整天，没有一个OJ让她AC一道题，她已经交了32遍采药了。</p><p>　　可怜的小女孩！她又冷又饿，浑身战栗地写着二叉堆。CRT显示器发出的光落在她的枯黄的长头发上，那干枯的头发打成卷儿披在肩上，看上去就像二叉树，不过她没注意这些。每个显示器里都透出光来，机房里飘着一股CPU发糊的怪味，因为这是NOIP前夜——她可忘不了这个。</p><p>　　她在主函数前面停了下来，蜷着趴在键盘上。她觉得更冷了。她不敢回家，因为她还没调完二叉堆，没写对一个DP方程，教练一定会骂她的。再说，换成别的数据结构，一样写不出来。这些题都太水，虽然神犇都写过题解了，但是题解上一般都只有三个字：傻X题。</p><p>　　她几乎绝望了。啊，哪怕一个函数不会RE，对她也是有好处的！她每写一遍程序，跑出来的结果就不一样，要是她有数据，她就知道哪一个程序是算对了的。她得不到数据了，因为机房上不去网了，全校的网速都让隔壁的年级主任拿来下小电影了。如果能保证下一个程序能AC，她就敢再写几十KB的代码，但是她是不敢啊，她怕又算出来一个奇葩的结果来。 　　她新建了一个cpp重写了程序。编译通过了了，样例过了。这次，她感觉自己站在IOI的考场中AK。学校的大门上，贴着“我校学生以国际金牌向110周年校庆献礼”的条幅。在班级内的非诚勿扰中，全班男生都给她留了灯。这时候，程序又RE了，她面前只有cmd上的黑底白字。</p><p>　　她又写了一道模拟。这一回，她坐在美丽的二叉堆下。这棵二叉堆，比她在丽洁代码中看到的常数还要小，还要短。眼前是许多优美动人的ASCII码，那些都是她写的程序，各种可爱的指针在跳跃着，满世界都是系统栈，都在向她眨眼睛。小女孩向眼前的系统栈伸出手去。这时候，眼前的ASCII码还在，条幅还在，指针还在，年级主任还是和蔼地微笑着。只见那些代码那些指针越升越高越升越高，最后成了在天空中闪烁的星星。有一颗星星落下来了，在天空中划出了一道细长的红光。</p><p>　　 “有一个什么人快要死了。”小女孩说。唯一疼她的学姐保送之前告诉过她：一颗星星落下来，就有一个灵魂要到上帝那儿去了。</p><p>　　她notepad++中又写了一个快排。这一回，她把能用的IDE都用了。学姐出现在亮光里，是那么温和，那么快乐。 “学姐！”小女孩叫起来，“啊！请把我带走吧！我知道，系统栈一溢出，您就会不见的，像那校门的条幅，浮点数的精度，循环队列的空间一个样，就会不见的！”</p><p>　　她赶紧编译了5KB的高精度模板，要把学姐留住。一大把程序发出强烈的光，把机房照得跟白天一样明亮。学姐从来没有像现在这样温柔，这样美丽。她把小女孩抱起来，搂在怀里。她们俩在光明和快乐中飞走了，越飞越高，飞到那没有DP，没有图论，也没有数据结构的地方去了。</p><p>　　第二天清晨，这个小女孩坐在机房里，两腮通红，嘴上带着微笑。她死了，在NOIP的前夜死了。NOIP Day1的太阳升起来了，照在她小小的尸体上。小女孩坐在那儿，显示器上还有一坨编译过的代码。</p><p>　　“她想好好复习复赛。”人们说。谁也不知道她曾经看到过多么美丽的东西，她曾经多么幸福，跟着她学姐一起走向新世界的幸福中去。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>摘录自「SCP基金会」中的一些句子</title>
      <link href="/archives/2032683215/"/>
      <url>/archives/2032683215/</url>
      
        <content type="html"><![CDATA[<blockquote><p>已死之人，向赴死者致敬。</p><p>我想要宪法赋予我的那个世界。</p><p>大概你的确是死了，但我们还在前行，消逝的能够被盖棺定论，而还存在着的仿徨呐喊抗争着，却在眨眼就会丧命，空中会窜出无敌吃人大蜥蜴，永远有儿童和女孩在惨叫的世界的黄昏里，拾起那一朵清晨看见过的花。</p><p>当你们的时代过去，请继续送出信息，好让下一个声音响起来对抗黑暗。</p><p>他们很快乐，至少在最后之前。不是所有的船都得在黑夜中航行。</p><p>你已经做完了你必须去做的事，现在，请休息吧，晚安。</p><p>我会使得我们的宇宙成为一个值得拯救的宇宙的。</p><p>她死在一个遥远的地方，脸上带着笑容，手里握着武器，身边围着敌人。她向我们展示了一个真正的战士应该是什么样子。</p><p>我看到一片广阔的海岸，在我们面前展现的事物超越头脑所能理解的范畴，沙滩上的每一粒沙子，每一滴水和空气分子都是在讲述一个故事。每个都是要被唱响的歌。他们每个人都充满生机，笑声，苦难和仇恨。他们都是一样的，即使他们都是不同的。</p><p>我爱你，红。我爱你，安娜。五年，十一个月，二十天。</p><p>那些受影响的人，是因为他们失去了他们内心世界的孩子。他们不能只看到最表面的东西，他们把自己的观点注入一切然后从中获取乐趣。</p><p>神破碎自己，我们才得完整.</p><p>所以我央求你：这—真知—绝不能被抹去、遗忘。这不是收容。这是疯狂。</p><p>大概人们能哀叹于你的不幸，但没人有资格评论你为"不争"。在这个遍布异常的世界里，努力在绝大多数人眼前拉上一张布帘。从无数扭曲而血腥的异常下保护绝大多数人类的我们，可能面对着每天都有值得尊敬的人因异常而死亡的不幸，但也能在和这一切抗争着的同时，期冀着一个立于晨间，蝴蝶环绕翩翩飞舞的世界。</p><p>他想起内布拉斯加的麦田。</p><p>用伤害无辜者来掩盖自己的错误是心虚的体现，也永远掩盖不了。</p><p>他们也一样。</p><p>根据完整版资料我发现，601被姜特工发现的地方，就在那段时期执行流产手术频率最高的医院原址，更精确一点说，就在那个医院的化粪池原址。那一百天内被强制流产或者“生下来就掐死”的数以万计的婴儿，他们本可能成为你，可能成为我，可能成为这个世界上的任何一个人和任何一个人的爱人，但他们的生命还没开始，就被埋葬在了那个化粪池。</p><p>……是神又怎么样呢。这个国家最早的传说里并没有神的席位，取而代之的是被山挡住就决定挖山的农夫，被海淹死就去填海的小女孩，被太阳炙烤便搭箭指向太阳的猎人，或者从神那里偷来土壤治水的老人。“王侯将相，宁有种乎”，没错吧？我们的历史，从来不是由神兽或妖，而是由普通人来书写的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解 P1226 【【模板】快速幂||取余运算】</title>
      <link href="/archives/3299158642/"/>
      <url>/archives/3299158642/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p><a href="https://www.luogu.org/problemnew/show/P1226">洛谷P1226</a></p><h1 id="说明">说明</h1><p>看到题解里貌似并没有Python的题解，我来发一个，共两行。</p><p>众所周知，为什么有时候洛谷er们要用Python呢？因为Python里已经包装了很多算法，用在OI中基本上等于打游戏时开外挂。虽然</p><p>对于这道题，Python 3中有一个数学函数pow()，它在help()函数中的说明是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pow</span>(x, y, z=<span class="literal">None</span>, /)</span><br><span class="line">    Equivalent to x**y (<span class="keyword">with</span> two arguments) <span class="keyword">or</span> x**y % z (<span class="keyword">with</span> three arguments)</span><br><span class="line"></span><br><span class="line">    Some types, such <span class="keyword">as</span> ints, are able to use a more efficient algorithm when</span><br><span class="line">    invoked using the three argument form.</span><br></pre></td></tr></table></figure><p><code>x**y % z</code>，这正好就是这道题所用到的算法，所以直接调用<code>pow(b, p, k)</code>就OK了。一般来说，编程语言本身的库函数都会往死里优化，基本上不用担心时间复杂度的问题。（除了某些特别坑的）</p><p>最后要注意的一点就是，很多人提交Python都莫名RE，原因是Python 3的<code>input()</code>函数返回的是字符串，必须用<code>int()</code>转换为整数。如果一行有多个数字，则调用<code>split()</code>方法分割成多个字符串。</p><p>上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">input</span>().split()</span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>] + <span class="string">&#x27;^&#x27;</span> + a[<span class="number">1</span>] + <span class="string">&#x27; mod &#x27;</span> + a[<span class="number">2</span>] + <span class="string">&#x27;=&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">pow</span>(<span class="built_in">int</span>(a[<span class="number">0</span>]), <span class="built_in">int</span>(a[<span class="number">1</span>]), <span class="built_in">int</span>(a[<span class="number">2</span>]))))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「文章转载」赛博空间独立宣言</title>
      <link href="/archives/142292747/"/>
      <url>/archives/142292747/</url>
      
        <content type="html"><![CDATA[<p>　　工业世界的政府，你们这些肉体和钢铁的巨人，令人厌倦，我来自赛博空间，思维的新家园。以未来的名义，我要求属于过去的你们，不要干涉我们的自由。我们不欢迎你们，我们聚集的地方，你们不享有主权。</p><p>　　我们没有民选政府，将来也不会有，所以我现在跟你们讲话，运用的不过是自由言说的权威。我宣布，我们建立的全球社会空间，自然地不受你们强加给我们的专制的约束。你们没有任何道德权利统治我们，你们也没有任何强制方法，让我们真的有理由恐惧。</p><p>　　政府的正当权利来自被统治者的同意。你们从来没有要求过我们的同意，你们也没有得到我们的同意。我们没有邀请你来，你们不了解我们，不了解我们的世界。赛博空间不在你们的疆界之内。不要认为你们可以建造这样一个疆界，好像建造一座公共建筑。你们没有这个能力。这个疆界是一件自然行为，它将从我们的集体行动中生发出来。</p><p>　　你们从来没有参加过我们的大会，你们也没有创造我们的市场财富。对我们的文化，我们的道德，我们的不成文法典，你们一无所知，这些法典已经在维护我们社会的秩序，比你们的任何强制所能达到的要好得多。</p><p>　　你们说我们有问题，你们要解决这些问题。你们用这个借口侵犯我们的领地。你们所宣称的这些问题，许多都不存在。真正冲突出现的时候，不公正出现的时候，我们自己会鉴定它，用自己的方式解决它。我们正在形成我们自己的社会契约。治理将出现，但根据的是我们世界的情况，不是你们的。我们的世界，是不同的。</p><p>　　赛博空间由交易、关系和思想本身构成，它们像一道永恒的波浪，在我们的交流之网上部署着。我们的世界无处不在，又无处可寻，我们的世界不是肉体存在的世界。</p><p>　　我们正在创造一个新世界，人人都可以进入这个世界，而不必考虑由种族、经济力、武力、出生地而来的特权或偏见。</p><p>　　我们正在创造一个新世界，人人、处处可以表达他或她的信仰，无论这种信仰是多么古怪，而不再害怕被强制沉默或强制一律。</p><p>　　你们关于财产、表达、身份、迁徙的法律概念及其关联对我们不适用。这些概念建立在物质的基础上，我们这里没有物质。</p><p>　　我们的身份不涉及肉体，所以和你们不一样，我们不能通过肉体的强制来获得秩序。我们相信，我们的治道将从伦理、明智的自我利益和公益中产生出来。我们的身份可能分布在你们许许多多的法律管辖中。我们全部的立宪文化能够普遍认可的唯一法律就是这样一个法则：己所不欲，勿施予人。我们希望能在这个基础上确立我们特殊的解决方案。但是我们不能接受你们企图强加给我们的解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS-over-HTTPS(DoH)简析与配置</title>
      <link href="/archives/2251452003/"/>
      <url>/archives/2251452003/</url>
      
        <content type="html"><![CDATA[<p>本文同步发布于 <a href="https://keepthethink.github.io/archives/2251452003/">Heliumの博客</a>，到我的博客阅读体验更佳QwQ</p><h1 id="dns是什么">DNS是什么</h1><p>DNS（Domain Name System）是一项网络服务，用途是对全球各个网站的域名进行解析。如果听不懂上面这句话也没关系，接下来会讲解。如果你是网络方面的大牛可以直接跳过或关闭此网页。</p><h2 id="简明易懂的dns">简明易懂的DNS</h2><p>举个例子，从前有个叫小明的人（目测此人已累死），开了一家商店。一开始顾客要去购物时,就直接去商店里买。</p><p>但由于网络环境的复杂性，让顾客直接记住地址是不太可能的。（你试试看？）于是就有人动了脑筋，推出了一样类似DNS的服务：你只需要说出地点（小明杂货店），服务商就会开车送你去目的地。</p><p>很多大公司实际上都推出了这份服务，例如阿里，百度，谷歌，Cloudflare等。</p><p>实际网络中的DNS，则是向服务器询问域名，而服务器返回IP地址。</p><p>顺便推荐几个质量好的良心DNS如下：</p><h3 id="cloudflare-dns">Cloudflare DNS:</h3><p>1.1.1.1, 1.0.0.1</p><h3 id="google-public-dns">Google Public DNS:</h3><p>8.8.8.8, 8.8.4.4</p><h3 id="opendns">OpenDNS</h3><p>208.67.222.222, 208.67.220.220</p><h2 id="dns查询">DNS查询</h2><p>看到这里你可能有疑惑了，难道每一台DNS服务器都储存了很多IP地址和域名的对应吗？不是。一这很浪费空间，二这样很难更新。</p><p>以我的博客地址<code>keepthethink.github.io</code>为例，当你输入地址后：</p><p>1.你的电脑首先会去询问DNS服务器；</p><p>这个“DNS服务器”可能在任何地方，可能就在你家的路由器上，也有可能在万里之遥的灯塔国QwQ（如果你是非酋</p><p>当然，一般来讲你的路由器上不会真的有一个DNS服务端，如果你在本地登录912.168.0.1或192.168.1.1，你就会看到在“DNS”设置那一栏会有你的ISP的DNS地址（当然，如果你想把它换成公共DNS也可以，但要为你自己的网速负责。）</p><p>2.DNS服务器询问所谓“根服务器”；</p><p>根服务器询问.io域名的权威服务器；</p><p>.io域名的权威服务器询问.github.io域名的权威服务器;</p><p>.github.io域名的权威服务器将IP告知你的电脑；</p><p>OK</p><p>（这套措施实在是找不到合适的比喻，看不懂就跳过吧。）</p><h2 id="注意事项">注意事项</h2><p>如果你访问的是一些比较国际化的网站，而且还使用了国外的DNS服务器，有可能会会给你分配个国外的IP地址。</p><p>举个最基础的例子：Hexo博客在注册网址时，进行的国内外分流。这是不排除某些睿智国外DNS不管三七二十一给你个国外地址的情形。</p><h2 id="dns缓存">DNS缓存</h2><p>这么干，空间的确节省了很多，但效率显然就更慢了。所以，DNS服务器中一般有个“缓存”，当你重复询问同一个网址时，直接找出缓存记录并答复。当然，每个一定的时间会更新缓存。</p><p>既然这套措施已经很完美了，那DoH是干嘛的？别急，马上就讲。</p><h2 id="dns劫持与http劫持">DNS劫持与HTTP劫持</h2><h3 id="dns劫持当dns不那么老实">DNS劫持：当DNS不那么老实</h3><p>打个比方：</p><p>从前有个叫小刚的，他也开了家杂货店；</p><p>小刚发现小明的杂货店有很多客户，分外眼红，便拿钱贿赂了DNS服务商，于是，当顾客要求DNS服务商将其带到“小明杂货店”是，DNS会不管三七二十一将其带到“小刚杂货店”。在网络中，则是DNS服务器故意给出错误的IP地址。</p><p>这显然是无计可施的，一般来说，遇到这种人品烂的掉渣的服务商，最好的办法就是换一家，好在这年头网络条件不错，大多数DNS都不搞这种事。</p><p><strong>但是</strong>，对于DNS劫持，刚才讲的一种情况并非最常见的，最常见的事下面这种：</p><p>假设只有服务商A收了贿赂，而服务商B没有。当你向DNS服务商B打电话时，你的<strong>电话服务商</strong>将其转接到服务商A，那你就前功尽弃了。唯一的方法是使用DNS-over-HTTPS，后面会讲解。</p><h3 id="http劫持当isp不那么老实">HTTP劫持：当ISP不那么老实</h3><p>假设你向DNS服务器打了个电话，“我要去小明杂货店。”结果你的电话服务商窃听了这句话，得知了你的行程；甚至将其修改为“我要去小刚杂货店。”，然后你就不明不白的被带到了另一个地方。</p><p>在这种情况下，你的DNS服务商是老实可靠的，但你的ISP（网络服务提供商）则不那么可靠。当然，一般的ISP并没有那么猖狂，他们最多不过是往你身上塞几张奇♂怪♂的广♂告♂（想必大家都有这样的经历。）你有时候会不会发现你看到的广告就是最近曾经关注过的事物？</p><p>你也许会说，可以修改DNS来解决这个问题，但如果你的ISP让 Google Public DNS 跳转到 <em>.</em>.<em>.</em> 之类与其同流合污的DNS地址怎没办？图样图森破。</p><p><strong>注意</strong></p><p>有哪些进行HTTP劫持的ISP？基本上都有：移动，联通，电信，天下乌鸦一般黑，呵呵。 一个极其明显的例子如下：</p><figure><img src="https://i.loli.net/2019/04/26/5cc2c1cf0d688.jpg" alt="yunyingshangjiechi04.jpg" /><figcaption aria-hidden="true">yunyingshangjiechi04.jpg</figcaption></figure><p>这种劫持的关键在于，DNS服务器与你之间的链接为“明文传输”，而非“加密传输”。这就导致每一个环节上的人都能随意修改你的链接。幸运的是，在生产力高度发达的9102年，加密技术早已像烂柿子一样成熟了，如HTTPS。</p><h1 id="doh的具体原理">DoH的具体原理</h1><p>DoH的具体原理其实就是在DNS外面套一层HTTPS。（而且更慢了）即流程变成了</p><blockquote><p>你的电脑 -&gt; DoH服务器 -&gt; DNS服务器 -&gt; DoH服务器 -&gt; 你的电脑</p></blockquote><p>以上流程中的一个箭头代表一个HTTPS加密链接，使得该过程中的所有流量皆受到强加密，这样一来，除非拖出量子计算机或智子，否则绝无可能被破解。</p><p>（当然，如果HTTPS本身出现漏洞，流量自然就会被破解。但这样一来所有与网络有关的事务都会彻底崩溃，不多你一个。）</p><h2 id="提示">提示</h2><ol type="1"><li>本人电脑为macOS + Firefox，亲测有效。</li><li>新疆OIer会因为某些原因而无法使用DoH。</li></ol><h2 id="在firefox浏览器中体验doh">在Firefox浏览器中体验DoH</h2><p>首先，把你的Firefox Quantum更新到最新版。（废话）</p><p>点击右侧的“菜单”，就是那个三条横线的图标；</p><p>在菜单里点击“首选项”；</p><p>进入“常规”选项；</p><p><img src="https://keepthethink.github.io/images/Jietu20190416-142149@2x.jpg" /></p><p>滚动页面到最下方，选择“网络设置”；</p><p><img src="https://keepthethink.github.io/images/Jietu20190416-142524@2x.jpg" /></p><p>在弹出窗口的最下方选择“启用基于HTTPS的DNS”，点击“使用默认值”即可。</p><h2 id="在google-chrome中体验doh">在Google Chrome中体验DoH</h2><p>遗憾的是，直到这篇科普写完时，Chrome仍然不支持直接配置DoH。如果你希望使用Chrome，请参见下面的教程。</p><h2 id="在windows上使用doh">在Windows上使用DoH</h2><p>想再Windows上使用DoH？直接安装Firefox不就好了？</p><p>当然，如果你是一名狂信徒，非要使用其他浏览器，我这里倒是有个思路：</p><ol type="1"><li><p>买一台服务器，系统是Linux。</p></li><li><p>在服务器上重复“在Linux中体验DoH”中的方案</p></li><li><p>把你的DNS服务器地址设为你的服务器的公网IP地址</p></li></ol><p>当然，可能你自己得花点钱。</p><h2 id="在macos中体验doh">在macOS中体验DoH</h2><p>首先，为了安装必要的组件，我们首先要安装Homebrew软件包管理器。在终端中输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><p>安装完成后，输入以下命令安装cloudflared：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cloudflare/cloudflare/cloudflared</span><br></pre></td></tr></table></figure><p>等待安装，这段时间内你可以去换（chuan）件（shang）衣（nv）服（zhuang）。</p><p>然后，我们要修改一下配置文件，新建一个文件<code>/usr/local/etc/cloudflared/config.yaml</code>，输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy-dns: true</span><br><span class="line">proxy-dns-upstream:</span><br><span class="line">  - https://1.1.1.1/dns-query</span><br><span class="line">  - https://1.0.0.1/dns-query</span><br></pre></td></tr></table></figure><p>（顺便提一下，如果1.1.1.1和1.0.0.1两个都连不上，可以把网址删除换成<code>https://dns.google.com/experimental</code>试试，</p><p>好了不要吵了我知道这是天方夜谭）</p><p>配置结束，启动服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cloudflared service install</span><br></pre></td></tr></table></figure><p>QED！现在你的电脑已经成了一台DoH服务器，高兴的话你也可以把它当作DNS服务器来用。打开 系统首选项 -&gt; 网络 -&gt; 高级 -&gt; DNS，在列表的最顶端添加 127.0.0.1 即可。</p><h2 id="在linux中体验doh">在Linux中体验DoH</h2><p>同macOS，但安装时一定要记得加PPA源～</p><h2 id="doh的使用测试">DoH的使用测试</h2><p>用dig命令测试一下，发现DOH的使用体验还是相当不错的。对域名<code>www.google.com</code>的查询结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ dig @127.0.0.1 www.google.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; @127.0.0.1 www.google.com</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 48175</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1</span><br><span class="line"></span><br><span class="line">;; OPT PSEUDOSECTION:</span><br><span class="line">; EDNS: version: 0, flags:; udp: 1452</span><br><span class="line">; PAD: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 (&quot;.................................................................&quot;)</span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;www.google.com.INA</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">www.google.com.66INA216.58.194.196</span><br><span class="line"></span><br><span class="line">;; Query time: 165 msec</span><br><span class="line">;; SERVER: 127.0.0.1#53(127.0.0.1)</span><br><span class="line">;; WHEN: Tue Apr 16 16:33:38 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 142</span><br></pre></td></tr></table></figure><p>注意最下方几行：165毫秒的查询时间不可谓不快。</p><h1 id="总结">总结</h1><p>事实上，如果你饱受各种小广告弹窗之苦，DoH是个不错的应对措施；</p><p>如果你的运营商直接进行DNS劫持，建议投诉或诉诸法律；</p><p>如果你的运营商进行HTTP劫持，推荐DoH。</p><p><strong>点个赞再走吧(๑•́₃ •̀๑)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「文章转载」他译作“维基”的那个网站消失在竹幕后</title>
      <link href="/archives/2552852216/"/>
      <url>/archives/2552852216/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文放弃一切经济权利，各网站、公号和其他各类载体可在保持原文完整的基础上自由转载。</p></blockquote><p>这个周末，维基百科终于整体离我们而去。它的404，意味着13亿人再次被隔离于一个“普世产品”之外。</p><p>Pingwest创始人托马斯·骆在山寨发布会群里分享了他勤奋更新的微信公众号文章，<a href="http://mp.weixin.qq.com/s?__biz=MzAxMzc1NTkwNQ==&amp;mid=400989696&amp;idx=1&amp;sn=d36df590742255b0cb95d054376149d2&amp;scene=25&amp;srcid=1206Z80ZDGf1hSTlJarvNJ9i#wechat_redirect">《自由和美好的事物总是戛然而止：比如约翰 列侬和维基百科》</a>（点击链接可以访问过去，做好他的公众号无所不谈的准备，虽然都挺有趣的）。</p><p>知乎讨论这个问题的500多个回答在昨天上午戛然而止，消失无踪。托马斯的这篇文字也不知道能生存到何时。互联网这片沃土在别的地方长出了很多参天大树，在中国却总像城市人行道水泥砖之间的野草，顽强地露头，被碾压而过；又螳臂挡车地冒头，再被碾压。周而复始。</p><p>在这些野草之中，我翻出了2010年时采访第一个中文维基百科词条创建者、“维基”这个译名的提出者的随笔。当他以及最早期的维基中文十三人确定这个译名并胼手砥足地一条一条建立起中文维基时，未必能看到这灰暗的未来。但他接受采访时的淡然和话语间隐隐透露出的理想主义，却正是这些年来激励人们前赴后继地传播光明的原动力。</p><p>这篇东西同样不知道能存活多久，所以本文开头我就放弃了关于本文的一切权利，希望尽量多的自媒体、网站和无处不在的SEO页能收录它、转发它，让人知道中文互联网世界一直燃烧不灭的微弱火种。即使不转发，也可以把它发到邮箱里，存到梯子通达的墙外，在隐秘的一个个圈子里流传。在历史无法书写之处，我们口口相传。仿佛华氏451那个时代，消防员以焚书为业；但热爱文字的人们仍然找到办法，他们分工合作，背下了每一本人类历史的名著；他们</p><blockquote><p>跟普通人没什么两样，像是跑完了一段长路，经过漫长的寻觅，见过美好的事物被焚毁，如今已垂垂老矣，聚在一起等待曲终人散，灯干油尽。他们并不肯定自己脑中所记载的一切，能使未来每一个日出发出更纯净的光辉，他们对此并无把握。但他们确知，那些书储存在他们平静的眼眸之后，完好无缺地等待着将来某一天，那些手指干净或肮脏的读者再来翻动。</p></blockquote><p>以下为原文。斜体字为今日所加。</p><p><strong>那些改变中国互联网的小人物之一：维基百科命名者苑明理</strong></p><p>2002年10月24日，苑明理（维基用户名 mountain）撰写了第一个具有中文内容的维基百科主页。</p><p>此前，或许有其他用户也曾想尝试，但当时的维基主页不支持中文输入。借由工具软件，mountain巧妙地绕过了这个障碍。维基媒体基金会发现了这个微小但意义深远的变化，三天后，中文维基百科有了自己的服务器、域名，同时，后台程序也升级为支持中文输入的版本。世界上最大的百科全书与使用人口最多的语言成功握手。作为中文维基百科的第一位参与用户，苑明理启动了这一进程。</p><p>在完成了第一篇中文条目“计算机科学”后，苑明理又提出了中文命名的提案。尽管已经有了中文内容，但这个百科全书的命名仍然用英文名字Wikipedia。 当时正在北大读应用数学研究生的苑明理引经据典，提出以“维基百科”作为Wikipedia的中文名称。苑明理向淼叔解释了当时的思路：“维”的本意是系物的大绳，由“纲举目张”转引到“网”的含义。而在此前，“万维网”作为WWW流传最广中文译名，已经认可了“维”与互联网的对应；“维基百科”，基于互联网的百科全书，这个译名成为Web2.0概念中音义俱佳的翻译，其流行程度仅次于“博客”（但后者并未得到普遍认同，现在仍有大量业者坚持称为“网志”）。一年之后的2003年10月，中文维基的13个管理员用户投票决定正式中文名，其中有9人选择了“维基百科”。在今天看来，这次投票的意义堪比埃尔隆德会议。</p><p>发布首个维基百科中文条目，以及命名维基百科，这两项里程碑式工作，完成任何一项都可以在IT史甚至学术史上留名；但苑明理并不认为这些有多么重要。 “我不做，总有人会做。当时国内已经有一些人在英文维基上学习了。至于命名，其实当时参与投票的其他译名也有很不错的”。很难说这是一种故作姿态的谦虚， 因为相比浩淼如海的维基百科，无论是参与者，还是使用者，都会为海量的知识目眩神迷。</p><p>Wikipedia 自2001年在美国建立以来，迄今已经拥有1200万个以上的条目，最大的英文维基拥有316万个条目（大英百科全书不到七万条）；中文维基自建立以来， 也已经拥有将近30万个条目。截至2007年10月，维基百科已经经历了四亿次编辑。相对地，维基的注册用户达1500万之众——要知道，维基百科的查阅甚至修改都无需注册。</p><p>在这些数据背后，是仍然不断汇聚而来的知识，更多的编辑者，更多的条目，更多次搜索。苑明理参与维基社区时，中文用户寥寥，条目也以编译英文条目为主。“维基”之译名，自提案而至表决，长达一年。倒并非是争论激烈，而是一开始人数太少，不好遽然而定。“中文维基属于所有中文用户，人数太少时定下名字，对其他人不是很不公平。”</p><p>苑明理坦承，维基所倡导的民主与自由，对其自身影响很大。维基的原则是每一个人均可参与编辑，人人平等；由于每一个人均可以编辑条目、增删内容，因此所有用户在维基面前平等。即使作为开创者和管理员，苑明理也并未享有太多的特权。管理员所作的，更多是维持编辑秩序，锁定或清理恶意编辑者。而对条目的修改，管理员与普通用户权限并无不同，都需要反复讨论、辨析，表明观点。这使维基的管理员远远不像一些论坛版主那样跋扈，所有参与者的讨论反映到条目上，也显得冷静而客观。</p><p>早期参与编辑维基的用户，素质都较为卓越。“我从他们身上学到了很多。”苑明理很怀念一位新加坡籍管理员，后者致力于中文维基社区规则的建立与完善。维基开放给所有用户编写，汇聚知识领域的微力量，带来的副作用可能是信息杂化，和编辑者之间的争吵。既然管理员不能以权威压人，此时便需要依规则调解。另有管理员引入“共识”的标准，成为解决条目争议的重要规则。</p><p>“早期中文维基的管理者贡献良多。”苑明理回忆。他们贡献的不止是中文条目，更在于及时将中文维基解决争端、协调众声的机制和规则建立起来。作为一个参与者几乎无限的项目，维基能够在高速增长的同时，仍维持条目令人惊奇的准确与中立，规则之完善与争端调解机制的建立，功不可没。</p><p>在飞速发展的同时，维基百科也并非没有遇到障碍。尽管拥有世界上最高超的调和艺术和顶尖人才，但维基仍然常常爆发“编辑战”，即各位编辑者就词条的表达与取舍进行的激烈论战。较为典型的是，伊朗现任总统内贾德的词条，从他还是一个默默无闻的候选人时就出现在百科页面上，随着他仕途的通达和不断发表的争议性言论，维基内部也一次次爆发论战。他的哪些言行需要载入页面，哪些判断适合进入百科，“每一个字上都展开了殊死搏斗”。</p><p>内贾德代表了世界上所有尖锐的冲突：东方主义下的东西方冲突，文明冲突论下的伊斯兰文明与基督教文明冲突，政治学意义下的学者与政客的冲突。反映到维基百科上，就是长达三年的争吵，三个调解员因此去职，单一个积极用户就作了近400次修改；最后完成的词条力争记录了内贾德的言论，却仍然被指责为“过长，但没有信息量”。筋疲力尽的维基人们告诉后来者：“可以重新开始讨论……可是我们已经没有精力再参与”（本段内容参考了南方都市报的相关报道）。</p><p>中文维基百科面临相似的困扰，据mountain回忆，有时他甚至声称要因此退出维基项目。与大部分争吵的原因不同，对内容的讨论主要围绕中立原则，只不 过各方对“中立”的理解不同。维基的词条就是在这样严格得近乎苛刻的审查中诞生，每一个词条看上去都冷淡，平静，客观，不带任何感情色彩和倾向。维基的编写是天下大同的缩写，呈现出来的结果却是万籁俱寂的白描。“维基最大的特点，就是在规则之下的众声喧哗，直到共识。”苑明理总结。</p><p>除了内容上的争论，中文维基还面临许多“特色国情”的挑战。作为百科全书，基本目的就是无所不包，除了“根据当地的法律法规不予显示”的内容。但是，当法律法规并未明确规定内容的界限时，无所不包就成为一种冒险的行为。中文维基百科自2005年后，访问上始终存在一些滞涩。有时一些页面会载入后无法显示，有 些时候则干脆整站无法访问。在这段时间，百度百科、互动百科等国产百科开始占领市场。</p><p>在注意力就是资源的互联网，苑明理对这种蚕食并不是太在意。“维基百科不会死，其他山寨版不尊重版权，随意拷贝媒体内容，没有真正创作和学习的乐趣，对维基百科不会形成真正威胁。”似乎是为了证明这一点，科普作家方舟子在博客上发文，痛斥国内某搜索引擎的在线百科不尊重版权，随意剽窃他文章的内容，还设置了繁琐的投诉程序。</p><p>“海纳百川，有容乃大”是中文维基百科的副标题，苑明理似乎从这句话中获得了更多从容的力量。“英文维基不会死，维基用户数量就有了保障。竞争再激烈，时间总会说明一切。坚持中立、包容和分享知识的乐趣，维基精神就不灭。”在关于维基你或许不知道的十件事这个条目下，最后一条就是“维基是一个百年大计”。既然能长寿到所有敌人都死去，那还有什么值得焦躁和忧愁呢？</p><p>“维基汇聚了所有普通人的力量，分享着所有用户的知识，并以此为基础记录人类文明的成果。”苑明理终于谈到了自己的理想：“这就是我想要的，世界公民。”</p><p>补记：苑明理已经于三年前离开了他服务多年的国际IT巨头。现在他在知春路的一家创业公司中埋头做一款叫做“彩云天气”的产品。除此之外，生活没有任何变化。</p>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解 P1003 【铺地毯】</title>
      <link href="/archives/1438989892/"/>
      <url>/archives/1438989892/</url>
      
        <content type="html"><![CDATA[<h1 id="说明">说明</h1><p>看标签 <strong>枚举，模拟，暴力</strong>。</p><p>很容易想到开一个大小N * N 的二维数组，然而数据范围是0 ≤ N ≤10,000</p><p>数组大小：10000 * 10000 = 100000000 Byte = 100000 KB = 100MB</p><p>刚好跨过了RE与MLE的红线。</p><p>另外一种方法是用四个数组来记录长方形的四个参数，再扫一遍检查最上面的地毯。</p><p>亲测，完美AC。</p><h1 id="代码">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span> + <span class="number">5</span>;<span class="comment">//程序里出现幻数可不是好习惯哦~</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[MAXN], b[MAXN], g[MAXN], k[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a[i], &amp;b[i], &amp;g[i], &amp;k[i]);<span class="comment">//输入</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= a[i] &amp;&amp; y &gt;= b[i] &amp;&amp; x &lt;= a[i] + g[i] &amp;&amp; y &lt;= b[i] + k[i]) &#123;</span><br><span class="line">            ans = i + <span class="number">1</span>;<span class="comment">//ans的最终值恰好是最上面的那张地毯编号</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);<span class="comment">//输出结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人类首张黑洞照片</title>
      <link href="/archives/2078626702/"/>
      <url>/archives/2078626702/</url>
      
        <content type="html"><![CDATA[<p>2019年4月10日9：00，人类首张对黑洞进行直接拍摄的照片发布。</p><p><img src="https://i.loli.net/2019/04/12/5cb090dea8dcc.jpg" /></p><p>这张照片可能并不符合许多人想象中常见的“漩涡”形象，但这是最符合目前学术界公认理论的形象。爱因斯坦，史瓦西，克尔，霍金等历代科学家的理论终于在这一天得到了论证，只不过他们都没有活到看到他们预言之物终于被光学设备记录到的那一天。</p><p>“黑洞”这个概念在20世纪就早已名扬四海，但这个概念一直只是存在于物理学家的计算中，这多少让人想起海王星，但海王星被计算出后几乎是立刻就被天文望远镜所发现，而黑洞从被计算出（1915年12月德国天文学家卡尔·史瓦西计算出爱因斯坦方程的黑洞解。）到2019年黑洞终于被人类的天文望远镜拍摄到，时隔整整103年。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 天文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解 P1002 【过河卒】</title>
      <link href="/archives/2197869946/"/>
      <url>/archives/2197869946/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述">题目描述</h1><p>棋盘上<span class="math inline">\(A\)</span>点有一个过河卒，需要走到目标<span class="math inline">\(B\)</span>点。卒行走的规则：可以向下、或者向右。同时在棋盘上<span class="math inline">\(C\)</span>点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，<span class="math inline">\(A\)</span>点<span class="math inline">\((0, 0)\)</span>、<span class="math inline">\(B\)</span>点<span class="math inline">\((n, m)\)</span>(<span class="math inline">\(n\)</span>, <span class="math inline">\(m\)</span>为不超过<span class="math inline">\(20\)</span>的整数)，同样马的位置坐标是需要给出的。</p><p>现在要求你计算出卒从<span class="math inline">\(A\)</span>点能够到达<span class="math inline">\(B\)</span>点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h1 id="输入输出格式">输入输出格式</h1><h2 id="输入格式">输入格式：</h2><p>一行四个数据，分别表示<span class="math inline">\(B\)</span>点坐标和马的坐标。</p><h2 id="输出格式">输出格式：</h2><p>一个数据，表示所有的路径条数。</p><h1 id="输入输出样例">输入输出样例</h1><h2 id="输入样例1">输入样例#1：</h2><p>6 6 3 3 ## 输出样例#1： 6 # 说明 结果可能很大！ * * *</p><p>看到题目二话不说用了搜索，直到在提交前看了一下算法标签，又看了一下数据范围。。。</p><p>状态转移方程的推导并不复杂，每次判断卒是否能走到这个格子，不可以则为0（显而易见），可以则为下方与左方的值之和。</p><p>上代码，这道题算是一道DP入门题吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> attack[<span class="number">9</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">2</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>&#125;, &#123;<span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dist[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> map[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n, m, x, y;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x + attack[i][<span class="number">0</span>] &lt;= n &amp;&amp; x + attack[i][<span class="number">0</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(y + attack[i][<span class="number">1</span>] &lt;= m &amp;&amp; y + attack[i][<span class="number">1</span>] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                map[x + attack[i][<span class="number">0</span>]][y + attack[i][<span class="number">1</span>]] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;x, &amp;y);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        dist[i][<span class="number">0</span>] = map[i][<span class="number">0</span>] ? k = <span class="number">0</span> : k;</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        dist[<span class="number">0</span>][i] = map[<span class="number">0</span>][i] ? k = <span class="number">0</span> : k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dist[i][j] = map[i][j] ? <span class="number">0</span> : dist[i - <span class="number">1</span>][j] + dist[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, dist[n][m]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> DP </tag>
            
            <tag> 洛谷 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算几何：凸包</title>
      <link href="/archives/704167021/"/>
      <url>/archives/704167021/</url>
      
        <content type="html"><![CDATA[<p>对于初学计算几何的OIer来说，Graham算法是个不错的凸包算法。Graham算法相比极角排序法来说，更为直观也更容易理解。</p><h1 id="数据定义">数据定义</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x = <span class="number">0</span>, <span class="type">double</span> y = <span class="number">0</span>):<span class="built_in">x</span>(x), <span class="built_in">y</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Point</span>(Point a, Point b) &#123;</span><br><span class="line">        <span class="comment">//构造从a到b的向量</span></span><br><span class="line">        x = b.x - a.x;</span><br><span class="line">        y = b.y - a.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">dist</span><span class="params">(<span class="type">const</span> Point&amp; p)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算从自身到点P的距离</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>((x - p.x) * (x - p.x) + (y - p.y) * (y - p.y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="keyword">operator</span> * (<span class="type">const</span> Point&amp; p) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">//计算向量叉积</span></span><br><span class="line">        <span class="keyword">return</span> x * p.y - p.x * y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> Point&amp; p) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">//按照X轴排序</span></span><br><span class="line">        <span class="keyword">return</span> (x == p.x) ? (y &lt; p.y) : (x &lt; p.x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span> &gt;&gt; (istream&amp; in, Point&amp; p) &#123;</span><br><span class="line">        <span class="comment">//重载 &gt;&gt; 运算符使得cin可以输入</span></span><br><span class="line">        in &gt;&gt; p.x &gt;&gt; p.y;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">Point p[MAXN];</span><br><span class="line"><span class="type">int</span> st[MAXN], top = <span class="number">-1</span>; <span class="comment">//点栈</span></span><br><span class="line"><span class="type">int</span> n;</span><br></pre></td></tr></table></figure><h1 id="主程序">主程序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123; <span class="comment">//输入所有点</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">input</span>();</span><br><span class="line">    <span class="built_in">sort</span>(p, p + n); <span class="comment">//对点进行直角坐标排序􏰣􏰳􏰣􏰳􏰮􏰂</span></span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    st[++top] = <span class="number">0</span>; <span class="comment">//将第一个点入栈</span></span><br><span class="line">    st[++top] = <span class="number">1</span>; <span class="comment">//将第二个点入栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="function">Point <span class="title">u</span><span class="params">(p[st[top - <span class="number">1</span>]], p[st[top]])</span></span>; <span class="comment">//计算栈顶两个点构成的向量</span></span><br><span class="line">        <span class="function">Point <span class="title">v</span><span class="params">(p[st[top]], p[i])</span></span>; <span class="comment">//计算当前点与栈顶构成的向量</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(u * v &lt; <span class="number">0</span>) &#123; <span class="comment">//若叉积小于0</span></span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">0</span>) &#123; <span class="comment">//当栈中只有一个元素时，退出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--; <span class="comment">//弹出栈顶</span></span><br><span class="line">            u = <span class="built_in">Point</span>(p[st[top - <span class="number">1</span>]], p[st[top]]); <span class="comment">//更新</span></span><br><span class="line">            v = <span class="built_in">Point</span>(p[st[top]], p[i]); <span class="comment">//更新</span></span><br><span class="line">        &#125;</span><br><span class="line">        st[++top] = i; <span class="comment">//将第i个点压入栈中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += p[st[i]].<span class="built_in">dist</span>(p[st[i + <span class="number">1</span>]]); <span class="comment">//累加下半个凸包的长度</span></span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">-1</span>; <span class="comment">//清空栈</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求出上半个凸包，与前半部分大同小异</span></span><br><span class="line">    st[++top] = <span class="number">0</span>;</span><br><span class="line">    st[++top] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="function">Point <span class="title">u</span><span class="params">(p[st[top - <span class="number">1</span>]], p[st[top]])</span></span>;</span><br><span class="line">        <span class="function">Point <span class="title">v</span><span class="params">(p[st[top]], p[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(u * v &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(top == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            top--;</span><br><span class="line">            u = <span class="built_in">Point</span>(p[st[top - <span class="number">1</span>]], p[st[top]]);</span><br><span class="line">            v = <span class="built_in">Point</span>(p[st[top]], p[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        st[++top] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        ans += p[st[i]].<span class="built_in">dist</span>(p[st[i + <span class="number">1</span>]]);</span><br><span class="line">    &#125;</span><br><span class="line">    top = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; fixed &lt;&lt; ans &lt;&lt; endl; <span class="comment">//控制精度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算几何 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Splay学习笔记</title>
      <link href="/archives/1401793044/"/>
      <url>/archives/1401793044/</url>
      
        <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>伸展树（英语：Splay Tree）是一种能够<strong>自我平衡</strong>的二叉查找树，它能在均摊O(log n)的时间内完成基于伸展（Splay）操作的插入、查找、修改和删除操作。</p><p>众所周知，普通BST在进行各种操作时很容易因为左子树与右子树高度差的问题导致时间复杂度退化为O(n)，Splay为了避免这个问题，使用了一种叫做“伸展”的操作来使左右子树平衡，在后面会介绍。</p><h1 id="定义">定义</h1><h2 id="节点">节点</h2><p><code>node.v</code>：节点node的值</p><p><code>node.father</code>：节点node的父节点</p><p><code>node.ch[0]</code>与<code>node.ch[1]</code>：节点node的左子节点与右子节点</p><p><code>node.size</code>：以节点node为根节点的子树的节点总数</p><p><code>node.cnt</code>：数值与节点node相同的节点的数量（都储存在节点node中）</p><p>代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v, father, ch[<span class="number">2</span>], size, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> v = <span class="number">0</span>, <span class="type">int</span> father = <span class="number">0</span>, <span class="type">int</span> size = <span class="number">0</span>, <span class="type">int</span> cnt = <span class="number">0</span>):<span class="built_in">v</span>(v), <span class="built_in">father</span>(father), <span class="built_in">size</span>(size), <span class="built_in">cnt</span>(cnt) &#123;</span><br><span class="line">        ch[<span class="number">0</span>] = ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="树">树</h2><p><code>root</code>：根节点</p><p><code>cnt</code>：总结点数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node node[MAXN];</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="操作">操作</h1><h2 id="基本操作">基本操作</h2><h3 id="pushup">pushup</h3><p><code>pushup()</code>函数：<strong>更新</strong>节点p的<code>size</code>值</p><h2 id="section"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    node[p].size = node[node[p].ch[<span class="number">0</span>]].size + node[p].cnt + node[node[p].ch[<span class="number">1</span>]].size; <span class="comment">//节点数 = 左子树节点数 + 本身的节点数 + 右子树节点数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="check">check</h3><p><code>check()</code>函数：询问节点p是其父节点的左子节点还是右子节点</p><h2 id="section-1"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node[node[p].father].ch[<span class="number">0</span>] == p ? <span class="number">0</span> : <span class="number">1</span>; <span class="comment">//0代表左子节点，1代表右子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></h2><h3 id="connect">connect</h3><p><code>connect()</code>函数：将节点x连接为节点f的子节点，方向为d (d = 0, 1，同上)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">connect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f, <span class="type">int</span> d)</span> </span>&#123;</span><br><span class="line">    node[f].ch[d] = x; <span class="comment">//将节点f的子节点设置为x</span></span><br><span class="line">    node[x].father = f; <span class="comment">//将节点x的父节点设置为f</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="旋转">旋转</h2><h3 id="rotate">rotate</h3><p>旋转是平衡树最主要的操作，其本质在于，每次进行旋转时，左右子树当中之一高度 -1，另外一棵高度 +1，以达到平衡的目的。</p><p>左旋：</p><p>第一次连边，节点x的子节点成为x的父节点的右子节点</p><p>第二次连边，节点x成为节点x的父节点的父节点的子节点，方向与x的父节点相同</p><p>第三次连边，节点x的父节点成为节点x的左子节点</p><p><img src="https://keepthethink.github.io/images/left_rotate.jpg" /></p><p>右旋：</p><p>第一次连边，节点x的子节点成为x的父节点的左子节点</p><p>第二次连边，节点x成为节点x的父节点的父节点的子节点，方向与x的父节点相同</p><p>第三次连边，节点x的父节点成为节点x的右子节点</p><p><img src="https://keepthethink.github.io/images/right_rotate.jpg" /></p><p>旋转操作只与标为红，蓝，绿的三个部分有关。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = node[x].father, z = node[y].father, d = <span class="built_in">check</span>(x), w = node[x].ch[d ^ <span class="number">1</span>]; <span class="comment">//w判断应该左旋还是右旋</span></span><br><span class="line">    <span class="built_in">connect</span>(w, y, d); <span class="comment">//第一次连边，节点x的子节点连接到x的父节点，方向与节点x相同</span></span><br><span class="line">    <span class="built_in">connect</span>(x, z, <span class="built_in">check</span>(y)); <span class="comment">//第二次连边，节点x连接到节点x的父节点的父节点，方向与x的父节点相同</span></span><br><span class="line">    <span class="built_in">connect</span>(y, x, d ^ <span class="number">1</span>); <span class="comment">//第三次连边，节点x的父节点连接到节点x，方向与节点x原先的方向相反</span></span><br><span class="line">    <span class="built_in">pushup</span>(y); <span class="comment">//更新子树</span></span><br><span class="line">    <span class="built_in">pushup</span>(x); <span class="comment">//更新子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="伸展">伸展</h2><h3 id="splay">splay</h3><p>Splay操作：将节点x旋转到节点dist的子节点。通常是将该节点旋转到根节点，在这种情况下，应当将<code>root</code>置为x</p><p>最朴素的想法：只要父节点不是dist就一直旋转该节点，但这样很容易被某些机（wu）智（liang）出题人卡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> dist = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(node[x].father != dist) &#123;</span><br><span class="line">        <span class="built_in">rotate</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist == <span class="number">0</span>) &#123;</span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，在实际操作中，通常会预判节点x的父节点的方向，若方向一致则旋转其父节点，减少被卡的可能性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> dist = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> f = node[x].father; f = node[x].father, f != dist; <span class="built_in">rotate</span>(x)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[f].father != dist) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(x) == <span class="built_in">check</span>(f)) &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(f); <span class="comment">//方向一致则旋转x的父节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">rotate</span>(x); <span class="comment">//方向不一致则旋转x</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist == <span class="number">0</span>) &#123;</span><br><span class="line">        root = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找">查找</h2><h3 id="find">find</h3><p>查找值为x的节点，找到后将其置为<code>root</code>以便操作。</p><p><code>find</code>操作的意义在于将值为x的节点伸展（splay）到根，在不存在值为x的节点的情况下，应将小于x的节点中最大的节点伸展（splay）到根。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span>(node[cur].ch[x &gt; node[cur].v] != <span class="number">0</span> &amp;&amp; x != node[cur].v) &#123;</span><br><span class="line">        cur = node[cur].ch[x &gt; node[cur].v]; <span class="comment">//查找值为x的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公共操作">公共操作</h2><p>如果将本文讲的Splay打包成一个<code>class</code>，则前文所述的操作应包含在<code>private</code>中，本节所述的操作应包含在<code>public</code>中。</p><h3 id="insert">insert</h3><p>Splay中的<code>insert</code>其实与朴素BST中的<code>insert</code>没有什么区别，但若直接插入可能导致树退化为链，所以要在末尾处调用一次splay()函数，使Splay树保持平衡。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = root, p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="number">0</span> &amp;&amp; node[cur].v != x) &#123;</span><br><span class="line">        p = cur;</span><br><span class="line">        cur = node[cur].ch[x &lt; node[cur].v ? <span class="number">0</span> : <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cur != <span class="number">0</span>) &#123;</span><br><span class="line">        node[cur].cnt++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cur = ++cnt;</span><br><span class="line">        <span class="keyword">if</span>(p != <span class="number">0</span>) &#123;</span><br><span class="line">            node[p].ch[x &lt;= node[p].v ? <span class="number">0</span> : <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        node[cur] = <span class="built_in">Node</span>(x, p, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">splay</span>(cur);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="serial">serial</h3><p><code>serial</code>操作：查询值为x的节点，在<code>find</code>操作的基础上，<code>serial</code>只需要在<code>find</code>过后输出左子树节点数量即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">serial</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">return</span> node[node[root].ch[<span class="number">0</span>]].size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pre">pre</h3><p>找出值为x的节点的前驱，将节点splay到root后在左子树查找最大值即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(node[root].v &lt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = node[root].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(node[cur].ch[<span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        cur = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="suc">suc</h3><p>找出值为x的点的后继，与前驱同理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">suc</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(node[root].v &gt; x) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> cur = node[root].ch[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(node[cur].ch[<span class="number">0</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">        cur = node[cur].ch[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove">remove</h3><p>删除一个节点。</p><p>删除较为复杂，分四步来完成：</p><ol type="1"><li>定义<code>last</code>为节点的前驱，<code>next</code>为节点的后继。</li><li>将<code>last</code>节点splay到<code>root</code>，这时<code>last</code>的左子树皆小于x</li><li>将<code>next</code>节点splay到<code>last</code>的子节右点，此时<code>next</code>的右子树皆大于x</li><li><code>next</code>的左节点<code>rm</code>必然满足 <code>last</code> &lt; rm &lt; <code>next</code>，删除<code>rm</code>即可</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> last = <span class="built_in">pre</span>(x), next = <span class="built_in">suc</span>(x);</span><br><span class="line">    <span class="built_in">splay</span>(last);</span><br><span class="line">    <span class="built_in">splay</span>(next, last);</span><br><span class="line">    <span class="type">int</span> rm = node[next].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(node[rm].cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        node[rm].cnt--;</span><br><span class="line">        <span class="built_in">splay</span>(rm);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        node[next].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pushup</span>(next);</span><br><span class="line">        <span class="built_in">pushup</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rank">rank</h3><p>查找排名为k的节点</p><p>用一个指针cur从root开始查找，每次根据左子树大小于k的关系修改cur以及k。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = root;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(node[cur].ch[<span class="number">0</span>] != <span class="number">0</span> &amp;&amp; k &lt;= node[node[cur].ch[<span class="number">0</span>]].size) &#123;</span><br><span class="line">            cur = node[cur].ch[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &gt; node[node[cur].ch[<span class="number">0</span>]].size + node[cur].cnt) &#123;</span><br><span class="line">            k -= node[node[cur].ch[<span class="number">0</span>]].size + node[cur].cnt;</span><br><span class="line">            cur = node[cur].ch[<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料">参考资料</h1><p><a href="https://zh.wikipedia.org/zh-hans/伸展树">伸展树- 维基百科，自由的百科全书</a></p><p><a href="https://www.youtube.com/watch?v=IBY4NtxmGg8">Splay Tree Introduction</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
            <tag> Splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一维数据结构学习笔记</title>
      <link href="/archives/1580237458/"/>
      <url>/archives/1580237458/</url>
      
        <content type="html"><![CDATA[<h1 id="一维数据结构学习笔记">一维数据结构学习笔记</h1><h2 id="链表">链表</h2><p>链表:按顺序记录元素的线性数据结构。</p><p>其中的“顺序”是逻辑上的顺序，不一定是物理存储上的顺序。</p><p>链表分为单向与双向两种：</p><p>1.单向链表:每个元素只记录了下一个元素的位置。</p><p>2.双向链表:每个元素记录了上一个及下一个元素的位置。</p><p>代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用类来定义链表中的每个元素。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    Node * next = <span class="literal">NULL</span>, * prev = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*前一个元素或者后一个元素可以不存在，所以必须要使用指针类型。*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> v = <span class="number">0</span>, Node * next = <span class="literal">NULL</span>, Node * prev = <span class="literal">NULL</span>):<span class="built_in">v</span>(v), <span class="built_in">next</span>(next), <span class="built_in">prev</span>(prev) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 链表常用操作:构造链表</p><p>通过实例化链表类，创建链表的每个元素并建立元素之间的关系。</p><p>代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造一个只有头尾两个元素的链表。</span></span><br><span class="line">Node* head = <span class="keyword">new</span> <span class="built_in">Node</span>(); </span><br><span class="line">Node* tail = <span class="keyword">new</span> <span class="built_in">Node</span>(); </span><br><span class="line"></span><br><span class="line">head -&gt; next = tail;</span><br><span class="line">tile -&gt; prev = head;</span><br></pre></td></tr></table></figure></p><h3 id="链表常用操作遍历链表">链表常用操作:遍历链表</h3><p>将链表头赋值给临时变量，然后不断寻找下一个元素直到空。</p><p>代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Node* i = head;</span><br><span class="line"><span class="keyword">while</span> (i -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    i = i -&gt; next;</span><br><span class="line">    <span class="comment">//需要对链表元素进行的操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="链表常用操作插入元素">链表常用操作:插入元素</h3><p>找到要插入元素的位置，一般是记录前一个元素。<br />重新设置插入位置两边的元素和插入元素的关系。</p><p>代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在元素p后面插入元素i</span></span><br><span class="line">i -&gt; next = p -&gt; next;</span><br><span class="line">i -&gt; prev = p;</span><br><span class="line"><span class="keyword">if</span> (p -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    p -&gt; next -&gt; prev = i;</span><br><span class="line">&#125;</span><br><span class="line">p -&gt; next = i;</span><br></pre></td></tr></table></figure> 注意:</p><blockquote><p>1.修改关系的顺序.</p><p>2.特判插入链表头的情况。</p></blockquote><h3 id="链表常用操作删除元素">链表常用操作:删除元素</h3><p>首先，找到要删除的元素。</p><p>重新设置该元素的前后元素之间的关系，并根据需要释放元素。 代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    i -&gt; next -&gt; prev = i -&gt; prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i -&gt; prev != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    i -&gt; prev -&gt; next = i -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> i;</span><br></pre></td></tr></table></figure> 注意:</p><blockquote><p>如果有变量用来记录链表头，头被删除时要记得更新。</p><p>链表尾同理。</p></blockquote><h3 id="链表-qa">链表 Q&amp;A</h3><p><strong>Q：</strong> 单向链表可以进行删除元素操作吗?</p><p><strong>A：</strong> 可以。通过预判下一个元素的方式，找到要删除元素的上一个元素，再更新下一个元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pr -&gt; next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    pr -&gt; next = pr -&gt; next -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当然，还是要特判删除链表头的情况。</p><p><strong>Q：</strong> 还有别的方式可以用来实现链表吗?</p><p><strong>A：</strong> 通常情况下，使用数组来实现链表会更加简便。</p><p>给每个元素一个编号(地址)，以代替指针的引用。</p><p>为了记录每个元素的属性，可以使用结构体、二维数组或者多个数组。</p><p><strong>Q：</strong> 用数组实现链表有哪些缺点?</p><p><strong>A：</strong> 1.数组必须一次性初始化，并且长度固定。2.删除元素不会真正的释放空间。</p><h2 id="队列">队列</h2><p>从严格意义上来说，队列是一种特殊的链表，只支持添加队列尾元素和删除队列头元素两种操作。</p><p>或者说，队列是链表的子集。</p><h3 id="队列常用操作从队列尾部添加元素">队列常用操作:从队列尾部添加元素</h3><p>创建一个新元素，将队尾元素的下一个元素指向新元素。</p><p>将队尾移动到新元素。</p><p>代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* newTail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">tail -&gt; next = newTail;</span><br><span class="line">tail = newTail;</span><br></pre></td></tr></table></figure></p><h3 id="队列常用操作从队列头部删除元素">队列常用操作:从队列头部删除元素</h3><p>记录队头元素。</p><p>将队头元素移动到它的下一个元素。根据需要释放旧的队头元素。</p><p>代码实现： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* oldHead = head;</span><br><span class="line">head = head -&gt; next;</span><br><span class="line">oldHead -&gt; next = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure> 注意： &gt; 还要特判队列为空的情况。</p><h3 id="数组一种特殊的队列">数组:一种特殊的队列</h3><p>用两个整数表示数组的下标，作为队头和队尾的指针。</p><p>删除元素则将队头指针+1，添加元素则将队尾指针+1。</p><p>队头指针超过的队尾指针表示队列为空。</p><h3 id="循环队列循环重复利用被删除空间的数组队列">循环队列:循环重复利用被删除空间的数组队列</h3><p>移动指针后如果超出了数组长度，则重置为0。</p><p>当尾指针追赶上头指针时，表示队列溢出。</p><p>定义： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">100</span>;</span><br><span class="line">Node* queue[LENGTH];</span><br><span class="line"><span class="type">int</span> head = <span class="number">0</span>, tile = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p><p>添加元素： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head != (tail + <span class="number">2</span>)) &#123; <span class="comment">// 判断满。 </span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % LENGTH; </span><br><span class="line">        queue[tail] = t;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>删除元素： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head != (tail + <span class="number">1</span>)) &#123; <span class="comment">// 判断空。 </span></span><br><span class="line">        Node* h = queue[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % LENGTH;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="队列-qa">队列 Q&amp;A</h3><p><strong>Q：</strong> 队列是单向链表还是双向链表?</p><p><strong>A：</strong> 使用单向链表足以支持队列的操作。</p><p><strong>Q：</strong> 如果是双向队列，需要额外增加哪些操作?</p><p><strong>A：</strong> 添加时要设置新元素的前一个元素，删除时要清空新队头的前一个元素。</p><p><strong>Q：</strong> 数组队列有哪些优点与缺点?</p><p><strong>A：</strong> 优点：队列不需要删除中间元素，数组完全满足队列的操作要求。</p><p>缺点：删除掉的空间无法被重复利用。</p><p><strong>Q：</strong> 如何区分循环队列是满还是空?</p><p><strong>A：</strong> 有两种方案：</p><blockquote><p>1.用一个额外的变量记录队列的元素个数。</p><p>2.将实际队列的容量变为数组长度-1，让队列空和满时的队尾指针在不同的位置。</p></blockquote><p>本文代码采用的是第二种方案</p><h2 id="栈">栈</h2><p>从严格意义上来说栈是一种特殊的链表，只支持添加栈尾元素和删除栈尾元素两种操作。</p><p>或者说，栈是链表的子集。</p><h3 id="栈常用操作从栈尾部添加元素">栈常用操作:从栈尾部添加元素</h3><p>1.创建一个新元素。<br />2.将新元素的上一个元素指向栈尾元素。<br />3.将栈尾移动到新元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* newTail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">newTail -&gt; prev = tail;</span><br><span class="line">tail = newTail;</span><br></pre></td></tr></table></figure> 注意：还要特判栈为空的情况。</p><h3 id="栈常用操作从栈尾部删除元素">栈常用操作:从栈尾部删除元素</h3><p>1.记录栈尾元素。<br />2.将栈尾元素移动到它的上一个元素。<br />3.将旧栈尾元素的上一个元素置空。根据需要释放旧的栈尾元素。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node* oldTail = tail;</span><br><span class="line">tail = tail -&gt; prev;</span><br><span class="line">oldTail -&gt; prev = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure> 注意：还要特判栈为空的情况。</p><h3 id="数组一种特殊的栈">数组:一种特殊的栈</h3><p>用一个整数表示数组的下标，作为栈尾的指针。</p><p>添加元素则将栈尾指针+1，删除元素则将栈尾指针-1。</p><p>栈尾指针小于栈头元素的下标则表示栈为空。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷题解P1119【灾后重建】</title>
      <link href="/archives/1827780785/"/>
      <url>/archives/1827780785/</url>
      
        <content type="html"><![CDATA[<h1 id="题目背景">题目背景</h1><p><span class="math inline">\(B\)</span>地区在地震过后，所有村庄都造成了一定的损毁，而这场地震却没对公路造成什么影响。但是在村庄重建好之前，所有与未重建完成的村庄的公路均无法通车。换句话说，只有连接着两个重建完成的村庄的公路才能通车，只能到达重建完成的村庄。</p><h1 id="题目描述">题目描述</h1><p>给出<span class="math inline">\(B\)</span>地区的村庄数<span class="math inline">\(N\)</span>，村庄编号从<span class="math inline">\(0\)</span>到<span class="math inline">\(N-1\)</span>，和所有<span class="math inline">\(M\)</span>条公路的长度，公路是双向的。并给出第<span class="math inline">\(i\)</span>个村庄重建完成的时间<span class="math inline">\(t_i\)</span>，你可以认为是同时开始重建并在第<span class="math inline">\(t_i\)</span>天重建完成，并且在当天即可通车。若<span class="math inline">\(t_i\)</span>为<span class="math inline">\(0\)</span>则说明地震未对此地区造成损坏，一开始就可以通车。之后有<span class="math inline">\(Q\)</span>个询问<span class="math inline">\((x, y, t)\)</span>，对于每个询问你要回答在第<span class="math inline">\(t\)</span>天，从村庄<span class="math inline">\(x\)</span>到村庄<span class="math inline">\(y\)</span>的最短路径长度为多少。如果无法找到从<span class="math inline">\(x\)</span>村庄到<span class="math inline">\(y\)</span>村庄的路径，经过若干个已重建完成的村庄，或者村庄<span class="math inline">\(x\)</span>或村庄<span class="math inline">\(y\)</span>在第<span class="math inline">\(t\)</span>天仍未重建完成 ，则需要返回<span class="math inline">\(-1\)</span>。</p><h1 id="输入输出格式">输入输出格式</h1><h2 id="输入格式">输入格式：</h2><p>第一行包含两个正整数<span class="math inline">\(N,M\)</span>，表示了村庄的数目与公路的数量。</p><p>第二行包含<span class="math inline">\(N\)</span>个非负整数<span class="math inline">\(t_0, t_1,…, t_{N-1}\)</span>​，表示了每个村庄重建完成的时间，数据保证了<span class="math inline">\(t_0 ≤ t_1 ≤ … ≤ t_{N-1}​\)</span>。</p><p>接下来<span class="math inline">\(M\)</span>行，每行<span class="math inline">\(3\)</span>个非负整数<span class="math inline">\(i, j, w\)</span>，<span class="math inline">\(w\)</span>为不超过<span class="math inline">\(10000\)</span>的正整数，表示了有一条连接村庄<span class="math inline">\(i\)</span>与村庄<span class="math inline">\(j\)</span>的道路，长度为<span class="math inline">\(w\)</span>，保证<span class="math inline">\(i≠j\)</span>，且对于任意一对村庄只会存在一条道路。</p><p>接下来一行也就是<span class="math inline">\(M+3\)</span>行包含一个正整数<span class="math inline">\(Q\)</span>，表示<span class="math inline">\(Q\)</span>个询问。</p><p>接下来<span class="math inline">\(Q\)</span>行，每行<span class="math inline">\(3\)</span>个非负整数<span class="math inline">\(x, y, t\)</span>，询问在第<span class="math inline">\(t\)</span>天，从村庄<span class="math inline">\(x\)</span>到村庄<span class="math inline">\(y\)</span>的最短路径长度为多少，数据保证了<span class="math inline">\(t\)</span>是不下降的。</p><h2 id="输出格式">输出格式：</h2><p>共<span class="math inline">\(Q\)</span>行，对每一个询问<span class="math inline">\((x, y, t)\)</span>输出对应的答案，即在第<span class="math inline">\(t\)</span>天，从村庄<span class="math inline">\(x\)</span>到村庄<span class="math inline">\(y\)</span>的最短路径长度为多少。如果在第<span class="math inline">\(t\)</span>天无法找到从<span class="math inline">\(x\)</span>村庄到<span class="math inline">\(y\)</span>村庄的路径，经过若干个已重建完成的村庄，或者村庄<span class="math inline">\(x\)</span>或村庄<span class="math inline">\(y\)</span>在第<span class="math inline">\(t\)</span>天仍未修复完成，则输出<span class="math inline">\(-1\)</span>。</p><h1 id="输入输出样例">输入输出样例</h1><h2 id="输入样例1">输入样例#1：</h2><p>4 5 1 2 3 4 0 2 1 2 3 1 3 1 2 2 1 4 0 3 5 4 2 0 2 0 1 2 0 1 3 0 1 4 ## 输出样例#1： -1 -1 5 4 # 说明 对于<span class="math inline">\(30\%\)</span>的数据，有<span class="math inline">\(N≤50\)</span>；</p><p>对于<span class="math inline">\(30\%\)</span>的数据，有<span class="math inline">\(t_i= 0\)</span>，其中有20%20%的数据有<span class="math inline">\(t_i = 0\)</span>且<span class="math inline">\(N&gt;50\)</span>；</p><p>对于<span class="math inline">\(50\%\)</span>的数据，有<span class="math inline">\(Q≤100\)</span>；</p><p>对于<span class="math inline">\(100\%\)</span>的数据，有<span class="math inline">\(N≤200\)</span>，<span class="math inline">\(M≤N \times (N-1)/2\)</span>，<span class="math inline">\(Q≤50000\)</span>，所有输入数据涉及整数均不超过<span class="math inline">\(100000\)</span>。</p><h1 id="说明">说明</h1><p>本题基本上是Floyd的模版题，适合初学Floyd的OIer练习。</p><p>本题的重点在于并非在每一个时刻，每一个节点都可以到达，所以应枚举目前所有可以到达的节点k，并以k为中转点进行更新。</p><p>同时，因为出题人已经给数据排好了顺序，发现未建成时直接中断即可。</p><p>闲话少说，主要看代码注释。</p><p>#代码 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> edge[MAXN][MAXN], times[MAXN];</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init()函数：</span></span><br><span class="line"><span class="comment">Floyd初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">edge[i][j] = (i == j ? <span class="number">0</span> : INF);<span class="comment">//节点到自身的距离为0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">addEdge()函数：</span></span><br><span class="line"><span class="comment">在邻接矩阵中添加一条（双向）边</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">edge[i][j] = edge[j][i] = v;<span class="comment">//双向边处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">input()函数：</span></span><br><span class="line"><span class="comment">输入数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"><span class="built_in">init</span>(); <span class="comment">//读入n, m后进行初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;times[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;v);</span><br><span class="line"><span class="built_in">addEdge</span>(x, y, v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">update()函数：</span></span><br><span class="line"><span class="comment">以k为中转点更新最短路</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">edge[i][j] = <span class="built_in">min</span>(edge[i][j], edge[i][k] + edge[k][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, t;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;t);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//这里是重点</span></span><br><span class="line"><span class="keyword">while</span>(times[cur] &lt;= t &amp;&amp; cur &lt; n) &#123;</span><br><span class="line"><span class="built_in">update</span>(cur);<span class="comment">//若当前可以经过村庄cur，以cur为中转点更新最短路径</span></span><br><span class="line">                        cur++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(times[x] &gt; t || times[y] &gt; t || edge[x][y] == INF) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);<span class="comment">//村庄x尚未建成,村庄x尚未建成或村庄x与村庄y在t时并不连通</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, edge[x][y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">//简洁的main()函数</span></span><br><span class="line"><span class="built_in">input</span>();</span><br><span class="line"><span class="built_in">work</span>();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> Floyd </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2018游记</title>
      <link href="/archives/3769932704/"/>
      <url>/archives/3769932704/</url>
      
        <content type="html"><![CDATA[<h1 id="出师">出师</h1><p>（1）</p><p>起床看见洛谷首页上显示的“距NOIP2018还有-1天”时，差点把嘴里的一口早饭喷了出来。</p><p>不过又想一下，要是一大早看见个“距NOIP2019还有365天”，估计瞬间会感觉压力山大。。。</p><ol start="2" type="1"><li></li></ol><p>进考场前竟然下起了倾盆大雨，从地铁站出来后，举着伞转了一个小时才找到考场，期间不停的被地图坑。</p><p>（我才不会告诉你浪费这么多时间的真正原因是使用迭代加深搜索找考场。）</p><p>进了考场发现有惊喜。。。机房竟然有网！有网！<del>结果在考试前网断了。。。</del>然后开始调整编辑器，<del>以至于没注意到别人都开始打代码了。。。</del></p><h1 id="第一题水题鉴定完毕">第一题，<del>水题，鉴定完毕。</del></h1><p>分析：可能连模拟都算不上，直接从头到尾扫描一遍即可。</p><p>但虽说是水题，也有一些坑点： 1. 读入要用 string + cin + getline()!</p><pre><code>读入要用 string + cin + getline()!读入要用 string + cin + getline()!重要的事情说三遍！@垃圾一个 就是在这一点上炸了。</code></pre><ol start="2" type="1"><li><p>判断时要自编函数或alnum，不能用ctype.h中的isprint()函数，要用isalnum()函数。</p><p>如果你问"isprint()函数是什么"或"isalnum()函数是什么",请自行忽略这段话并自觉编写判断函数。</p><p>别问我为什么，Luogu自测只有20分。</p></li></ol><p>代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(s[i])) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第二题暴力枚举鉴定完毕">第二题，<del>暴力枚举，鉴定完毕。</del></h1><p>分析： 1. 先计算好每一个军营的气势，同时累加双方的气势总和（输入后处理）</p><ol start="2" type="1"><li><p>枚举每一个军营，检查若将工兵放在此位置是否可减少双方差距，并更新最小值与位置。</p></li><li><p><del>输出位置</del></p></li></ol><p>写第一遍时大概思路就酱。</p><p>运行结果：</p><p>样例#1:Pass</p><p>样例#1:Pass</p><p>样例#3: <strong>Beng!</strong></p><p>又看了一下数据范围，对于 100% 的数据，n ≤ 10 ^ 5,ci,s1,s2≤10^9。</p><p>10^9?</p><p>“十年OI一场空，没开long long 见祖宗”，这话果然没错。</p><p>除int main()外的所有int皆换成long long，OK。</p><p>PS:如 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//some code</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 之类的旁门左道，为了安全起见，大家不要滥用哦QwQ。<del>有本事你写个typedef int long long看报不报错</del></p><h1 id="第三题">第三题。。。</h1><p>我这种小蒟蒻怎么可能作对前三题呢QwQ,又怎么可能想到DP正解QwQ</p><p>所以我挥手打了贪心。。。<del>当我发现第三个样例没过时已经来不及了</del></p><p>先说说贪心具体思路： 1. 将学生按照到达时间从小到大排个序 2. 用一个光标变量记录目前接到了第几个学生，如果还有人没被接到，就继续循环知道所有人都被接到为止。 3. 每次循环时检查当前这个人是否值得带，若值得则将光标后移。 4. 每次循环后将时间加上开车所需要的时间。 5. 最后累加总等待时间并输出。</p><p>答案正确率：玄学</p><p>到各大网站上测之，30分有之，80分有之，一切随缘。</p><h1 id="第四题本蒟蒻骗了分没脸来这胡说了">第四题本蒟蒻骗了分，没脸来这胡说了。。。</h1><h1 id="总结">总结</h1><p>咳咳咳。。。</p><h2 id="考试策略的应用">(1)考试策略的应用</h2><p>亏得我这只小蒟蒻还在进考场前看了1h AK NOI 的各位dalao 呕心沥血写的各种考场策略，结果一进考场简直就像接受了A级记忆删除，什么都忘得一干二净： 1. 一，二题打完过了样例就去打第三题。（double-plus-scared） 2. 第三题贪心死活过不了第三个点还执迷不悟认为就是贪心。 3. 第四题明明有子任务放着不做打随机数。</p><h2 id="考场心态的调整">(2)考场心态的调整</h2><p>众所周知，在NOIP考场这种地方要想保持心态稳定是不可能的。然而如果吓得完全写不出代码就凉凉了。总结就是一定要冷静冷静冷静再冷静，一定不要像某人一样，贪心错了都想不到半个动规。</p><p>最后，祝大家： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(NOIP2019.rp &lt; NOIP2019.rp + <span class="number">1</span>) &#123;</span><br><span class="line">    NOIP2019.rp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NOIP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>New Start</title>
      <link href="/archives/3735749857/"/>
      <url>/archives/3735749857/</url>
      
        <content type="html"><![CDATA[<p>折腾一番后终于把之前的文章迁移到GitHub Pages + Hexo的博客上了，之所以选择GitHub是因为这个平台忽然关闭的可能性很小，并且可定制性极强，虽然只能做静态网页，但搭个博客还是绰绰有余的。</p><p>从另一方面来讲，GitHub的信誉也不错，在服务品质上也比国内的诸多流氓公司强得多。</p><span id="more"></span><p>扯了这么多，博客的本质还是发布文章，就看自己能否坚持写下去了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="about-me">About Me</h2><p>一只蒟蒻OIer</p><p>全zypc最菜OI选手</p><p>曾经换过好几个名字，从一开始的HeliumOI一直到现在的“智子”和Sophon，有时也写作SophonCI</p><p>有人问我邮箱地址sophonci117是什么意思，117被同机房的大佬瞬间识破，是指11月7日，十月革命</p><p>至于CI，机房大佬猜是Communist International（共产国际），<del>我自己都信了</del></p><p><del>其实一开始是指Chaos Insurgency</del></p><p><del>自以为是一名马克思主义爱好者</del> 目前已经戒除一切政治相关内容。</p><p>闭关冲击 whk &amp; OI ing</p><h2 id="社交链接">社交链接</h2><p><a href="tencent://Message/?Uin=973178675">QQ</a></p><p><a href="mailto:sophonci117@gmail.com">E-Mail</a></p><p><a href="https://github.com/HeliumOI">GitHub</a></p><p><a href="https://t.me/SophonCI">Telegram</a></p><p><a href="https://www.luogu.com.cn/user/132435">洛谷</a></p><p><a href="https://space.bilibili.com/431327472">Bilibili</a></p><p>经历</p><p>2021.11 CCF CSP-S 一等奖</p><p>2019.12 CCF CSP-J 一等奖，CSP-S二等奖</p><p>2018.12 全国信息学奥林匹克联赛NOIP2018普及组一等奖</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
